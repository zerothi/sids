

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Hamiltonian &mdash; sisl |release| documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="DynamicalMatrix" href="sisl.physics.DynamicalMatrix.html" />
    <link rel="prev" title="DensityMatrix" href="sisl.physics.DensityMatrix.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">Publications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../publications.html">Publications using sisl</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="sisl.html">sisl (<code class="docutils literal notranslate"><span class="pre">sisl</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.geom.html">Common geometries (<code class="docutils literal notranslate"><span class="pre">sisl.geom</span></code>)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="sisl.physics.html">Physical objects (<code class="docutils literal notranslate"><span class="pre">sisl.physics</span></code>)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#brillouin-zone-brillouinzone">Brillouin zone (<code class="docutils literal notranslate"><span class="pre">brillouinzone</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#spin-configuration">Spin configuration</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="sisl.physics.html#physical-quantites">Physical quantites</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.EnergyDensityMatrix.html">EnergyDensityMatrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.DensityMatrix.html">DensityMatrix</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Hamiltonian</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.DynamicalMatrix.html">DynamicalMatrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.SelfEnergy.html">SelfEnergy</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.SemiInfinite.html">SemiInfinite</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.RecursiveSI.html">RecursiveSI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#electrons-electron">Electrons (<code class="docutils literal notranslate"><span class="pre">electron</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#phonons-phonon">Phonons (<code class="docutils literal notranslate"><span class="pre">phonon</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#bloch-s-theorem-bloch">Bloch’s theorem (<code class="docutils literal notranslate"><span class="pre">bloch</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#distribution-functions-distribution">Distribution functions (<code class="docutils literal notranslate"><span class="pre">distribution</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#low-level-objects">Low level objects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sisl.io.html">Input/Output (<code class="docutils literal notranslate"><span class="pre">sisl.io</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.constant.html">Physical constants (<code class="docutils literal notranslate"><span class="pre">sisl.constant</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.unit.html">Unit conversion (<code class="docutils literal notranslate"><span class="pre">sisl.unit</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.shape.html">Shapes (<code class="docutils literal notranslate"><span class="pre">sisl.shape</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.utils.html">Utility routines (<code class="docutils literal notranslate"><span class="pre">sisl.utils</span></code>)</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">sisl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../api.html">API documentation</a> &raquo;</li>
        
          <li><a href="sisl.physics.html">Physical objects (<code class="docutils literal notranslate"><span class="pre">sisl.physics</span></code>)</a> &raquo;</li>
        
      <li>Hamiltonian</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api-generated/sisl.physics.Hamiltonian.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="hamiltonian">
<h1>Hamiltonian<a class="headerlink" href="#hamiltonian" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="sisl.physics.Hamiltonian">
<em class="property">class </em><code class="descclassname">sisl.physics.</code><code class="descname">Hamiltonian</code><span class="sig-paren">(</span><em>geometry</em>, <em>dim=1</em>, <em>dtype=None</em>, <em>nnzpr=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse Hamiltonian matrix object</p>
<p>Assigning or changing Hamiltonian elements is as easy as with standard <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a> assignments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span>
</pre></div>
</div>
<p>which assigns 0.1 as the coupling constant between orbital 2 and 3.
(remember that Python is 0-based elements).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>geometry</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Geometry</span></dt>
<dd><p class="first last">parent geometry to create a density matrix from. The density matrix will
have size equivalent to the number of orbitals in the geometry</p>
</dd>
<dt><strong>dim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or Spin, optional</span></dt>
<dd><p class="first last">number of components per element, may be a <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin" title="sisl.physics.Spin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin</span></code></a> object</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.dtype, optional</span></dt>
<dd><p class="first last">data type contained in the density matrix. See details of <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin" title="sisl.physics.Spin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin</span></code></a> for default values.</p>
</dd>
<dt><strong>nnzpr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">number of initially allocated memory per orbital in the density matrix.
For increased performance this should be larger than the actual number of entries
per orbital.</p>
</dd>
<dt><strong>spin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Spin, optional</span></dt>
<dd><p class="first last">equivalent to <a class="reference internal" href="#sisl.physics.Hamiltonian.dim" title="sisl.physics.Hamiltonian.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a> argument. This keyword-only argument has precedence over <a class="reference internal" href="#sisl.physics.Hamiltonian.dim" title="sisl.physics.Hamiltonian.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a>.</p>
</dd>
<dt><strong>orthogonal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">whether the density matrix corresponds to a non-orthogonal basis. In this case
the dimensionality of the density matrix is one more than <a class="reference internal" href="#sisl.physics.Hamiltonian.dim" title="sisl.physics.Hamiltonian.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a>.
This is a keyword-only argument.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.H" title="sisl.physics.Hamiltonian.H"><code class="xref py py-obj docutils literal notranslate"><span class="pre">H</span></code></a></td>
<td>Access elements to the sparse Hamiltonian</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.S" title="sisl.physics.Hamiltonian.S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">S</span></code></a></td>
<td>Access elements to the sparse overlap</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.dim" title="sisl.physics.Hamiltonian.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a></td>
<td>Number of components per element</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.dkind" title="sisl.physics.Hamiltonian.dkind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dkind</span></code></a></td>
<td>Data type of sparse elements (in str)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.dtype" title="sisl.physics.Hamiltonian.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></td>
<td>Data type of sparse elements</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.finalized" title="sisl.physics.Hamiltonian.finalized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">finalized</span></code></a></td>
<td>Whether the contained data is finalized and non-used elements have been removed</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.geom" title="sisl.physics.Hamiltonian.geom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geom</span></code></a></td>
<td>Associated geometry</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.geometry" title="sisl.physics.Hamiltonian.geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geometry</span></code></a></td>
<td>Associated geometry</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.nnz" title="sisl.physics.Hamiltonian.nnz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nnz</span></code></a></td>
<td>Number of non-zero elements</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.non_orthogonal" title="sisl.physics.Hamiltonian.non_orthogonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">non_orthogonal</span></code></a></td>
<td>True if the object is using a non-orthogonal basis</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.orthogonal" title="sisl.physics.Hamiltonian.orthogonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthogonal</span></code></a></td>
<td>True if the object is using an orthogonal basis</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.shape" title="sisl.physics.Hamiltonian.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></td>
<td>Shape of sparse matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.spin" title="sisl.physics.Hamiltonian.spin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin</span></code></a></td>
<td>Associated spin class</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.DOS" title="sisl.physics.Hamiltonian.DOS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DOS</span></code></a>(E[,&nbsp;k,&nbsp;distribution])</td>
<td>Calculate the DOS at the given energies for a specific <em class="xref py py-obj">k</em> point</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.Hk" title="sisl.physics.Hamiltonian.Hk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hk</span></code></a>([k,&nbsp;dtype,&nbsp;gauge,&nbsp;format])</td>
<td>Setup the Hamiltonian for a given k-point</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.PDOS" title="sisl.physics.Hamiltonian.PDOS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PDOS</span></code></a>(E[,&nbsp;k,&nbsp;distribution])</td>
<td>Calculate the projected DOS at the given energies for a specific <em class="xref py py-obj">k</em> point</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.Rij" title="sisl.physics.Hamiltonian.Rij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rij</span></code></a>([what,&nbsp;dtype])</td>
<td>Create a sparse matrix with the vectors between atoms/orbitals</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.Sk" title="sisl.physics.Hamiltonian.Sk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sk</span></code></a>([k,&nbsp;dtype,&nbsp;gauge,&nbsp;format])</td>
<td>Setup the overlap matrix for a given k-point</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code>(geometry[,&nbsp;dim,&nbsp;dtype,&nbsp;nnzpr])</td>
<td>Initialize Hamiltonian</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.append" title="sisl.physics.Hamiltonian.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(other,&nbsp;axis[,&nbsp;eps])</td>
<td>Append <em class="xref py py-obj">other</em> along <em class="xref py py-obj">axis</em> to construct a new connected sparse matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.construct" title="sisl.physics.Hamiltonian.construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct</span></code></a>(func[,&nbsp;na_iR,&nbsp;method,&nbsp;eta])</td>
<td>Automatically construct the sparse model based on a function that does the setting up of the elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.copy" title="sisl.physics.Hamiltonian.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([dtype])</td>
<td>A copy of this object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.create_construct" title="sisl.physics.Hamiltonian.create_construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_construct</span></code></a>(R,&nbsp;param)</td>
<td>Create a simple function for passing to the <a class="reference internal" href="#sisl.physics.Hamiltonian.construct" title="sisl.physics.Hamiltonian.construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct</span></code></a> function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.cut" title="sisl.physics.Hamiltonian.cut"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut</span></code></a>(seps,&nbsp;axis,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Cuts the sparse orbital model into different parts.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.dHk" title="sisl.physics.Hamiltonian.dHk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dHk</span></code></a>([k,&nbsp;dtype,&nbsp;gauge,&nbsp;format])</td>
<td>Setup the Hamiltonian derivative for a given k-point</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.dSk" title="sisl.physics.Hamiltonian.dSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dSk</span></code></a>([k,&nbsp;dtype,&nbsp;gauge,&nbsp;format])</td>
<td>Setup the <span class="math notranslate nohighlight">\(k\)</span>-derivatie of the overlap matrix for a given k-point</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.ddHk" title="sisl.physics.Hamiltonian.ddHk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddHk</span></code></a>([k,&nbsp;dtype,&nbsp;gauge,&nbsp;format])</td>
<td>Setup the Hamiltonian double derivative for a given k-point</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.ddSk" title="sisl.physics.Hamiltonian.ddSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddSk</span></code></a>([k,&nbsp;dtype,&nbsp;gauge,&nbsp;format])</td>
<td>Setup the double <span class="math notranslate nohighlight">\(k\)</span>-derivatie of the overlap matrix for a given k-point</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.edges" title="sisl.physics.Hamiltonian.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a>([atom,&nbsp;exclude,&nbsp;orbital])</td>
<td>Retrieve edges (connections) of a given <em class="xref py py-obj">atom</em> or list of <em class="xref py py-obj">atom</em>’s</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.eig" title="sisl.physics.Hamiltonian.eig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eig</span></code></a>([k,&nbsp;gauge,&nbsp;eigvals_only])</td>
<td>Returns the eigenvalues of the physical quantity (using the non-Hermitian solver)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.eigenstate" title="sisl.physics.Hamiltonian.eigenstate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenstate</span></code></a>([k,&nbsp;gauge])</td>
<td>Calculate the eigenstates at <em class="xref py py-obj">k</em> and return an <a class="reference internal" href="sisl.physics.EigenstateElectron.html#sisl.physics.EigenstateElectron" title="sisl.physics.EigenstateElectron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenstateElectron</span></code></a> object containing all eigenstates</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.eigenvalue" title="sisl.physics.Hamiltonian.eigenvalue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvalue</span></code></a>([k,&nbsp;gauge])</td>
<td>Calculate the eigenvalues at <em class="xref py py-obj">k</em> and return an <a class="reference internal" href="sisl.physics.EigenvalueElectron.html#sisl.physics.EigenvalueElectron" title="sisl.physics.EigenvalueElectron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenvalueElectron</span></code></a> object containing all eigenvalues for a given <em class="xref py py-obj">k</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.eigh" title="sisl.physics.Hamiltonian.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a>([k,&nbsp;gauge,&nbsp;eigvals_only])</td>
<td>Returns the eigenvalues of the physical quantity</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.eigsh" title="sisl.physics.Hamiltonian.eigsh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigsh</span></code></a>([k,&nbsp;n,&nbsp;gauge,&nbsp;eigvals_only])</td>
<td>Calculates a subset of eigenvalues of the physical quantity  (default 10)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.eliminate_zeros" title="sisl.physics.Hamiltonian.eliminate_zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eliminate_zeros</span></code></a>([atol])</td>
<td>Removes all zero elements from the sparse matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.empty" title="sisl.physics.Hamiltonian.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a>([keep_nnz])</td>
<td>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">empty</span></code> for details</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.fermi_level" title="sisl.physics.Hamiltonian.fermi_level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fermi_level</span></code></a>([bz,&nbsp;q,&nbsp;distribution,&nbsp;q_tol])</td>
<td>Calculate the Fermi-level using a Brillouinzone sampling and a target charge</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.finalize" title="sisl.physics.Hamiltonian.finalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">finalize</span></code></a>()</td>
<td>Finalizes the model</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.fromsp" title="sisl.physics.Hamiltonian.fromsp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromsp</span></code></a>(geometry,&nbsp;P[,&nbsp;S])</td>
<td>Read and return the object with possible overlap</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.iter" title="sisl.physics.Hamiltonian.iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter</span></code></a>([local])</td>
<td>Iterations of the orbital space in the geometry, two indices from loop</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.iter_nnz" title="sisl.physics.Hamiltonian.iter_nnz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_nnz</span></code></a>([atom,&nbsp;orbital])</td>
<td>Iterations of the non-zero elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.nonzero" title="sisl.physics.Hamiltonian.nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code></a>([atom,&nbsp;only_col])</td>
<td>Indices row and column indices where non-zero elements exists</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.prepend" title="sisl.physics.Hamiltonian.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a>(other,&nbsp;axis[,&nbsp;eps])</td>
<td>See <a class="reference internal" href="#sisl.physics.Hamiltonian.append" title="sisl.physics.Hamiltonian.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a> for details</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.read" title="sisl.physics.Hamiltonian.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read</span></code></a>(sile,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Reads Hamiltonian from <em class="xref py py-obj">Sile</em> using <em class="xref py py-obj">read_hamiltonian</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.remove" title="sisl.physics.Hamiltonian.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a>(atom[,&nbsp;orb_index])</td>
<td>Remove a subset of this sparse matrix by only retaining the atoms corresponding to <em class="xref py py-obj">atom</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.remove_orbital" title="sisl.physics.Hamiltonian.remove_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_orbital</span></code></a>(atom,&nbsp;orbital)</td>
<td>Remove a subset of orbitals on <em class="xref py py-obj">atom</em> according to <em class="xref py py-obj">orbital</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.repeat" title="sisl.physics.Hamiltonian.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>(reps,&nbsp;axis)</td>
<td>Create a repeated sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.repeat</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.reset" title="sisl.physics.Hamiltonian.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>([dim,&nbsp;dtype,&nbsp;nnzpr])</td>
<td>The sparsity pattern has all elements removed and everything is reset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.rij" title="sisl.physics.Hamiltonian.rij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rij</span></code></a>([what,&nbsp;dtype])</td>
<td>Create a sparse matrix with the distance between atoms/orbitals</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.set_nsc" title="sisl.physics.Hamiltonian.set_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_nsc</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Reset the number of allowed supercells in the sparse orbital</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.shift" title="sisl.physics.Hamiltonian.shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shift</span></code></a>(E)</td>
<td>Shift the electronic structure by a constant energy</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.spalign" title="sisl.physics.Hamiltonian.spalign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spalign</span></code></a>(other)</td>
<td>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">align</span></code> for details</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.spin_moment" title="sisl.physics.Hamiltonian.spin_moment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_moment</span></code></a>([k])</td>
<td>Calculate the spin moment for the eigenstates for a given <em class="xref py py-obj">k</em> point</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.spin_squared" title="sisl.physics.Hamiltonian.spin_squared"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_squared</span></code></a>([k,&nbsp;n_up,&nbsp;n_down])</td>
<td>Calculate spin-squared expectation value, see <a class="reference internal" href="sisl.physics.electron.spin_squared.html#sisl.physics.electron.spin_squared" title="sisl.physics.electron.spin_squared"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_squared</span></code></a> for details</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.spsame" title="sisl.physics.Hamiltonian.spsame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spsame</span></code></a>(other)</td>
<td>Compare two sparse objects and check whether they have the same entries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.sub" title="sisl.physics.Hamiltonian.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(atom)</td>
<td>Create a subset of this sparse matrix by only retaining the atoms corresponding to <em class="xref py py-obj">atom</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.sub_orbital" title="sisl.physics.Hamiltonian.sub_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_orbital</span></code></a>(atom,&nbsp;orbital)</td>
<td>Retain only a subset of the orbitals on <em class="xref py py-obj">atom</em> according to <em class="xref py py-obj">orbital</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.swap" title="sisl.physics.Hamiltonian.swap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap</span></code></a>(a,&nbsp;b)</td>
<td>Swaps atoms in the sparse geometry to obtain a new order of atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.tile" title="sisl.physics.Hamiltonian.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>(reps,&nbsp;axis)</td>
<td>Create a tiled sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.tile</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.toSparseAtom" title="sisl.physics.Hamiltonian.toSparseAtom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">toSparseAtom</span></code></a>([dim,&nbsp;dtype])</td>
<td>Convert the sparse object (without data) to a new sparse object with equivalent but reduced sparse pattern</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.tocsr" title="sisl.physics.Hamiltonian.tocsr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tocsr</span></code></a>([dim,&nbsp;isc])</td>
<td>Return a <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.2.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">csr_matrix</span></code></a> for the specified dimension</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.transpose" title="sisl.physics.Hamiltonian.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>()</td>
<td>Create the transposed sparse geometry by interchanging supercell indices</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.velocity" title="sisl.physics.Hamiltonian.velocity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">velocity</span></code></a>([k])</td>
<td>Calculate the velocity for the eigenstates for a given <em class="xref py py-obj">k</em> point</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.Hamiltonian.write" title="sisl.physics.Hamiltonian.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a>(sile,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Writes a Hamiltonian to the <em class="xref py py-obj">Sile</em> as implemented in the <code class="code docutils literal notranslate"><span class="pre">Sile.write_hamiltonian</span></code> method</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sisl.physics.Hamiltonian.DOS">
<code class="descname">DOS</code><span class="sig-paren">(</span><em>E</em>, <em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>distribution='gaussian'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.DOS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.DOS" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the DOS at the given energies for a specific <em class="xref py py-obj">k</em> point</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>E</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">energies to calculate the DOS at</p>
</dd>
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd><p class="first last">k-point at which the DOS is calculated</p>
</dd>
<dt><strong>distribution</strong> <span class="classifier-delimiter">:</span> <span class="classifier">func or str, optional</span></dt>
<dd><p class="first last">a function that accepts <span class="math notranslate nohighlight">\(E-\epsilon\)</span> as argument and calculates the
distribution function.</p>
</dd>
<dt><strong>**kwargs: optional</strong></dt>
<dd><p class="first last">additional parameters passed to the <a class="reference internal" href="#sisl.physics.Hamiltonian.eigenvalue" title="sisl.physics.Hamiltonian.eigenvalue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvalue</span></code></a> routine</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="sisl.physics.distribution.html#module-sisl.physics.distribution" title="sisl.physics.distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.physics.distribution</span></code></a></dt>
<dd>setup a distribution function, see details regarding the <a class="reference internal" href="sisl.physics.distribution.html#module-sisl.physics.distribution" title="sisl.physics.distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distribution</span></code></a> argument</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.eigenvalue" title="sisl.physics.Hamiltonian.eigenvalue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvalue</span></code></a></dt>
<dd>method used to calculate the eigenvalues</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.PDOS" title="sisl.physics.Hamiltonian.PDOS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PDOS</span></code></a></dt>
<dd>Calculate projected DOS</dd>
<dt><a class="reference internal" href="sisl.physics.EigenvalueElectron.html#sisl.physics.EigenvalueElectron.DOS" title="sisl.physics.EigenvalueElectron.DOS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenvalueElectron.DOS</span></code></a></dt>
<dd>Underlying method used to calculate the DOS</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.H">
<code class="descname">H</code><a class="headerlink" href="#sisl.physics.Hamiltonian.H" title="Permalink to this definition">¶</a></dt>
<dd><p>Access elements to the sparse Hamiltonian</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.Hk">
<code class="descname">Hk</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>dtype=None</em>, <em>gauge='R'</em>, <em>format='csr'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.Hk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.Hk" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the Hamiltonian for a given k-point</p>
<p>Creation and return of the Hamiltonian for a given k-point (default to Gamma).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">the k-point to setup the Hamiltonian at</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype , optional</span></dt>
<dd><p class="first last">the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></p>
</dd>
<dt><strong>gauge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘R’, ‘r’}</span></dt>
<dd><p class="first last">the chosen gauge, <em class="xref py py-obj">R</em> for cell vector gauge, and <em class="xref py py-obj">r</em> for orbital distance
gauge.</p>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘csr’, ‘array’, ‘dense’, ‘coo’, …}</span></dt>
<dd><p class="first last">the returned format of the matrix, defaulting to the <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>/<em class="xref py py-obj">’dense’</em>/<em class="xref py py-obj">’matrix’</em>).</p>
</dd>
<dt><strong>spin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">if the Hamiltonian is a spin polarized one can extract the specific spin direction
matrix by passing an integer (0 or 1). If the Hamiltonian is not <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a>
this keyword is ignored.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>object</strong> <span class="classifier-delimiter">:</span> <span class="classifier">the Hamiltonian matrix at <span class="math notranslate nohighlight">\(k\)</span>. The returned object depends on <em class="xref py py-obj">format</em>.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.dHk" title="sisl.physics.Hamiltonian.dHk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dHk</span></code></a></dt>
<dd>Hamiltonian derivative with respect to <em class="xref py py-obj">k</em></dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.ddHk" title="sisl.physics.Hamiltonian.ddHk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddHk</span></code></a></dt>
<dd>Hamiltonian double derivative with respect to <em class="xref py py-obj">k</em></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\mathbf H(k) = \mathbf H_{\nu\mu} e^{i k R}\]</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(\nu\)</span>, <span class="math notranslate nohighlight">\(\mu\)</span> are orbital indices.</p>
<p>Another possible gauge is the orbital distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\mathbf H(k) = \mathbf H_{\nu\mu} e^{i k r}\]</div>
<p>where <span class="math notranslate nohighlight">\(r\)</span> is the distance between the orbitals.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.PDOS">
<code class="descname">PDOS</code><span class="sig-paren">(</span><em>E</em>, <em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>distribution='gaussian'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.PDOS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.PDOS" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the projected DOS at the given energies for a specific <em class="xref py py-obj">k</em> point</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>E</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">energies to calculate the projected DOS at</p>
</dd>
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd><p class="first last">k-point at which the projected DOS is calculated</p>
</dd>
<dt><strong>distribution</strong> <span class="classifier-delimiter">:</span> <span class="classifier">func or str, optional</span></dt>
<dd><p class="first last">a function that accepts <span class="math notranslate nohighlight">\(E-\epsilon\)</span> as argument and calculates the
distribution function.</p>
</dd>
<dt><strong>**kwargs: optional</strong></dt>
<dd><p class="first last">additional parameters passed to the <a class="reference internal" href="#sisl.physics.Hamiltonian.eigenstate" title="sisl.physics.Hamiltonian.eigenstate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenstate</span></code></a> routine</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="sisl.physics.distribution.html#module-sisl.physics.distribution" title="sisl.physics.distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.physics.distribution</span></code></a></dt>
<dd>setup a distribution function, see details regarding the <a class="reference internal" href="sisl.physics.distribution.html#module-sisl.physics.distribution" title="sisl.physics.distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distribution</span></code></a> argument</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.eigenstate" title="sisl.physics.Hamiltonian.eigenstate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenstate</span></code></a></dt>
<dd>method used to calculate the eigenstates</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.DOS" title="sisl.physics.Hamiltonian.DOS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DOS</span></code></a></dt>
<dd>Calculate total DOS</dd>
<dt><a class="reference internal" href="sisl.physics.EigenstateElectron.html#sisl.physics.EigenstateElectron.PDOS" title="sisl.physics.EigenstateElectron.PDOS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenstateElectron.PDOS</span></code></a></dt>
<dd>Underlying method used to calculate the projected DOS</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.Rij">
<code class="descname">Rij</code><span class="sig-paren">(</span><em>what='orbital'</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.Rij" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse matrix with the vectors between atoms/orbitals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>what</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘orbital’, ‘atom’}</span></dt>
<dd><p class="first last">which kind of sparse vector matrix to return, either an atomic vector matrix
or an orbital vector matrix. The orbital matrix is equivalent to the atomic
one with the same vectors repeated for the same atomic orbitals.
The default is the same type as the parent class.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype, optional</span></dt>
<dd><p class="first last">the data-type of the sparse matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The returned sparse matrix with vectors are taken from the current sparse pattern.
I.e. a subsequent addition of sparse elements will make them inequivalent.
It is thus important to <em>only</em> create the sparse vector matrix when the sparse
structure is completed.</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.S">
<code class="descname">S</code><a class="headerlink" href="#sisl.physics.Hamiltonian.S" title="Permalink to this definition">¶</a></dt>
<dd><p>Access elements to the sparse overlap</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.Sk">
<code class="descname">Sk</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>dtype=None</em>, <em>gauge='R'</em>, <em>format='csr'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.Sk" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the overlap matrix for a given k-point</p>
<p>Creation and return of the overlap matrix for a given k-point (default to Gamma).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd><p class="first last">the k-point to setup the overlap at (default Gamma point)</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype, optional</span></dt>
<dd><p class="first last">the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></p>
</dd>
<dt><strong>gauge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘R’, ‘r’}</span></dt>
<dd><p class="first last">the chosen gauge, <em class="xref py py-obj">R</em> for cell vector gauge, and <em class="xref py py-obj">r</em> for orbital distance
gauge.</p>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘csr’, ‘array’, ‘matrix’, ‘coo’, …}</span></dt>
<dd><p class="first last">the returned format of the matrix, defaulting to the <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>/<em class="xref py py-obj">’dense’</em>/<em class="xref py py-obj">’matrix’</em>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>object</strong> <span class="classifier-delimiter">:</span> <span class="classifier">the overlap matrix for the <span class="math notranslate nohighlight">\(k\)</span>-point, <em class="xref py py-obj">format</em> determines the object type.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.dSk" title="sisl.physics.Hamiltonian.dSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dSk</span></code></a></dt>
<dd>Overlap matrix derivative with respect to <em class="xref py py-obj">k</em></dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.ddSk" title="sisl.physics.Hamiltonian.ddSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddSk</span></code></a></dt>
<dd>Overlap matrix double derivative with respect to <em class="xref py py-obj">k</em></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\mathbf S(k) = \mathbf S_{\nu\mu} e^{i k R}\]</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(\nu\)</span>, <span class="math notranslate nohighlight">\(\mu\)</span> are orbital indices.</p>
<p>Another possible gauge is the orbital distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\mathbf S(k) = \mathbf S_{\nu\mu} e^{i k r}\]</div>
<p>where <span class="math notranslate nohighlight">\(r\)</span> is the distance between the orbitals.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>other</em>, <em>axis</em>, <em>eps=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append <em class="xref py py-obj">other</em> along <em class="xref py py-obj">axis</em> to construct a new connected sparse matrix</p>
<p>This method tries to append two sparse geometry objects together by
the following these steps:</p>
<ol class="arabic simple">
<li>Create the new extended geometry</li>
<li>Use neighbor cell couplings from <em class="xref py py-obj">self</em> as the couplings to <em class="xref py py-obj">other</em>
This <em>may</em> cause problems if the coupling atoms are not exactly equi-positioned.
If the coupling coordinates and the coordinates in <em class="xref py py-obj">other</em> differ by more than
0.001 Ang, a warning will be issued.
If this difference is above <em class="xref py py-obj">eps</em> the couplings will be removed.</li>
</ol>
<p>When appending sparse matrices made up of atoms, this method assumes that
the orbitals on the overlapping atoms have the same orbitals, as well as the
same orbital ordering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">must be an object of the same type as <em class="xref py py-obj">self</em></p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">axis to append the two sparse geometries along</p>
</dd>
<dt><strong>eps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">tolerance that all coordinates <em>must</em> be within to allow an append.
It is important that this value is smaller than half the distance between
the two closests atoms such that there is no ambiguity in selecting
equivalent atoms. An internal stricter eps is used as a baseline, see above.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>object</strong></dt>
<dd><p class="first last">a new instance with two sparse matrices joined and appended together</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError if atomic coordinates does not overlap within `eps`</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.prepend" title="sisl.physics.Hamiltonian.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt>
<dd>equivalent scheme as this method</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.transpose" title="sisl.physics.Hamiltonian.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a></dt>
<dd>ensure hermiticity by using this routine</dd>
</dl>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.append</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.prepend</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This routine and how it is functioning may change in future releases.
There are many design choices in how to assign the matrix elements when
combining two models and it is not clear what is the best procedure.</p>
<p>The current implentation does not preserve the hermiticity of the matrix.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sporb</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="o">....</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">forced_hermitian</span> <span class="o">=</span> <span class="p">(</span><span class="n">sporb</span> <span class="o">+</span> <span class="n">sporb</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">*</span> <span class="mf">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.construct">
<code class="descname">construct</code><span class="sig-paren">(</span><em>func</em>, <em>na_iR=1000</em>, <em>method='rand'</em>, <em>eta=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.construct" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically construct the sparse model based on a function that does the setting up of the elements</p>
<p>This may be called in two variants.</p>
<ol class="arabic simple">
<li>Pass a function (<em class="xref py py-obj">func</em>), see e.g. <code class="docutils literal notranslate"><span class="pre">create_construct</span></code>
which does the setting up.</li>
<li>Pass a tuple/list in <em class="xref py py-obj">func</em> which consists of two
elements, one is <code class="docutils literal notranslate"><span class="pre">R</span></code> the radii parameters for
the corresponding parameters.
The second is the parameters
corresponding to the <code class="docutils literal notranslate"><span class="pre">R[i]</span></code> elements.
In this second case all atoms must only have
one orbital.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func: callable or array_like</strong></dt>
<dd><p class="first">this function <em>must</em> take 4 arguments.
1. Is this object (<code class="docutils literal notranslate"><span class="pre">self</span></code>)
2. Is the currently examined atom (<code class="docutils literal notranslate"><span class="pre">ia</span></code>)
3. Is the currently bounded indices (<code class="docutils literal notranslate"><span class="pre">idxs</span></code>)
4. Is the currently bounded indices atomic coordinates (<code class="docutils literal notranslate"><span class="pre">idxs_xyz</span></code>)
An example <em class="xref py py-obj">func</em> could be:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">idxs_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.44</span><span class="p">],</span> <span class="n">idx</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="n">idxs_xyz</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.7</span>
</pre></div>
</div>
</dd>
<dt><strong>na_iR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">number of atoms within the sphere for speeding
up the <em class="xref py py-obj">iter_block</em> loop.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘rand’, str}</span></dt>
<dd><p class="first last">method used in <em class="xref py py-obj">Geometry.iter_block</em>, see there for details</p>
</dd>
<dt><strong>eta: bool, optional</strong></dt>
<dd><p class="first last">whether an ETA will be printed</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.create_construct" title="sisl.physics.Hamiltonian.create_construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_construct</span></code></a></dt>
<dd>a generic function used to create a generic function which this routine requires</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.tile" title="sisl.physics.Hamiltonian.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt>
<dd>tiling <em>after</em> construct is much faster for very large systems</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.repeat" title="sisl.physics.Hamiltonian.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a></dt>
<dd>repeating <em>after</em> construct is much faster for very large systems</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of this object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype, optional</span></dt>
<dd><p class="first last">it is possible to convert the data to a different data-type
If not specified, it will use <code class="docutils literal notranslate"><span class="pre">self.dtype</span></code></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.create_construct">
<code class="descname">create_construct</code><span class="sig-paren">(</span><em>R</em>, <em>param</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.create_construct" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a simple function for passing to the <a class="reference internal" href="#sisl.physics.Hamiltonian.construct" title="sisl.physics.Hamiltonian.construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct</span></code></a> function.</p>
<p>This is simply to leviate the creation of simplistic
functions needed for setting up the sparse elements.</p>
<p>Basically this returns a function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">idxs_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">idxs</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">radii parameters for different shells.
Must have same length as <em class="xref py py-obj">param</em> or one less.
If one less it will be extended with <code class="docutils literal notranslate"><span class="pre">R[0]/100</span></code></p>
</dd>
<dt><strong>param</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">coupling constants corresponding to the <em class="xref py py-obj">R</em>
ranges. <code class="docutils literal notranslate"><span class="pre">param[0,:]</span></code> are the elements
for the all atoms within <code class="docutils literal notranslate"><span class="pre">R[0]</span></code> of each atom.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.construct" title="sisl.physics.Hamiltonian.construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct</span></code></a></dt>
<dd>routine to create the sparse matrix from a generic function (as returned from <a class="reference internal" href="#sisl.physics.Hamiltonian.create_construct" title="sisl.physics.Hamiltonian.create_construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_construct</span></code></a>)</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function only works for geometry sparse matrices (i.e. one
element per atom). If you have more than one element per atom
you have to implement the function your-self.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.cut">
<code class="descname">cut</code><span class="sig-paren">(</span><em>seps</em>, <em>axis</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Cuts the sparse orbital model into different parts.</p>
<p>Recreates a new sparse orbital object with only the cutted
atoms in the structure.</p>
<p>Cutting is the opposite of tiling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>seps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of times the structure will be cut</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">the axis that will be cut</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.dHk">
<code class="descname">dHk</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>dtype=None</em>, <em>gauge='R'</em>, <em>format='csr'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.dHk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.dHk" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the Hamiltonian derivative for a given k-point</p>
<p>Creation and return of the Hamiltonian derivative for a given k-point (default to Gamma).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">the k-point to setup the Hamiltonian at</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype , optional</span></dt>
<dd><p class="first last">the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></p>
</dd>
<dt><strong>gauge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘R’, ‘r’}</span></dt>
<dd><p class="first last">the chosen gauge, <em class="xref py py-obj">R</em> for cell vector gauge, and <em class="xref py py-obj">r</em> for orbital distance
gauge.</p>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘csr’, ‘array’, ‘dense’, ‘coo’, …}</span></dt>
<dd><p class="first last">the returned format of the matrix, defaulting to the <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>/<em class="xref py py-obj">’dense’</em>/<em class="xref py py-obj">’matrix’</em>).</p>
</dd>
<dt><strong>spin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">if the Hamiltonian is a spin polarized one can extract the specific spin direction
matrix by passing an integer (0 or 1). If the Hamiltonian is not <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a>
this keyword is ignored.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple</strong> <span class="classifier-delimiter">:</span> <span class="classifier">for each of the Cartesian directions a <span class="math notranslate nohighlight">\(\partial \mathbf H(k)/\partial k_\alpha\)</span> is returned.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.Hk" title="sisl.physics.Hamiltonian.Hk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hk</span></code></a></dt>
<dd>Hamiltonian with respect to <em class="xref py py-obj">k</em></dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.ddHk" title="sisl.physics.Hamiltonian.ddHk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddHk</span></code></a></dt>
<dd>Hamiltonian double derivative with respect to <em class="xref py py-obj">k</em></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\nabla_k \mathbf H_\alpha(k) = i R_\alpha \mathbf H_{\nu\mu} e^{i k R}\]</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(\nu\)</span>, <span class="math notranslate nohighlight">\(\mu\)</span> are orbital indices.
And <span class="math notranslate nohighlight">\(\alpha\)</span> is one of the Cartesian directions.</p>
<p>Another possible gauge is the orbital distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\nabla_k \mathbf H_\alpha(k) = i r_\alpha \mathbf H_{\nu\mu} e^{i k r}\]</div>
<p>where <span class="math notranslate nohighlight">\(r\)</span> is the distance between the orbitals.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.dSk">
<code class="descname">dSk</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>dtype=None</em>, <em>gauge='R'</em>, <em>format='csr'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.dSk" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the <span class="math notranslate nohighlight">\(k\)</span>-derivatie of the overlap matrix for a given k-point</p>
<p>Creation and return of the derivative of the overlap matrix for a given k-point (default to Gamma).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd><p class="first last">the k-point to setup the overlap at (default Gamma point)</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype, optional</span></dt>
<dd><p class="first last">the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></p>
</dd>
<dt><strong>gauge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘R’, ‘r’}</span></dt>
<dd><p class="first last">the chosen gauge, <em class="xref py py-obj">R</em> for cell vector gauge, and <em class="xref py py-obj">r</em> for orbital distance
gauge.</p>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘csr’, ‘array’, ‘matrix’, ‘coo’, …}</span></dt>
<dd><p class="first last">the returned format of the matrix, defaulting to the <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>/<em class="xref py py-obj">’dense’</em>/<em class="xref py py-obj">’matrix’</em>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple</strong> <span class="classifier-delimiter">:</span> <span class="classifier">for each of the Cartesian directions a <span class="math notranslate nohighlight">\(\partial \mathbf S(k)/\partial k\)</span> is returned.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.Sk" title="sisl.physics.Hamiltonian.Sk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sk</span></code></a></dt>
<dd>Overlap matrix at <em class="xref py py-obj">k</em></dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.ddSk" title="sisl.physics.Hamiltonian.ddSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddSk</span></code></a></dt>
<dd>Overlap matrix double derivative at <em class="xref py py-obj">k</em></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\nabla_k \mathbf S_\alpha(k) = i R_\alpha \mathbf S_{\nu\mu} e^{i k R}\]</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(\nu\)</span>, <span class="math notranslate nohighlight">\(\mu\)</span> are orbital indices.
And <span class="math notranslate nohighlight">\(\alpha\)</span> is one of the Cartesian directions.</p>
<p>Another possible gauge is the orbital distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\nabla_k \mathbf S_\alpha(k) = i r_\alpha \mathbf S_{ij} e^{i k r}\]</div>
<p>where <span class="math notranslate nohighlight">\(r\)</span> is the distance between the orbitals.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.ddHk">
<code class="descname">ddHk</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>dtype=None</em>, <em>gauge='R'</em>, <em>format='csr'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.ddHk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.ddHk" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the Hamiltonian double derivative for a given k-point</p>
<p>Creation and return of the Hamiltonian double derivative for a given k-point (default to Gamma).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">the k-point to setup the Hamiltonian at</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype , optional</span></dt>
<dd><p class="first last">the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></p>
</dd>
<dt><strong>gauge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘R’, ‘r’}</span></dt>
<dd><p class="first last">the chosen gauge, <em class="xref py py-obj">R</em> for cell vector gauge, and <em class="xref py py-obj">r</em> for orbital distance
gauge.</p>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘csr’, ‘array’, ‘dense’, ‘coo’, …}</span></dt>
<dd><p class="first last">the returned format of the matrix, defaulting to the <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>/<em class="xref py py-obj">’dense’</em>/<em class="xref py py-obj">’matrix’</em>).</p>
</dd>
<dt><strong>spin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">if the Hamiltonian is a spin polarized one can extract the specific spin direction
matrix by passing an integer (0 or 1). If the Hamiltonian is not <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a>
this keyword is ignored.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple of tuples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">for each of the Cartesian directions</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.Hk" title="sisl.physics.Hamiltonian.Hk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hk</span></code></a></dt>
<dd>Hamiltonian with respect to <em class="xref py py-obj">k</em></dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.dHk" title="sisl.physics.Hamiltonian.dHk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dHk</span></code></a></dt>
<dd>Hamiltonian derivative with respect to <em class="xref py py-obj">k</em></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\nabla_k^2 \mathbf H_{\alpha\beta}(k) = - R_\alpha R_\beta \mathbf H_{\nu\mu} e^{i k R}\]</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(\nu\)</span>, <span class="math notranslate nohighlight">\(\mu\)</span> are orbital indices.
And <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are one of the Cartesian directions.</p>
<p>Another possible gauge is the orbital distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\nabla_k^2 \mathbf H_{\alpha\beta}(k) = - r_\alpha r_\beta \mathbf H_{\nu\mu} e^{i k r}\]</div>
<p>where <span class="math notranslate nohighlight">\(r\)</span> is the distance between the orbitals.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.ddSk">
<code class="descname">ddSk</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>dtype=None</em>, <em>gauge='R'</em>, <em>format='csr'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.ddSk" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the double <span class="math notranslate nohighlight">\(k\)</span>-derivatie of the overlap matrix for a given k-point</p>
<p>Creation and return of the double derivative of the overlap matrix for a given k-point (default to Gamma).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd><p class="first last">the k-point to setup the overlap at (default Gamma point)</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype, optional</span></dt>
<dd><p class="first last">the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></p>
</dd>
<dt><strong>gauge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘R’, ‘r’}</span></dt>
<dd><p class="first last">the chosen gauge, <em class="xref py py-obj">R</em> for cell vector gauge, and <em class="xref py py-obj">r</em> for orbital distance
gauge.</p>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘csr’, ‘array’, ‘matrix’, ‘coo’, …}</span></dt>
<dd><p class="first last">the returned format of the matrix, defaulting to the <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>/<em class="xref py py-obj">’dense’</em>/<em class="xref py py-obj">’matrix’</em>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple of tuples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">for each of the Cartesian directions</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.Sk" title="sisl.physics.Hamiltonian.Sk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sk</span></code></a></dt>
<dd>Overlap matrix at <em class="xref py py-obj">k</em></dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.dSk" title="sisl.physics.Hamiltonian.dSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dSk</span></code></a></dt>
<dd>Overlap matrix derivative at <em class="xref py py-obj">k</em></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\nabla_k^2 \mathbf S_{\alpha\beta}(k) = - R_\alpha R_\beta \mathbf S_{\nu\mu} e^{i k R}\]</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(\nu\)</span>, <span class="math notranslate nohighlight">\(\mu\)</span> are orbital indices.
And <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are one of the Cartesian directions.</p>
<p>Another possible gauge is the orbital distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\nabla_k^2 \mathbf S_{\alpha\beta}(k) = - r_\alpha r_\beta \mathbf S_{ij} e^{i k r}\]</div>
<p>where <span class="math notranslate nohighlight">\(r\)</span> is the distance between the orbitals.</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.dim">
<code class="descname">dim</code><a class="headerlink" href="#sisl.physics.Hamiltonian.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of components per element</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.dkind">
<code class="descname">dkind</code><a class="headerlink" href="#sisl.physics.Hamiltonian.dkind" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type of sparse elements (in str)</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#sisl.physics.Hamiltonian.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type of sparse elements</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.edges">
<code class="descname">edges</code><span class="sig-paren">(</span><em>atom=None</em>, <em>exclude=None</em>, <em>orbital=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve edges (connections) of a given <em class="xref py py-obj">atom</em> or list of <em class="xref py py-obj">atom</em>’s</p>
<p>The returned edges are unique and sorted (see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.unique.html#numpy.unique" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.unique</span></code></a>) and are returned
in supercell indices (i.e. <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">edge</span> <span class="pre">&lt;</span> <span class="pre">self.geometry.no_s</span></code>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>atom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of int</span></dt>
<dd><p class="first last">the edges are returned only for the given atom (but by using  all orbitals of the
requested atom). The returned edges are also atoms.</p>
</dd>
<dt><strong>exclude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of int, optional</span></dt>
<dd><p class="first last">remove edges which are in the <em class="xref py py-obj">exclude</em> list.
Default to <em class="xref py py-obj">atom</em>.</p>
</dd>
<dt><strong>orbital</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of int</span></dt>
<dd><p class="first last">the edges are returned only for the given orbital. The returned edges are orbitals.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseCSR.edges</span></code></dt>
<dd>the underlying routine used for extracting the edges</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.eig">
<code class="descname">eig</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>gauge='R'</em>, <em>eigvals_only=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the eigenvalues of the physical quantity (using the non-Hermitian solver)</p>
<p>Setup the system and overlap matrix with respect to
the given k-point and calculate the eigenvalues.</p>
<p>All subsequent arguments gets passed directly to <code class="code docutils literal notranslate"><span class="pre">scipy.linalg.eig</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">the spin-component to calculate the eigenvalue spectrum of, note that
this parameter is only valid for <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a> matrices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.eigenstate">
<code class="descname">eigenstate</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>gauge='R'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.eigenstate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.eigenstate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the eigenstates at <em class="xref py py-obj">k</em> and return an <a class="reference internal" href="sisl.physics.EigenstateElectron.html#sisl.physics.EigenstateElectron" title="sisl.physics.EigenstateElectron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenstateElectron</span></code></a> object containing all eigenstates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like*3, optional</span></dt>
<dd><p class="first last">the k-point at which to evaluate the eigenstates at</p>
</dd>
<dt><strong>gauge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">the gauge used for calculating the eigenstates</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">if <code class="docutils literal notranslate"><span class="pre">True</span></code>, <a class="reference internal" href="#sisl.physics.Hamiltonian.eigsh" title="sisl.physics.Hamiltonian.eigsh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigsh</span></code></a> will be called, else <a class="reference internal" href="#sisl.physics.Hamiltonian.eigh" title="sisl.physics.Hamiltonian.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a> will be
called (default).</p>
</dd>
<dt><strong>**kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">passed arguments to the <a class="reference internal" href="#sisl.physics.Hamiltonian.eigh" title="sisl.physics.Hamiltonian.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a> routine</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>EigenstateElectron</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.eigh" title="sisl.physics.Hamiltonian.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a></dt>
<dd>eigenvalue routine</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.eigsh" title="sisl.physics.Hamiltonian.eigsh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigsh</span></code></a></dt>
<dd>eigenvalue routine</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.eigenvalue">
<code class="descname">eigenvalue</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>gauge='R'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.eigenvalue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.eigenvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the eigenvalues at <em class="xref py py-obj">k</em> and return an <a class="reference internal" href="sisl.physics.EigenvalueElectron.html#sisl.physics.EigenvalueElectron" title="sisl.physics.EigenvalueElectron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenvalueElectron</span></code></a> object containing all eigenvalues for a given <em class="xref py py-obj">k</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like*3, optional</span></dt>
<dd><p class="first last">the k-point at which to evaluate the eigenvalues at</p>
</dd>
<dt><strong>gauge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">the gauge used for calculating the eigenvalues</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">if <code class="docutils literal notranslate"><span class="pre">True</span></code>, <a class="reference internal" href="#sisl.physics.Hamiltonian.eigsh" title="sisl.physics.Hamiltonian.eigsh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigsh</span></code></a> will be called, else <a class="reference internal" href="#sisl.physics.Hamiltonian.eigh" title="sisl.physics.Hamiltonian.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a> will be
called (default).</p>
</dd>
<dt><strong>**kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">passed arguments to the <a class="reference internal" href="#sisl.physics.Hamiltonian.eigh" title="sisl.physics.Hamiltonian.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a> routine</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>EigenvalueElectron</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.eigh" title="sisl.physics.Hamiltonian.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a></dt>
<dd>eigenvalue routine</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.eigsh" title="sisl.physics.Hamiltonian.eigsh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigsh</span></code></a></dt>
<dd>eigenvalue routine</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.eigh">
<code class="descname">eigh</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>gauge='R'</em>, <em>eigvals_only=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.eigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the eigenvalues of the physical quantity</p>
<p>Setup the system and overlap matrix with respect to
the given k-point and calculate the eigenvalues.</p>
<p>All subsequent arguments gets passed directly to <code class="code docutils literal notranslate"><span class="pre">scipy.linalg.eigh</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">the spin-component to calculate the eigenvalue spectrum of, note that
this parameter is only valid for <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a> matrices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.eigsh">
<code class="descname">eigsh</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>n=10</em>, <em>gauge='R'</em>, <em>eigvals_only=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.eigsh" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a subset of eigenvalues of the physical quantity  (default 10)</p>
<p>Setup the quantity and overlap matrix with respect to
the given k-point and calculate a subset of the eigenvalues using the sparse algorithms.</p>
<p>All subsequent arguments gets passed directly to <code class="code docutils literal notranslate"><span class="pre">scipy.linalg.eigsh</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">the spin-component to calculate the eigenvalue spectrum of, note that
this parameter is only valid for <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a> matrices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.eliminate_zeros">
<code class="descname">eliminate_zeros</code><span class="sig-paren">(</span><em>atol=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.eliminate_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all zero elements from the sparse matrix</p>
<p>This is an <em>in-place</em> operation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>atol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">absolute tolerance equal or below this value will be considered 0.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.empty">
<code class="descname">empty</code><span class="sig-paren">(</span><em>keep_nnz=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">empty</span></code> for details</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.fermi_level">
<code class="descname">fermi_level</code><span class="sig-paren">(</span><em>bz=None</em>, <em>q=None</em>, <em>distribution='fermi_dirac'</em>, <em>q_tol=1e-12</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.fermi_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.fermi_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Fermi-level using a Brillouinzone sampling and a target charge</p>
<p>The Fermi-level will be calculated using an iterative approach by first calculating all eigenvalues
and subsequently fitting the Fermi level to the final charge (<em class="xref py py-obj">q</em>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bz</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Brillouinzone, optional</span></dt>
<dd><p class="first last">sampled k-points and weights, the <code class="docutils literal notranslate"><span class="pre">bz.parent</span></code> will be equal to this object upon return
default to Gamma-point</p>
</dd>
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, list of float, optional</span></dt>
<dd><p class="first last">seeked charge, if not set will be equal to <code class="docutils literal notranslate"><span class="pre">self.geometry.q0</span></code>. If a list of two is passed
there will be calculated a Fermi-level per spin-channel. If the Hamiltonian is not spin-polarized
the sum of the list will be used and only a single fermi-level will be returned.</p>
</dd>
<dt><strong>distribution</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, func, optional</span></dt>
<dd><p class="first last">used distribution, must accept the keyword <code class="docutils literal notranslate"><span class="pre">mu</span></code> as parameter for the Fermi-level</p>
</dd>
<dt><strong>q_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">tolerance of charge for finding the Fermi-level</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fermi-level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">the Fermi-level of the system (or two if two different charges are passed)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the model</p>
<p>Finalizes the model so that all non-used elements are removed. I.e. this simply reduces the memory requirement for the sparse matrix.</p>
<p>Note that adding more elements to the sparse matrix is more time-consuming than for a non-finalized sparse matrix due to the
internal data-representation.</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.finalized">
<code class="descname">finalized</code><a class="headerlink" href="#sisl.physics.Hamiltonian.finalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the contained data is finalized and non-used elements have been removed</p>
</dd></dl>

<dl class="classmethod">
<dt id="sisl.physics.Hamiltonian.fromsp">
<em class="property">classmethod </em><code class="descname">fromsp</code><span class="sig-paren">(</span><em>geometry</em>, <em>P</em>, <em>S=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.fromsp" title="Permalink to this definition">¶</a></dt>
<dd><p>Read and return the object with possible overlap</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.geom">
<code class="descname">geom</code><a class="headerlink" href="#sisl.physics.Hamiltonian.geom" title="Permalink to this definition">¶</a></dt>
<dd><p>Associated geometry</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.geometry">
<code class="descname">geometry</code><a class="headerlink" href="#sisl.physics.Hamiltonian.geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Associated geometry</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.iter">
<code class="descname">iter</code><span class="sig-paren">(</span><em>local=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterations of the orbital space in the geometry, two indices from loop</p>
<p>An iterator returning the current atomic index and the corresponding
orbital index.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
</pre></div>
</div>
<p>In the above case <a class="reference external" href="https://docs.python.org/dev/library/io.html#module-io" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">io</span></code></a> always belongs to atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ia</em> may be
repeated according to the number of orbitals associated with
the atom <em class="xref py py-obj">ia</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>local</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">whether the orbital index is the global index, or the local index relative to
the atom it resides on.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.iter_nnz">
<code class="descname">iter_nnz</code><span class="sig-paren">(</span><em>atom=None</em>, <em>orbital=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.iter_nnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterations of the non-zero elements</p>
<p>An iterator on the sparse matrix with, row and column</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>atom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array_like</span></dt>
<dd><p class="first last">only loop on the non-zero elements coinciding with the orbitals
on these atoms (not compatible with the <code class="docutils literal notranslate"><span class="pre">orbital</span></code> keyword)</p>
</dd>
<dt><strong>orbital</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array_like</span></dt>
<dd><p class="first last">only loop on the non-zero elements coinciding with the orbital
(not compatible with the <code class="docutils literal notranslate"><span class="pre">atom</span></code> keyword)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">():</span>
<span class="gp">... </span>   <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="c1"># is then the non-zero value</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.nnz">
<code class="descname">nnz</code><a class="headerlink" href="#sisl.physics.Hamiltonian.nnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-zero elements</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.non_orthogonal">
<code class="descname">non_orthogonal</code><a class="headerlink" href="#sisl.physics.Hamiltonian.non_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the object is using a non-orthogonal basis</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.nonzero">
<code class="descname">nonzero</code><span class="sig-paren">(</span><em>atom=None</em>, <em>only_col=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices row and column indices where non-zero elements exists</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>atom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array_like of int, optional</span></dt>
<dd><p class="first last">only return the tuples for the requested atoms, default is all atoms
But for <em>all</em> orbitals.</p>
</dd>
<dt><strong>only_col</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">only return then non-zero columns</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseCSR.nonzero</span></code></dt>
<dd>the equivalent function call</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.orthogonal">
<code class="descname">orthogonal</code><a class="headerlink" href="#sisl.physics.Hamiltonian.orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the object is using an orthogonal basis</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.prepend">
<code class="descname">prepend</code><span class="sig-paren">(</span><em>other</em>, <em>axis</em>, <em>eps=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.prepend" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#sisl.physics.Hamiltonian.append" title="sisl.physics.Hamiltonian.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a> for details</p>
<p>This is currently equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="sisl.physics.Hamiltonian.read">
<em class="property">static </em><code class="descname">read</code><span class="sig-paren">(</span><em>sile</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads Hamiltonian from <em class="xref py py-obj">Sile</em> using <em class="xref py py-obj">read_hamiltonian</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sile</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sile, str or pathlib.Path</span></dt>
<dd><p class="first last">a <em class="xref py py-obj">Sile</em> object which will be used to read the Hamiltonian
and the overlap matrix (if any)
if it is a string it will create a new sile using <em class="xref py py-obj">get_sile</em>.</p>
</dd>
<dt><strong>*</strong> <span class="classifier-delimiter">:</span> <span class="classifier">args passed directly to <code class="docutils literal notranslate"><span class="pre">read_hamiltonian(,**)</span></code></span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>atom</em>, <em>orb_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a subset of this sparse matrix by only retaining the atoms corresponding to <em class="xref py py-obj">atom</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>atom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of int or Atom</span></dt>
<dd><p class="first last">indices of removed atoms or Atom for direct removal of all atoms</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.remove</span></code></dt>
<dd>equivalent to the resulting <em class="xref py py-obj">Geometry</em> from this routine</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.sub</span></code></dt>
<dd>the negative of <em class="xref py py-obj">Geometry.remove</em></dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.sub" title="sisl.physics.Hamiltonian.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a></dt>
<dd>the opposite of <a class="reference internal" href="#sisl.physics.Hamiltonian.remove" title="sisl.physics.Hamiltonian.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a>, i.e. retain a subset of atoms</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.remove_orbital">
<code class="descname">remove_orbital</code><span class="sig-paren">(</span><em>atom</em>, <em>orbital</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.remove_orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a subset of orbitals on <em class="xref py py-obj">atom</em> according to <em class="xref py py-obj">orbital</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>atom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of int or Atom</span></dt>
<dd><p class="first last">indices of atoms or <em class="xref py py-obj">Atom</em> that will be reduced in size according to <em class="xref py py-obj">orbital</em></p>
</dd>
<dt><strong>orbital</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of int or Orbital</span></dt>
<dd><p class="first last">indices of the orbitals on <em class="xref py py-obj">atom</em> that are removed from the sparse matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># remove the second orbital on the 2nd atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># all other orbitals are retained</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">remove_orbital</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a repeated sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.repeat</em></p>
<p>The already existing sparse elements are extrapolated
to the new supercell by repeating them in blocks like the coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of repetitions along cell-vector <em class="xref py py-obj">axis</em></p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">0, 1, 2 according to the cell-direction</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.repeat</span></code></dt>
<dd>the same ordering as the final geometry</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.tile</span></code></dt>
<dd>a different ordering of the final geometry</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.tile" title="sisl.physics.Hamiltonian.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt>
<dd>a different ordering of the final geometry</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><em>dim=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>nnzpr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>The sparsity pattern has all elements removed and everything is reset.</p>
<p>The object will be the same as if it had been
initialized with the same geometry as it were
created with.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dim: int, optional</strong></dt>
<dd><p class="first last">number of dimensions per element, default to the current number of
elements per matrix element.</p>
</dd>
<dt><strong>dtype: numpy.dtype, optional</strong></dt>
<dd><p class="first last">the datatype of the sparse elements</p>
</dd>
<dt><strong>nnzpr: int, optional</strong></dt>
<dd><p class="first last">number of non-zero elements per row</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.rij">
<code class="descname">rij</code><span class="sig-paren">(</span><em>what='orbital'</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.rij" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse matrix with the distance between atoms/orbitals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>what</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘orbital’, ‘atom’}</span></dt>
<dd><p class="first last">which kind of sparse distance matrix to return, either an atomic distance matrix
or an orbital distance matrix. The orbital matrix is equivalent to the atomic
one with the same distance repeated for the same atomic orbitals.
The default is the same type as the parent class.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype, optional</span></dt>
<dd><p class="first last">the data-type of the sparse matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The returned sparse matrix with distances are taken from the current sparse pattern.
I.e. a subsequent addition of sparse elements will make them inequivalent.
It is thus important to <em>only</em> create the sparse distance when the sparse
structure is completed.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.set_nsc">
<code class="descname">set_nsc</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.set_nsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the number of allowed supercells in the sparse orbital</p>
<p>If one reduces the number of supercells <em>any</em> sparse element
that references the supercell will be deleted.</p>
<p>See <em class="xref py py-obj">SuperCell.set_nsc</em> for allowed parameters.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell.set_nsc</span></code></dt>
<dd>the underlying called method</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.shape">
<code class="descname">shape</code><a class="headerlink" href="#sisl.physics.Hamiltonian.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape of sparse matrix</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>E</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the electronic structure by a constant energy</p>
<p>This is equal to performing this operation:</p>
<div class="math notranslate nohighlight">
\[\mathbf H_\sigma = \mathbf H_\sigma + E \mathbf S\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf H_\sigma\)</span> correspond to the spin diagonal components of the
Hamiltonian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>E</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or (2,)</span></dt>
<dd><p class="first last">the energy (in eV) to shift the electronic structure, if two values are passed
the two first spin-components get shifted individually.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.spalign">
<code class="descname">spalign</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.spalign" title="Permalink to this definition">¶</a></dt>
<dd><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">align</span></code> for details</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.Hamiltonian.spin">
<code class="descname">spin</code><a class="headerlink" href="#sisl.physics.Hamiltonian.spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Associated spin class</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.spin_moment">
<code class="descname">spin_moment</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.spin_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.spin_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spin moment for the eigenstates for a given <em class="xref py py-obj">k</em> point</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd><p class="first last">k-point at which the spin moments are calculated</p>
</dd>
<dt><strong>**kwargs: optional</strong></dt>
<dd><p class="first last">additional parameters passed to the <a class="reference internal" href="#sisl.physics.Hamiltonian.eigenstate" title="sisl.physics.Hamiltonian.eigenstate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenstate</span></code></a> routine</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.eigenstate" title="sisl.physics.Hamiltonian.eigenstate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenstate</span></code></a></dt>
<dd>method used to calculate the eigenstates</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenvalueElectron.spin_moment</span></code></dt>
<dd>Underlying method used to calculate the spin moment</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.spin_squared">
<code class="descname">spin_squared</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>n_up=None</em>, <em>n_down=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.spin_squared"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.spin_squared" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spin-squared expectation value, see <a class="reference internal" href="sisl.physics.electron.spin_squared.html#sisl.physics.electron.spin_squared" title="sisl.physics.electron.spin_squared"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_squared</span></code></a> for details</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd><p class="first last">k-point at which the spin-squared expectation value is</p>
</dd>
<dt><strong>n_up</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">number of states for spin up configuration, default to all. All states up to and including
<em class="xref py py-obj">n_up</em>.</p>
</dd>
<dt><strong>n_down</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">same as <em class="xref py py-obj">n_up</em> but for the spin-down configuration</p>
</dd>
<dt><strong>**kwargs: optional</strong></dt>
<dd><p class="first last">additional parameters passed to the <a class="reference internal" href="#sisl.physics.Hamiltonian.eigenstate" title="sisl.physics.Hamiltonian.eigenstate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenstate</span></code></a> routine</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.spsame">
<code class="descname">spsame</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.spsame" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two sparse objects and check whether they have the same entries.</p>
<p>This does not necessarily mean that the elements are the same</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.sub">
<code class="descname">sub</code><span class="sig-paren">(</span><em>atom</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a subset of this sparse matrix by only retaining the atoms corresponding to <em class="xref py py-obj">atom</em></p>
<p>Negative indices are wrapped and thus works, supercell atoms are also wrapped to the unit-cell.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>atom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of int or Atom</span></dt>
<dd><p class="first last">indices of retained atoms or <em class="xref py py-obj">Atom</em> for retaining only <em>that</em> atom</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.remove</span></code></dt>
<dd>the negative of <em class="xref py py-obj">Geometry.sub</em></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.sub</span></code></dt>
<dd>equivalent to the resulting <em class="xref py py-obj">Geometry</em> from this routine</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.remove" title="sisl.physics.Hamiltonian.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a></dt>
<dd>the negative of <a class="reference internal" href="#sisl.physics.Hamiltonian.sub" title="sisl.physics.Hamiltonian.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>, i.e. remove a subset of atoms</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># only retain the second atom in the SparseGeometry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># retain all atoms which is equivalent to</span>
<span class="gp">&gt;&gt;&gt; </span>                           <span class="c1"># the first atomic specie</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.sub_orbital">
<code class="descname">sub_orbital</code><span class="sig-paren">(</span><em>atom</em>, <em>orbital</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.sub_orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Retain only a subset of the orbitals on <em class="xref py py-obj">atom</em> according to <em class="xref py py-obj">orbital</em></p>
<p>This allows one to retain only a given subset of the sparse matrix elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>atom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of int or Atom</span></dt>
<dd><p class="first last">indices of atoms or <em class="xref py py-obj">Atom</em> that will be reduced in size according to <em class="xref py py-obj">orbital</em></p>
</dd>
<dt><strong>orbital</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of int or Orbital</span></dt>
<dd><p class="first last">indices of the orbitals on <em class="xref py py-obj">atom</em> that are retained in the sparse matrix, the list of
orbitals will be sorted. One cannot re-arrange matrix elements currently.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Future implementations may allow one to re-arange orbitals using this method.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># only retain the second orbital on the 2nd atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># all other orbitals are retained</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps atoms in the sparse geometry to obtain a new order of atoms</p>
<p>This can be used to reorder elements of a geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">the first list of atomic coordinates</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">the second list of atomic coordinates</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.tile">
<code class="descname">tile</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tiled sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.tile</em></p>
<p>The already existing sparse elements are extrapolated
to the new supercell by repeating them in blocks like the coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of repetitions along cell-vector <em class="xref py py-obj">axis</em></p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">0, 1, 2 according to the cell-direction</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.tile</span></code></dt>
<dd>the same ordering as the final geometry</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.repeat</span></code></dt>
<dd>a different ordering of the final geometry</dd>
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.repeat" title="sisl.physics.Hamiltonian.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a></dt>
<dd>a different ordering of the final geometry</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.toSparseAtom">
<code class="descname">toSparseAtom</code><span class="sig-paren">(</span><em>dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.toSparseAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the sparse object (without data) to a new sparse object with equivalent but reduced sparse pattern</p>
<p>This converts the orbital sparse pattern to an atomic sparse pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">number of dimensions allocated in the SparseAtom object, default to the same</p>
</dd>
<dt><strong>dtype: numpy.dtype, optional</strong></dt>
<dd><p class="first last">used data-type for the sparse object. Defaults to the same.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.tocsr">
<code class="descname">tocsr</code><span class="sig-paren">(</span><em>dim=0</em>, <em>isc=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.tocsr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.2.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">csr_matrix</span></code></a> for the specified dimension</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">the dimension in the sparse matrix (for non-orthogonal cases the last
dimension is the overlap matrix)</p>
</dd>
<dt><strong>isc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">the supercell index, or all (if <code class="docutils literal notranslate"><span class="pre">isc=None</span></code>)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.Hamiltonian.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the transposed sparse geometry by interchanging supercell indices</p>
<p>Sparse geometries are (typically) relying on symmetry in the supercell picture.
Thus when one transposes a sparse geometry one should <em>ideally</em> get the same
matrix. This is true for the Hamiltonian, density matrix, etc.</p>
<p>This routine transposes all rows and columns such that any interaction between
row, <em class="xref py py-obj">r</em>, and column <em class="xref py py-obj">c</em> in a given supercell <em class="xref py py-obj">(i,j,k)</em> will be transposed
into row <em class="xref py py-obj">c</em>, column <em class="xref py py-obj">r</em> in the supercell <em class="xref py py-obj">(-i,-j,-k)</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>object</strong></dt>
<dd><p class="first last">an equivalent sparse geometry with transposed matrix elements</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For Hamiltonians with non-collinear or spin-orbit there is no transposing of the
sub-spin matrix box. This needs to be done <em>manually</em>.</p>
<p class="rubric">Examples</p>
<p>Force a sparse geometry to be Hermitian:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">*</span> <span class="mf">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.velocity">
<code class="descname">velocity</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.velocity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the velocity for the eigenstates for a given <em class="xref py py-obj">k</em> point</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd><p class="first last">k-point at which the velocities are calculated</p>
</dd>
<dt><strong>**kwargs: optional</strong></dt>
<dd><p class="first last">additional parameters passed to the <a class="reference internal" href="#sisl.physics.Hamiltonian.eigenstate" title="sisl.physics.Hamiltonian.eigenstate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenstate</span></code></a> routine</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.Hamiltonian.eigenstate" title="sisl.physics.Hamiltonian.eigenstate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenstate</span></code></a></dt>
<dd>method used to calculate the eigenstates</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenvalueElectron.velocity</span></code></dt>
<dd>Underlying method used to calculate the velocity</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.Hamiltonian.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>sile</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/hamiltonian.html#Hamiltonian.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.Hamiltonian.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a Hamiltonian to the <em class="xref py py-obj">Sile</em> as implemented in the <code class="code docutils literal notranslate"><span class="pre">Sile.write_hamiltonian</span></code> method</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sisl.physics.DynamicalMatrix.html" class="btn btn-neutral float-right" title="DynamicalMatrix" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sisl.physics.DensityMatrix.html" class="btn btn-neutral float-left" title="DensityMatrix" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2018, Nick Papior

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>