

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Geometry &mdash; sisl |release| documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="sisl |release| documentation" href="../index.html"/>
        <link rel="up" title="sisl (sisl)" href="sisl.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                0.8.5-282
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">Citing</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="sisl.html">sisl (<code class="docutils literal"><span class="pre">sisl</span></code>)</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="sisl.html#generic-classes">Generic classes</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="sisl.PeriodicTable.html">PeriodicTable</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Atom.html">Atom</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Atoms.html">Atoms</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Geometry</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.SuperCell.html">SuperCell</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Grid.html">Grid</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="sisl.html#advanced-classes">Advanced classes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sisl.geom.html">Common geometries (<code class="docutils literal"><span class="pre">sisl.geom</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.physics.html">Physical objects (<code class="docutils literal"><span class="pre">sisl.physics</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.shape.html">Shapes (<code class="docutils literal"><span class="pre">sisl.shape</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.io.html">Input/Output (<code class="docutils literal"><span class="pre">sisl.io</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.unit.html">Unit conversion (<code class="docutils literal"><span class="pre">sisl.unit</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.utils.html">Utility routines (<code class="docutils literal"><span class="pre">sisl.utils</span></code>)</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">sisl</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../api.html">API documentation</a> &raquo;</li>
        
          <li><a href="sisl.html">sisl (<code class="docutils literal"><span class="pre">sisl</span></code>)</a> &raquo;</li>
        
      <li>Geometry</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api-generated/sisl.Geometry.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="geometry">
<h1>Geometry<a class="headerlink" href="#geometry" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="sisl.Geometry">
<em class="property">class </em><code class="descclassname">sisl.</code><code class="descname">Geometry</code><span class="sig-paren">(</span><em>xyz</em>, <em>atom=None</em>, <em>sc=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds atomic information, coordinates, species, lattice vectors</p>
<p>The <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal"><span class="pre">Geometry</span></code></a> class holds information regarding atomic coordinates,
the atomic species, the corresponding lattice-vectors.</p>
<p>It enables the interaction and conversion of atomic structures via
simple routine methods.</p>
<p>All lengths are assumed to be in units of Angstrom, however, as
long as units are kept same the exact units are irrespective.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz</strong> : array_like</p>
<blockquote>
<div><p>atomic coordinates
<code class="docutils literal"><span class="pre">xyz[i,</span> <span class="pre">:]</span></code> is the atomic coordinate of the i’th atom.</p>
</div></blockquote>
<p><strong>atom</strong> : array_like or Atoms</p>
<blockquote>
<div><p>atomic species retrieved from the <a class="reference internal" href="sisl.PeriodicTable.html#sisl.PeriodicTable" title="sisl.PeriodicTable"><code class="xref py py-obj docutils literal"><span class="pre">PeriodicTable</span></code></a></p>
</div></blockquote>
<p><strong>sc</strong> : SuperCell</p>
<blockquote class="last">
<div><p>the unit-cell describing the atoms in a periodic
super-cell</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal"><span class="pre">Atoms</span></code></a></dt>
<dd>contained atoms <em class="xref py py-obj">self.atom</em></dd>
<dt><a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><code class="xref py py-obj docutils literal"><span class="pre">Atom</span></code></a></dt>
<dd>contained atoms are each an object of this</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>An atomic lattice consisting of Hydrogen atoms.
An atomic square lattice of Hydrogen atoms</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">           [1, 1, 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="n">Atom</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">],</span><span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
<p>The following estimates the lattice vectors from the
atomic coordinates, although possible, it is not recommended
to be used.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">           [1, 1, 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="code highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]],</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                  <span class="n">sc</span><span class="o">=</span><span class="n">SuperCell</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="go">Geometry{na: 1, no: 1,</span>
<span class="go"> Atoms{species: 1,</span>
<span class="go">   Atom{H, Z: 1, orbs: 1, mass(au): 1.00794, maxR: -1.00000}: 1,</span>
<span class="go"> },</span>
<span class="go"> nsc: [3, 3, 1], maxR: -1.0</span>
<span class="go">}</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal"><span class="pre">na</span></code></a></td>
<td>Number of atoms in geometry</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal"><span class="pre">atom</span></code></a></td>
<td>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal"><span class="pre">Atoms</span></code></a> object)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.maxR" title="sisl.Geometry.maxR"><code class="xref py py-obj docutils literal"><span class="pre">maxR</span></code></a>([all])</td>
<td>Maximum orbital range of the atoms</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>xyz</strong></td>
<td>(ndarray) atomic coordinates</td>
</tr>
<tr class="row-even"><td><strong>sc</strong></td>
<td>(SuperCell) the supercell describing the periodicity of the geometry</td>
</tr>
<tr class="row-odd"><td><strong>no: int</strong></td>
<td>total number of orbitals in the geometry</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">__init__</span></code>(xyz[,&nbsp;atom,&nbsp;sc])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.a2isc" title="sisl.Geometry.a2isc"><code class="xref py py-obj docutils literal"><span class="pre">a2isc</span></code></a>(ia)</td>
<td>Returns the super-cell index for a specific/list atom</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.a2o" title="sisl.Geometry.a2o"><code class="xref py py-obj docutils literal"><span class="pre">a2o</span></code></a>(ia[,&nbsp;all])</td>
<td>Returns an orbital index of the first orbital of said atom.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.a2sc" title="sisl.Geometry.a2sc"><code class="xref py py-obj docutils literal"><span class="pre">a2sc</span></code></a>(a)</td>
<td>Returns the super-cell offset for a specific atom</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal"><span class="pre">add</span></code></a>(other)</td>
<td>Adds atoms (as is) from the <code class="docutils literal"><span class="pre">other</span></code> geometry.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.add_vacuum" title="sisl.Geometry.add_vacuum"><code class="xref py py-obj docutils literal"><span class="pre">add_vacuum</span></code></a>(vacuum,&nbsp;axis)</td>
<td>Add vacuum along the <em class="xref py py-obj">axis</em> lattice vector</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.angle" title="sisl.Geometry.angle"><code class="xref py py-obj docutils literal"><span class="pre">angle</span></code></a>(atom[,&nbsp;dir,&nbsp;ref,&nbsp;rad])</td>
<td>The angle between atom <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal"><span class="pre">atom</span></code></a> and the direction <em class="xref py py-obj">dir</em>, with possibility of a reference coordinate <em class="xref py py-obj">ref</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal"><span class="pre">append</span></code></a>(other,&nbsp;axis)</td>
<td>Appends structure along <code class="docutils literal"><span class="pre">axis</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.asc2uc" title="sisl.Geometry.asc2uc"><code class="xref py py-obj docutils literal"><span class="pre">asc2uc</span></code></a>(atom[,&nbsp;uniq])</td>
<td>Returns atom from super-cell indices to unit-cell indices, possibly removing dublicates</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code></a>(s_idx,&nbsp;other,&nbsp;o_idx[,&nbsp;dist,&nbsp;axis])</td>
<td>Attaches another <code class="docutils literal"><span class="pre">Geometry</span></code> at the <em class="xref py py-obj">s_idx</em> index with respect to <em class="xref py py-obj">o_idx</em> using different methods.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.axyz" title="sisl.Geometry.axyz"><code class="xref py py-obj docutils literal"><span class="pre">axyz</span></code></a>([atom,&nbsp;isc])</td>
<td>Return the atomic coordinates in the supercell of a given atom.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.bond_correct" title="sisl.Geometry.bond_correct"><code class="xref py py-obj docutils literal"><span class="pre">bond_correct</span></code></a>(ia,&nbsp;atom[,&nbsp;method])</td>
<td>Corrects the bond between <em class="xref py py-obj">ia</em> and the <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal"><span class="pre">atom</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.center" title="sisl.Geometry.center"><code class="xref py py-obj docutils literal"><span class="pre">center</span></code></a>([atom,&nbsp;which])</td>
<td>Returns the center of the geometry</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.close" title="sisl.Geometry.close"><code class="xref py py-obj docutils literal"><span class="pre">close</span></code></a>(xyz_ia[,&nbsp;R,&nbsp;idx,&nbsp;idx_xyz,&nbsp;ret_xyz,&nbsp;…])</td>
<td>Indices of atoms in the entire supercell within a given radius from a given coordinate</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.close_all" title="sisl.Geometry.close_all"><code class="xref py py-obj docutils literal"><span class="pre">close_all</span></code></a>(xyz_ia[,&nbsp;R,&nbsp;idx,&nbsp;idx_xyz,&nbsp;…])</td>
<td>Indices of atoms in the entire supercell within a given radius from a given coordinate</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.close_sc" title="sisl.Geometry.close_sc"><code class="xref py py-obj docutils literal"><span class="pre">close_sc</span></code></a>(xyz_ia[,&nbsp;isc,&nbsp;R,&nbsp;idx,&nbsp;idx_xyz,&nbsp;…])</td>
<td>Indices of atoms in a given supercell within a given radius from a given coordinate</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.copy" title="sisl.Geometry.copy"><code class="xref py py-obj docutils literal"><span class="pre">copy</span></code></a>()</td>
<td>A copy of the object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.cut" title="sisl.Geometry.cut"><code class="xref py py-obj docutils literal"><span class="pre">cut</span></code></a>(seps,&nbsp;axis[,&nbsp;seg,&nbsp;rtol,&nbsp;atol])</td>
<td>Returns a subset of atoms from the geometry by cutting the geometry into <code class="docutils literal"><span class="pre">seps</span></code> parts along the direction <code class="docutils literal"><span class="pre">axis</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.distance" title="sisl.Geometry.distance"><code class="xref py py-obj docutils literal"><span class="pre">distance</span></code></a>([atom,&nbsp;R,&nbsp;tol,&nbsp;method])</td>
<td>Calculate the distances for all atoms in shells of radius <code class="docutils literal"><span class="pre">tol</span></code> within <code class="docutils literal"><span class="pre">max_R</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.equal" title="sisl.Geometry.equal"><code class="xref py py-obj docutils literal"><span class="pre">equal</span></code></a>(other[,&nbsp;R])</td>
<td>Whether two geometries are the same (optional not check of the orbital radius)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.fromASE" title="sisl.Geometry.fromASE"><code class="xref py py-obj docutils literal"><span class="pre">fromASE</span></code></a>(aseg)</td>
<td>Returns geometry from an ASE object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.iR" title="sisl.Geometry.iR"><code class="xref py py-obj docutils literal"><span class="pre">iR</span></code></a>([na,&nbsp;iR,&nbsp;R])</td>
<td>Return an integer number of maximum radii (<em class="xref py py-obj">self.maxR()</em>) which holds approximately <a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal"><span class="pre">na</span></code></a> atoms</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal"><span class="pre">insert</span></code></a>(atom,&nbsp;geom)</td>
<td>Inserts other atoms right before index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.is_orthogonal" title="sisl.Geometry.is_orthogonal"><code class="xref py py-obj docutils literal"><span class="pre">is_orthogonal</span></code></a>()</td>
<td>Return true if all cell vectors are linearly independent</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.iter" title="sisl.Geometry.iter"><code class="xref py py-obj docutils literal"><span class="pre">iter</span></code></a>()</td>
<td>An iterator over all atomic indices</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal"><span class="pre">iter_block</span></code></a>([iR,&nbsp;R,&nbsp;atom,&nbsp;method])</td>
<td>Iterator for performance critical loops</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.iter_block_rand" title="sisl.Geometry.iter_block_rand"><code class="xref py py-obj docutils literal"><span class="pre">iter_block_rand</span></code></a>([iR,&nbsp;R,&nbsp;atom])</td>
<td>Perform the <em>random</em> block-iteration by randomly selecting the next center of block</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.iter_block_shape" title="sisl.Geometry.iter_block_shape"><code class="xref py py-obj docutils literal"><span class="pre">iter_block_shape</span></code></a>([shape,&nbsp;iR,&nbsp;atom])</td>
<td>Perform the <em>grid</em> block-iteration by looping a grid</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.iter_orbitals" title="sisl.Geometry.iter_orbitals"><code class="xref py py-obj docutils literal"><span class="pre">iter_orbitals</span></code></a>([atom,&nbsp;local])</td>
<td>Returns an iterator over all atoms and their associated orbitals</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.iter_species" title="sisl.Geometry.iter_species"><code class="xref py py-obj docutils literal"><span class="pre">iter_species</span></code></a>([atom])</td>
<td>Iterator over all atoms and species as a tuple in this geometry</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.maxR" title="sisl.Geometry.maxR"><code class="xref py py-obj docutils literal"><span class="pre">maxR</span></code></a>([all])</td>
<td>Maximum orbital range of the atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.mirror" title="sisl.Geometry.mirror"><code class="xref py py-obj docutils literal"><span class="pre">mirror</span></code></a>(plane[,&nbsp;atom])</td>
<td>Mirrors the structure around the center of the atoms</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.move" title="sisl.Geometry.move"><code class="xref py py-obj docutils literal"><span class="pre">move</span></code></a>(v[,&nbsp;atom,&nbsp;cell])</td>
<td>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.o2a" title="sisl.Geometry.o2a"><code class="xref py py-obj docutils literal"><span class="pre">o2a</span></code></a>(io[,&nbsp;uniq])</td>
<td>Atomic index corresponding to the orbital indicies.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.o2isc" title="sisl.Geometry.o2isc"><code class="xref py py-obj docutils literal"><span class="pre">o2isc</span></code></a>(io)</td>
<td>Returns the super-cell index for a specific orbital.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.o2sc" title="sisl.Geometry.o2sc"><code class="xref py py-obj docutils literal"><span class="pre">o2sc</span></code></a>(o)</td>
<td>Returns the super-cell offset for a specific orbital.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.optimize_nsc" title="sisl.Geometry.optimize_nsc"><code class="xref py py-obj docutils literal"><span class="pre">optimize_nsc</span></code></a>([axis,&nbsp;R])</td>
<td>Optimize the number of supercell connections based on <code class="docutils literal"><span class="pre">self.maxR()</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.orij" title="sisl.Geometry.orij"><code class="xref py py-obj docutils literal"><span class="pre">orij</span></code></a>(io,&nbsp;jo)</td>
<td>Distance between orbital <a class="reference internal" href="sisl.io.html#module-sisl.io" title="sisl.io"><code class="xref py py-obj docutils literal"><span class="pre">io</span></code></a> and <em class="xref py py-obj">jo</em>, orbitals can be in super-cell indices</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.osc2uc" title="sisl.Geometry.osc2uc"><code class="xref py py-obj docutils literal"><span class="pre">osc2uc</span></code></a>(orbs[,&nbsp;uniq])</td>
<td>Returns orbitals from super-cell indices to unit-cell indices, possibly removing dublicates</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal"><span class="pre">prepend</span></code></a>(other,&nbsp;axis)</td>
<td>Prepends structure along <code class="docutils literal"><span class="pre">axis</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.read" title="sisl.Geometry.read"><code class="xref py py-obj docutils literal"><span class="pre">read</span></code></a>(sile,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Reads geometry from the <code class="xref py py-obj docutils literal"><span class="pre">Sile</span></code> using <em class="xref py py-obj">Sile.read_geometry</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.reduce" title="sisl.Geometry.reduce"><code class="xref py py-obj docutils literal"><span class="pre">reduce</span></code></a>()</td>
<td>Remove all atoms not currently used in the <code class="docutils literal"><span class="pre">self.atom</span></code> object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.remove" title="sisl.Geometry.remove"><code class="xref py py-obj docutils literal"><span class="pre">remove</span></code></a>(atom)</td>
<td>Remove atoms from the geometry.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.reorder" title="sisl.Geometry.reorder"><code class="xref py py-obj docutils literal"><span class="pre">reorder</span></code></a>()</td>
<td>Reorders atoms according to first occurence in the geometry</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.repeat" title="sisl.Geometry.repeat"><code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code></a>(reps,&nbsp;axis)</td>
<td>Create a repeated geometry</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.reverse" title="sisl.Geometry.reverse"><code class="xref py py-obj docutils literal"><span class="pre">reverse</span></code></a>([atom])</td>
<td>Returns a reversed geometry</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.rij" title="sisl.Geometry.rij"><code class="xref py py-obj docutils literal"><span class="pre">rij</span></code></a>(ia,&nbsp;ja)</td>
<td>Distance between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.rotate" title="sisl.Geometry.rotate"><code class="xref py py-obj docutils literal"><span class="pre">rotate</span></code></a>(angle,&nbsp;v[,&nbsp;origo,&nbsp;atom,&nbsp;only,&nbsp;rad])</td>
<td>Rotate geometry around vector and return a new geometry</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.rotate_miller" title="sisl.Geometry.rotate_miller"><code class="xref py py-obj docutils literal"><span class="pre">rotate_miller</span></code></a>(m,&nbsp;v)</td>
<td>Align Miller direction along <code class="docutils literal"><span class="pre">v</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.rotatea" title="sisl.Geometry.rotatea"><code class="xref py py-obj docutils literal"><span class="pre">rotatea</span></code></a>(angle[,&nbsp;origo,&nbsp;atom,&nbsp;only,&nbsp;rad])</td>
<td>Rotate around first lattice vector</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.rotateb" title="sisl.Geometry.rotateb"><code class="xref py py-obj docutils literal"><span class="pre">rotateb</span></code></a>(angle[,&nbsp;origo,&nbsp;atom,&nbsp;only,&nbsp;rad])</td>
<td>Rotate around second lattice vector</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.rotatec" title="sisl.Geometry.rotatec"><code class="xref py py-obj docutils literal"><span class="pre">rotatec</span></code></a>(angle[,&nbsp;origo,&nbsp;atom,&nbsp;only,&nbsp;rad])</td>
<td>Rotate around third lattice vector</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.sc2uc" title="sisl.Geometry.sc2uc"><code class="xref py py-obj docutils literal"><span class="pre">sc2uc</span></code></a>(atom[,&nbsp;uniq])</td>
<td>Returns atom from super-cell indices to unit-cell indices, possibly removing dublicates</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.sc_index" title="sisl.Geometry.sc_index"><code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Call local <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> object <a class="reference internal" href="#sisl.Geometry.sc_index" title="sisl.Geometry.sc_index"><code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code></a> function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.scale" title="sisl.Geometry.scale"><code class="xref py py-obj docutils literal"><span class="pre">scale</span></code></a>(scale)</td>
<td>Scale coordinates and unit-cell to get a new geometry with proper scaling</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.set_nsc" title="sisl.Geometry.set_nsc"><code class="xref py py-obj docutils literal"><span class="pre">set_nsc</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Set the number of super-cells in the <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.set_sc" title="sisl.Geometry.set_sc"><code class="xref py py-obj docutils literal"><span class="pre">set_sc</span></code></a>(sc)</td>
<td>Overwrites the local supercell</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.set_supercell" title="sisl.Geometry.set_supercell"><code class="xref py py-obj docutils literal"><span class="pre">set_supercell</span></code></a>(sc)</td>
<td>Overwrites the local supercell</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.sparserij" title="sisl.Geometry.sparserij"><code class="xref py py-obj docutils literal"><span class="pre">sparserij</span></code></a>([dtype,&nbsp;na_iR,&nbsp;method])</td>
<td>Return the sparse matrix with all distances in the matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.sub" title="sisl.Geometry.sub"><code class="xref py py-obj docutils literal"><span class="pre">sub</span></code></a>(atom[,&nbsp;cell])</td>
<td>Create a new <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal"><span class="pre">Geometry</span></code></a> with a subset of this <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal"><span class="pre">Geometry</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.swap" title="sisl.Geometry.swap"><code class="xref py py-obj docutils literal"><span class="pre">swap</span></code></a>(a,&nbsp;b)</td>
<td>Swap a set of atoms in the geometry and return a new one</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.swapaxes" title="sisl.Geometry.swapaxes"><code class="xref py py-obj docutils literal"><span class="pre">swapaxes</span></code></a>(a,&nbsp;b[,&nbsp;swap])</td>
<td>Swap the axis for the atomic coordinates and the cell vectors</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a>(reps,&nbsp;axis)</td>
<td>Tile the geometry to create a bigger one</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.toASE" title="sisl.Geometry.toASE"><code class="xref py py-obj docutils literal"><span class="pre">toASE</span></code></a>()</td>
<td>Returns the geometry as an ASE <code class="docutils literal"><span class="pre">Atoms</span></code> object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.translate" title="sisl.Geometry.translate"><code class="xref py py-obj docutils literal"><span class="pre">translate</span></code></a>(v[,&nbsp;atom,&nbsp;cell])</td>
<td>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.within" title="sisl.Geometry.within"><code class="xref py py-obj docutils literal"><span class="pre">within</span></code></a>(shapes[,&nbsp;idx,&nbsp;idx_xyz,&nbsp;ret_xyz,&nbsp;ret_rij])</td>
<td>Indices of atoms in the entire supercell within a given shape from a given coordinate</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.Geometry.within_sc" title="sisl.Geometry.within_sc"><code class="xref py py-obj docutils literal"><span class="pre">within_sc</span></code></a>(shapes[,&nbsp;isc,&nbsp;idx,&nbsp;idx_xyz,&nbsp;…])</td>
<td>Indices of atoms in a given supercell within a given shape from a given coordinate</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.Geometry.write" title="sisl.Geometry.write"><code class="xref py py-obj docutils literal"><span class="pre">write</span></code></a>(sile,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Writes geometry to the <code class="xref py py-obj docutils literal"><span class="pre">Sile</span></code> using <em class="xref py py-obj">sile.write_geometry</em></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sisl.Geometry.a2isc">
<code class="descname">a2isc</code><span class="sig-paren">(</span><em>ia</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.a2isc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.a2isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell index for a specific/list atom</p>
<p>Returns a vector of 3 numbers with integers.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.a2o">
<code class="descname">a2o</code><span class="sig-paren">(</span><em>ia</em>, <em>all=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.a2o"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.a2o" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an orbital index of the first orbital of said atom.
This is particularly handy if you want to create
TB models with more than one orbital per atom.</p>
<p>Note that this will preserve the super-cell offsets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ia</strong> : array_like</p>
<blockquote>
<div><p>Atomic indices</p>
</div></blockquote>
<p><strong>all</strong> : bool, optional</p>
<blockquote class="last">
<div><p><em class="xref py py-obj">False</em>, return only the first orbital corresponding to the atom,
<em class="xref py py-obj">True</em>, returns list of the full atom</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.a2sc">
<code class="descname">a2sc</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.a2sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.a2sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell offset for a specific atom</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds atoms (as is) from the <code class="docutils literal"><span class="pre">other</span></code> geometry.
This will not alter the cell vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>other</strong> : Geometry</p>
<blockquote class="last">
<div><p>Other geometry class which is added</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal"><span class="pre">append</span></code></a></dt>
<dd>appending geometries</dd>
<dt><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal"><span class="pre">prepend</span></code></a></dt>
<dd>prending geometries</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code></a></dt>
<dd>attach a geometry</dd>
<dt><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal"><span class="pre">insert</span></code></a></dt>
<dd>insert a geometry</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.add_vacuum">
<code class="descname">add_vacuum</code><span class="sig-paren">(</span><em>vacuum</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.add_vacuum" title="Permalink to this definition">¶</a></dt>
<dd><p>Add vacuum along the <em class="xref py py-obj">axis</em> lattice vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vacuum</strong> : float</p>
<blockquote>
<div><p>amount of vacuum added, in Ang</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>the lattice vector to add vacuum along</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.angle">
<code class="descname">angle</code><span class="sig-paren">(</span><em>atom</em>, <em>dir=(1.0</em>, <em>0</em>, <em>0)</em>, <em>ref=None</em>, <em>rad=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>The angle between atom <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal"><span class="pre">atom</span></code></a> and the direction <em class="xref py py-obj">dir</em>, with possibility of a reference coordinate <em class="xref py py-obj">ref</em></p>
<p>The calculated angle can be written as this</p>
<div class="math">
\[\alpha = \arccos \frac{(\mathrm{atom} - \mathrm{ref})\cdot \mathrm{dir}}
{|\mathrm{atom}-\mathrm{ref}||\mathrm{dir}|}\]</div>
<p>and thus lies in the interval <span class="math">\([0 ; \pi]\)</span> as one cannot distinguish orientation without
additional vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int or array_like</p>
<blockquote>
<div><p>atomic index</p>
</div></blockquote>
<p><strong>dir</strong> : str, int or vector</p>
<blockquote>
<div><p>the direction from which the angle is calculated from, default to <code class="docutils literal"><span class="pre">x</span></code></p>
</div></blockquote>
<p><strong>ref</strong> : int or coordinate, optional</p>
<blockquote>
<div><p>the reference point from which the vectors are drawn, default to origo</p>
</div></blockquote>
<p><strong>rad</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the returned value is in radians</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>other</em>, <em>axis</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends structure along <code class="docutils literal"><span class="pre">axis</span></code>. This will automatically
add the <code class="docutils literal"><span class="pre">self.cell[axis,:]</span></code> to all atomic coordiates in the
<code class="docutils literal"><span class="pre">other</span></code> structure before appending.</p>
<p>The basic algorithm is this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oxa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="bp">None</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span><span class="n">oxa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span>
</pre></div>
</div>
<p>NOTE: The cell appended is only in the axis that
is appended, which means that the other cell directions
need not conform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>other</strong> : Geometry or SuperCell</p>
<blockquote>
<div><p>Other geometry class which needs to be appended
If a <code class="docutils literal"><span class="pre">SuperCell</span></code> only the super cell will be extended</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>Cell direction to which the <code class="docutils literal"><span class="pre">other</span></code> geometry should be
appended.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal"><span class="pre">add</span></code></a></dt>
<dd>add geometries</dd>
<dt><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal"><span class="pre">prepend</span></code></a></dt>
<dd>prending geometries</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code></a></dt>
<dd>attach a geometry</dd>
<dt><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal"><span class="pre">insert</span></code></a></dt>
<dd>insert a geometry</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.asc2uc">
<code class="descname">asc2uc</code><span class="sig-paren">(</span><em>atom</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.asc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atom from super-cell indices to unit-cell indices, possibly removing dublicates</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.atom">
<code class="descname">atom</code><a class="headerlink" href="#sisl.Geometry.atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal"><span class="pre">Atoms</span></code></a> object)</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.atoms">
<code class="descname">atoms</code><a class="headerlink" href="#sisl.Geometry.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal"><span class="pre">Atoms</span></code></a> object)</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.attach">
<code class="descname">attach</code><span class="sig-paren">(</span><em>s_idx</em>, <em>other</em>, <em>o_idx</em>, <em>dist='calc'</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.attach"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Attaches another <code class="docutils literal"><span class="pre">Geometry</span></code> at the <em class="xref py py-obj">s_idx</em> index with respect to <em class="xref py py-obj">o_idx</em> using different methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dist</strong> : <code class="docutils literal"><span class="pre">array_like</span></code>, <code class="docutils literal"><span class="pre">float</span></code>, <code class="docutils literal"><span class="pre">str</span></code> (<em class="xref py py-obj">‘calc’</em>)</p>
<blockquote>
<div><p>the distance (in <em class="xref py py-obj">Ang</em>) between the attached coordinates.
If <em class="xref py py-obj">dist</em> is <em class="xref py py-obj">arraylike it should be the vector between
the atoms;
if `dist</em> is <em class="xref py py-obj">float</em> the argument <em class="xref py py-obj">axis</em> is required
and the vector will be calculated along the corresponding latticevector;
else if <em class="xref py py-obj">dist</em> is <em class="xref py py-obj">str</em> this will correspond to the
<em class="xref py py-obj">method</em> argument of the <code class="docutils literal"><span class="pre">Atom.radius</span></code> class of the two
atoms. Here <em class="xref py py-obj">axis</em> is also required.</p>
</div></blockquote>
<p><strong>axis</strong> : <code class="docutils literal"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>specify the direction of the lattice vectors used.
Not used if <em class="xref py py-obj">dist</em> is an array-like argument.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.axyz">
<code class="descname">axyz</code><span class="sig-paren">(</span><em>atom=None</em>, <em>isc=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.axyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.axyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atomic coordinates in the supercell of a given atom.</p>
<p>The <em class="xref py py-obj">Geometry[…]</em> slicing is calling this function with appropriate options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int or array_like</p>
<blockquote>
<div><p>atom(s) from which we should return the coordinates, the atomic indices
may be in supercell format.</p>
</div></blockquote>
<p><strong>isc</strong> : array_like, optional</p>
<blockquote class="last">
<div><p>Returns the atomic coordinates shifted according to the integer
parts of the cell. Defaults to the unit-cell</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">isc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[[ 1.   0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[ 1.   0.   0. ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.bond_correct">
<code class="descname">bond_correct</code><span class="sig-paren">(</span><em>ia</em>, <em>atom</em>, <em>method='calc'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.bond_correct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.bond_correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects the bond between <em class="xref py py-obj">ia</em> and the <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal"><span class="pre">atom</span></code></a>.</p>
<p>Corrects the bond-length between atom <em class="xref py py-obj">ia</em> and <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal"><span class="pre">atom</span></code></a> in such
a way that the atomic radius is preserved.
I.e. the sum of the bond-lengths minimizes the distance matrix.</p>
<p>Only atom <em class="xref py py-obj">ia</em> is moved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ia</strong> : int</p>
<blockquote>
<div><p>The atom to be displaced according to the atomic radius</p>
</div></blockquote>
<p><strong>atom</strong> : array_like or int</p>
<blockquote>
<div><p>The atom(s) from which the radius should be reduced.</p>
</div></blockquote>
<p><strong>method</strong> : <code class="docutils literal"><span class="pre">str</span></code>, <code class="docutils literal"><span class="pre">float</span></code></p>
<blockquote class="last">
<div><p>If str will use that as lookup in <a class="reference internal" href="sisl.Atom.html#sisl.Atom.radius" title="sisl.Atom.radius"><code class="xref py py-obj docutils literal"><span class="pre">Atom.radius</span></code></a>.
Else it will be the new bond-length.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.cell">
<code class="descname">cell</code><a class="headerlink" href="#sisl.Geometry.cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.cell" title="sisl.Geometry.cell"><code class="xref py py-obj docutils literal"><span class="pre">cell</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>atom=None</em>, <em>which='xyz'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of the geometry</p>
<p>By specifying <code class="docutils literal"><span class="pre">which</span></code> one can control whether it should be:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xyz|position</span></code>: Center of coordinates (default)</li>
<li><code class="docutils literal"><span class="pre">mass</span></code>: Center of mass</li>
<li><code class="docutils literal"><span class="pre">cell</span></code>: Center of cell</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : array_like</p>
<blockquote>
<div><p>list of atomic indices to find center of</p>
</div></blockquote>
<p><strong>which</strong> : {‘xyz’, ‘mass’, ‘cell’}</p>
<blockquote class="last">
<div><p>determine whether center should be of ‘cell’, mass-centered (‘mass’),
or absolute center of the positions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.close">
<code class="descname">close</code><span class="sig-paren">(</span><em>xyz_ia</em>, <em>R=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_xyz=False</em>, <em>ret_rij=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of atoms in the entire supercell within a given radius from a given coordinate</p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.Geometry.close_sc" title="sisl.Geometry.close_sc"><code class="xref py py-obj docutils literal"><span class="pre">close_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz_ia</strong> : coordinate/index</p>
<blockquote>
<div><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <em class="xref py py-obj">close_sc(self.xyz[xyz_ia,:])</em>.</p>
</div></blockquote>
<p><strong>R</strong> : (None), float/tuple of float</p>
<blockquote>
<div><p>The radii parameter to where the atomic connections are found.
If <code class="docutils literal"><span class="pre">R</span></code> is an array it will return the indices:
in the ranges:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sb">``</span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span><span class="sb">``</span>
</pre></div>
</div>
<p>If a single float it will return:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sb">``</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="sb">``</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>idx</strong> : array_like, optional</p>
<blockquote>
<div><p>List of indices for atoms that are to be considered</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : array_like, optional</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <code class="docutils literal"><span class="pre">idx</span></code> variable (<code class="docutils literal"><span class="pre">idx</span></code> must also be passed)</p>
</div></blockquote>
<p><strong>ret_xyz</strong> : bool, optional</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_rij</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If true this method will return the distances from the <code class="docutils literal"><span class="pre">xyz_ia</span></code>
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.close_all">
<code class="descname">close_all</code><span class="sig-paren">(</span><em>xyz_ia</em>, <em>R=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_xyz=False</em>, <em>ret_rij=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.close_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of atoms in the entire supercell within a given radius from a given coordinate</p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.Geometry.close_sc" title="sisl.Geometry.close_sc"><code class="xref py py-obj docutils literal"><span class="pre">close_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz_ia</strong> : coordinate/index</p>
<blockquote>
<div><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <em class="xref py py-obj">close_sc(self.xyz[xyz_ia,:])</em>.</p>
</div></blockquote>
<p><strong>R</strong> : (None), float/tuple of float</p>
<blockquote>
<div><p>The radii parameter to where the atomic connections are found.
If <code class="docutils literal"><span class="pre">R</span></code> is an array it will return the indices:
in the ranges:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sb">``</span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span><span class="sb">``</span>
</pre></div>
</div>
<p>If a single float it will return:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sb">``</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="sb">``</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>idx</strong> : array_like, optional</p>
<blockquote>
<div><p>List of indices for atoms that are to be considered</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : array_like, optional</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <code class="docutils literal"><span class="pre">idx</span></code> variable (<code class="docutils literal"><span class="pre">idx</span></code> must also be passed)</p>
</div></blockquote>
<p><strong>ret_xyz</strong> : bool, optional</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_rij</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If true this method will return the distances from the <code class="docutils literal"><span class="pre">xyz_ia</span></code>
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.close_sc">
<code class="descname">close_sc</code><span class="sig-paren">(</span><em>xyz_ia</em>, <em>isc=(0</em>, <em>0</em>, <em>0)</em>, <em>R=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_xyz=False</em>, <em>ret_rij=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.close_sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.close_sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of atoms in a given supercell within a given radius from a given coordinate</p>
<p>This returns a set of atomic indices which are within a
sphere of radius <em class="xref py py-obj">R</em>.</p>
<p>If <em class="xref py py-obj">R</em> is a tuple/list/array it will return the indices:
in the ranges:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz_ia</strong> : array_like of floats or int</p>
<blockquote>
<div><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="docutils literal"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p>
</div></blockquote>
<p><strong>isc</strong> : array_like, optional</p>
<blockquote>
<div><p>The super-cell which the coordinates are checked in.</p>
</div></blockquote>
<p><strong>R</strong> : float or array_like, optional</p>
<blockquote>
<div><p>The radii parameter to where the atomic connections are found.
If <em class="xref py py-obj">R</em> is an array it will return the indices:
in the ranges <code class="docutils literal"><span class="pre">(</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R[0]</span> <span class="pre">,</span> <span class="pre">R[0]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R[1],</span> <span class="pre">R[1]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R[2]</span> <span class="pre">)</span></code>.
If a single float it will return <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R</span></code>.</p>
</div></blockquote>
<p><strong>idx</strong> : array_like of int, optional</p>
<blockquote>
<div><p>List of atoms that will be considered. This can
be used to only take out a certain atoms.</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : array_like of float, optional</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <em class="xref py py-obj">idx</em> variable (<em class="xref py py-obj">idx</em> must also be passed)</p>
</div></blockquote>
<p><strong>ret_xyz</strong> : bool, optional</p>
<blockquote>
<div><p>If True this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_rij</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If True this method will return the distance
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the object.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.cut">
<code class="descname">cut</code><span class="sig-paren">(</span><em>seps</em>, <em>axis</em>, <em>seg=0</em>, <em>rtol=0.0001</em>, <em>atol=0.0001</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.cut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of atoms from the geometry by cutting the
geometry into <code class="docutils literal"><span class="pre">seps</span></code> parts along the direction <code class="docutils literal"><span class="pre">axis</span></code>.
It will then _only_ return the first cut.</p>
<p>This will effectively change the unit-cell in the <code class="docutils literal"><span class="pre">axis</span></code> as-well
as removing <code class="docutils literal"><span class="pre">self.na/seps</span></code> atoms.
It requires that <code class="docutils literal"><span class="pre">self.na</span> <span class="pre">%</span> <span class="pre">seps</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<p>REMARK: You need to ensure that all atoms within the first
cut out region are within the primary unit-cell.</p>
<p>Doing <code class="docutils literal"><span class="pre">geom.cut(2,</span> <span class="pre">1).tile(2,</span> <span class="pre">1)</span></code>, could for symmetric setups,
be equivalent to a no-op operation. A <code class="docutils literal"><span class="pre">UserWarning</span></code> will be issued
if this is not the case.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seps</strong> : int</p>
<blockquote>
<div><p>number of times the structure will be cut.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>the axis that will be cut</p>
</div></blockquote>
<p><strong>seg</strong> : int, optional</p>
<blockquote>
<div><p>returns the i’th segment of the cut structure
Currently the atomic coordinates are not translated,
this may change in the future.</p>
</div></blockquote>
<p><strong>rtol</strong> : (tolerance for checking tiling, see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html#numpy.allclose" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.allclose</span></code></a>)</p>
<p class="last"><strong>atol</strong> : (tolerance for checking tiling, see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html#numpy.allclose" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.allclose</span></code></a>)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.distance">
<code class="descname">distance</code><span class="sig-paren">(</span><em>atom=None</em>, <em>R=None</em>, <em>tol=0.1</em>, <em>method='average'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the distances for all atoms in shells of radius <code class="docutils literal"><span class="pre">tol</span></code> within <code class="docutils literal"><span class="pre">max_R</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int or array_like, optional</p>
<blockquote>
<div><p>only create list of distances from the given atoms, default to all atoms</p>
</div></blockquote>
<p><strong>R</strong> : float, optional</p>
<blockquote>
<div><p>the maximum radius to consider, default to <code class="docutils literal"><span class="pre">self.maxR()</span></code>.
To retrieve all distances for atoms within the supercell structure
you can pass <code class="xref py py-obj docutils literal"><span class="pre">numpy.inf</span></code>.</p>
</div></blockquote>
<p><strong>tol</strong> : float or array_like, optional</p>
<blockquote>
<div><p>the tolerance for grouping a set of atoms.
This parameter sets the shell radius for each shell.
I.e. the returned distances between two shells will be maximally
<em class="xref py py-obj">2*tol</em>, but only if atoms are within two consecutive lists.
If this is a list, the shells will be of unequal size.</p>
<p>The first shell size will be <em class="xref py py-obj">tol * .5</em> or <em class="xref py py-obj">tol[0] * .5</em> if <code class="docutils literal"><span class="pre">tol</span></code> is a list.</p>
</div></blockquote>
<p><strong>method</strong> : {‘average’, ‘mode’, ‘&lt;numpy.func&gt;’, func}</p>
<blockquote>
<div><p>How the distance in each shell is determined.
A list of distances within each shell is gathered and the equivalent
method will be used to extract a single quantity from the list of
distances in the shell.
If <em class="xref py py-obj">‘mode’</em> is chosen it will use <code class="docutils literal"><span class="pre">scipy.stats.mode</span></code>.
If a string is given it will correspond to <code class="docutils literal"><span class="pre">getattr(numpy,</span> <span class="pre">method)</span></code>,
while any callable function may be passed. The passed function
will only be passed a list of unsorted distances that needs to be
processed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">numpy.ndarray</p>
<blockquote class="last">
<div><p>an array of positive numbers yielding the distances from the atoms in reduced form</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.sparserij" title="sisl.Geometry.sparserij"><code class="xref py py-obj docutils literal"><span class="pre">sparserij</span></code></a></dt>
<dd>return a sparse matrix will all distances between atoms</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">1.</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">SuperCell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">()</span> <span class="c1"># use geom.maxR()</span>
<span class="go">[ 1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="go">[ 1.          1.41421356]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="go">[ 1.          1.41421356  2.        ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span> <span class="c1"># the R = 1 and R = 2 ** .5 gets averaged</span>
<span class="go">[ 1.20710678  2.        ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.equal">
<code class="descname">equal</code><span class="sig-paren">(</span><em>other</em>, <em>R=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether two geometries are the same (optional not check of the orbital radius)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>other</strong> : Geometry</p>
<blockquote>
<div><p>the other Geometry to check against</p>
</div></blockquote>
<p><strong>maxR</strong> : bool, optional</p>
<blockquote class="last">
<div><p>if True also check if the orbital radii are the same (see <a class="reference internal" href="sisl.Atom.html#sisl.Atom.equal" title="sisl.Atom.equal"><code class="xref py py-obj docutils literal"><span class="pre">Atom.equal</span></code></a>)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.firsto">
<code class="descname">firsto</code><a class="headerlink" href="#sisl.Geometry.firsto" title="Permalink to this definition">¶</a></dt>
<dd><p>The first orbital on the corresponding atom</p>
</dd></dl>

<dl class="classmethod">
<dt id="sisl.Geometry.fromASE">
<em class="property">classmethod </em><code class="descname">fromASE</code><span class="sig-paren">(</span><em>aseg</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.fromASE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.fromASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns geometry from an ASE object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>aseg</strong> : ASE <code class="docutils literal"><span class="pre">Atoms</span></code> object which contains the following routines:</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">get_atomic_numbers</span></code>, <code class="docutils literal"><span class="pre">get_positions</span></code>, <code class="docutils literal"><span class="pre">get_cell</span></code>.
From those methods a <a class="reference internal" href="sisl.html#module-sisl" title="sisl"><code class="xref py py-obj docutils literal"><span class="pre">sisl</span></code></a> object will be created.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.fxyz">
<code class="descname">fxyz</code><a class="headerlink" href="#sisl.Geometry.fxyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns geometry coordinates in fractional coordinates</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iR">
<code class="descname">iR</code><span class="sig-paren">(</span><em>na=1000</em>, <em>iR=20</em>, <em>R=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an integer number of maximum radii (<em class="xref py py-obj">self.maxR()</em>) which holds approximately <a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal"><span class="pre">na</span></code></a> atoms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>na</strong> : int, optional</p>
<blockquote>
<div><p>number of atoms within the radius</p>
</div></blockquote>
<p><strong>iR</strong> : int, optional</p>
<blockquote>
<div><p>initial <code class="docutils literal"><span class="pre">iR</span></code> value, which the sphere is estitametd from</p>
</div></blockquote>
<p><strong>R</strong> : float, optional</p>
<blockquote class="last">
<div><p>the value used for atomic range (defaults to <code class="docutils literal"><span class="pre">self.maxR()</span></code>)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>atom</em>, <em>geom</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts other atoms right before index</p>
<p>We insert the <code class="docutils literal"><span class="pre">geom</span></code> <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal"><span class="pre">Geometry</span></code></a> before <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal"><span class="pre">atom</span></code></a>.
Note that this will not change the unit cell.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int</p>
<blockquote>
<div><p>the index at which atom the other geometry is inserted</p>
</div></blockquote>
<p><strong>geom</strong> : Geometry</p>
<blockquote class="last">
<div><p>the other geometry to be inserted</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal"><span class="pre">add</span></code></a></dt>
<dd>add geometries</dd>
<dt><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal"><span class="pre">append</span></code></a></dt>
<dd>appending geometries</dd>
<dt><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal"><span class="pre">prepend</span></code></a></dt>
<dd>prending geometries</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code></a></dt>
<dd>attach a geometry</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.is_orthogonal">
<code class="descname">is_orthogonal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.is_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if all cell vectors are linearly independent</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.isc_off">
<code class="descname">isc_off</code><a class="headerlink" href="#sisl.Geometry.isc_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.isc_off" title="sisl.Geometry.isc_off"><code class="xref py py-obj docutils literal"><span class="pre">isc_off</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter">
<code class="descname">iter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator over all atomic indices</p>
<p>This iterator is the same as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
<span class="gp">... </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
<dl class="docutils">
<dt>or equivalently</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
<span class="gp">... </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.iter_species" title="sisl.Geometry.iter_species"><code class="xref py py-obj docutils literal"><span class="pre">iter_species</span></code></a></dt>
<dd>iterate across indices and atomic species</dd>
<dt><a class="reference internal" href="#sisl.Geometry.iter_orbitals" title="sisl.Geometry.iter_orbitals"><code class="xref py py-obj docutils literal"><span class="pre">iter_orbitals</span></code></a></dt>
<dd>iterate across atomic indices and orbital indices</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_block">
<code class="descname">iter_block</code><span class="sig-paren">(</span><em>iR=10</em>, <em>R=None</em>, <em>atom=None</em>, <em>method='rand'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator for performance critical loops</p>
<p>NOTE: This requires that <em class="xref py py-obj">R</em> has been set correctly as the maximum interaction range.</p>
<p>I.e. the loop would look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block</span><span class="p">():</span>
<span class="gp">... </span>   <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
<span class="gp">... </span>       <span class="n">idx_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">)</span>
</pre></div>
</div>
<p>This iterator is intended for systems with more than 1000 atoms.</p>
<p>Remark that the iterator used is non-deterministic, i.e. any two iterators need
not return the same atoms in any way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>iR</strong> : int, optional</p>
<blockquote>
<div><p>the number of <code class="docutils literal"><span class="pre">R</span></code> ranges taken into account when doing the iterator</p>
</div></blockquote>
<p><strong>R</strong> : float, optional</p>
<blockquote>
<div><p>enables overwriting the local R quantity. Defaults to <code class="docutils literal"><span class="pre">self.maxR()</span></code></p>
</div></blockquote>
<p><strong>atom</strong> : array_like, optional</p>
<blockquote>
<div><p>enables only effectively looping a subset of the full geometry</p>
</div></blockquote>
<p><strong>method</strong> : {‘rand’, ‘sphere’, ‘cube’}</p>
<blockquote>
<div><p>select the method by which the block iteration is performed.
Possible values are:</p>
<blockquote>
<div><p><em class="xref py py-obj">rand</em>: a spherical object is constructed with a random center according to the internal atoms
<em class="xref py py-obj">sphere</em>: a spherical equispaced shape is constructed and looped
<em class="xref py py-obj">cube</em>: a cube shape is constructed and looped</p>
</div></blockquote>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Two lists with <code class="docutils literal"><span class="pre">[0]</span></code> being a list of atoms to be looped and <code class="docutils literal"><span class="pre">[1]</span></code> being the atoms that</p>
<p class="last">need searched.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_block_rand">
<code class="descname">iter_block_rand</code><span class="sig-paren">(</span><em>iR=10</em>, <em>R=None</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_block_rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_block_rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the <em>random</em> block-iteration by randomly selecting the next center of block</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_block_shape">
<code class="descname">iter_block_shape</code><span class="sig-paren">(</span><em>shape=None</em>, <em>iR=10</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_block_shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_block_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the <em>grid</em> block-iteration by looping a grid</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_orbitals">
<code class="descname">iter_orbitals</code><span class="sig-paren">(</span><em>atom=None</em>, <em>local=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_orbitals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_orbitals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over all atoms and their associated orbitals</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_orbitals</span><span class="p">():</span>
</pre></div>
</div>
<p>with <code class="docutils literal"><span class="pre">ia</span></code> being the atomic index, <code class="docutils literal"><span class="pre">io</span></code> the associated orbital index on atom <code class="docutils literal"><span class="pre">ia</span></code>.
Note that <code class="docutils literal"><span class="pre">io</span></code> will start from <code class="docutils literal"><span class="pre">0</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int or array_like, optional</p>
<blockquote>
<div><p>only loop on the given atoms, default to all atoms</p>
</div></blockquote>
<p><strong>local</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the orbital index is the global index, or the local index relative to
the atom it resides on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.iter" title="sisl.Geometry.iter"><code class="xref py py-obj docutils literal"><span class="pre">iter</span></code></a></dt>
<dd>iterate over atomic indices</dd>
<dt><a class="reference internal" href="#sisl.Geometry.iter_species" title="sisl.Geometry.iter_species"><code class="xref py py-obj docutils literal"><span class="pre">iter_species</span></code></a></dt>
<dd>iterate across indices and atomic species</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_species">
<code class="descname">iter_species</code><span class="sig-paren">(</span><em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_species"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_species" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator over all atoms and species as a tuple in this geometry</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">idx_specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_species</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>
<span class="gp">... </span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>
<span class="gp">... </span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_specie</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>
</pre></div>
</div>
<p>with <code class="docutils literal"><span class="pre">ia</span></code> being the atomic index, <code class="docutils literal"><span class="pre">a</span></code> the <a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><code class="xref py py-obj docutils literal"><span class="pre">Atom</span></code></a> object, <em class="xref py py-obj">idx_specie</em>
is the index of the specie</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int or array_like, optional</p>
<blockquote class="last">
<div><p>only loop on the given atoms, default to all atoms</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.iter" title="sisl.Geometry.iter"><code class="xref py py-obj docutils literal"><span class="pre">iter</span></code></a></dt>
<dd>iterate over atomic indices</dd>
<dt><a class="reference internal" href="#sisl.Geometry.iter_orbitals" title="sisl.Geometry.iter_orbitals"><code class="xref py py-obj docutils literal"><span class="pre">iter_orbitals</span></code></a></dt>
<dd>iterate across atomic indices and orbital indices</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.lasto">
<code class="descname">lasto</code><a class="headerlink" href="#sisl.Geometry.lasto" title="Permalink to this definition">¶</a></dt>
<dd><p>The last orbital on the corresponding atom</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.mass">
<code class="descname">mass</code><a class="headerlink" href="#sisl.Geometry.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mass of all atoms as an array</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.maxR">
<code class="descname">maxR</code><span class="sig-paren">(</span><em>all=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.maxR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.maxR" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum orbital range of the atoms</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.mirror">
<code class="descname">mirror</code><span class="sig-paren">(</span><em>plane</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.mirror"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirrors the structure around the center of the atoms</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.move">
<code class="descname">move</code><span class="sig-paren">(</span><em>v</em>, <em>atom=None</em>, <em>cell=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></p>
<p>One can translate a subset of the atoms by supplying <code class="docutils literal"><span class="pre">atom</span></code>.</p>
<p>Returns a copy of the structure translated by <code class="docutils literal"><span class="pre">v</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>v</strong> : array_like</p>
<blockquote>
<div><p>the vector to displace all atomic coordinates</p>
</div></blockquote>
<p><strong>atom</strong> : int or array_like, optional</p>
<blockquote>
<div><p>only displace the given atomic indices, if not specified, all
atoms will be displaced</p>
</div></blockquote>
<p><strong>cell</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If True the supercell also gets enlarged by the vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.n_s">
<code class="descname">n_s</code><a class="headerlink" href="#sisl.Geometry.n_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.n_s" title="sisl.Geometry.n_s"><code class="xref py py-obj docutils literal"><span class="pre">n_s</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.na">
<code class="descname">na</code><a class="headerlink" href="#sisl.Geometry.na" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of atoms in geometry</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.na_s">
<code class="descname">na_s</code><a class="headerlink" href="#sisl.Geometry.na_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of supercell atoms</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.no">
<code class="descname">no</code><a class="headerlink" href="#sisl.Geometry.no" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of orbitals</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.no_s">
<code class="descname">no_s</code><a class="headerlink" href="#sisl.Geometry.no_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of supercell orbitals</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.nsc">
<code class="descname">nsc</code><a class="headerlink" href="#sisl.Geometry.nsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.nsc" title="sisl.Geometry.nsc"><code class="xref py py-obj docutils literal"><span class="pre">nsc</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.o2a">
<code class="descname">o2a</code><span class="sig-paren">(</span><em>io</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.o2a"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.o2a" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic index corresponding to the orbital indicies.</p>
<p>This is a particurlaly slow algorithm due to for-loops.</p>
<p>Note that this will preserve the super-cell offsets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>io: array_like</strong></p>
<blockquote>
<div><p>List of indices to return the atoms for</p>
</div></blockquote>
<p><strong>uniq</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If True only return the unique atoms.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.o2isc">
<code class="descname">o2isc</code><span class="sig-paren">(</span><em>io</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.o2isc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.o2isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell index for a specific orbital.</p>
<p>Returns a vector of 3 numbers with integers.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.o2sc">
<code class="descname">o2sc</code><span class="sig-paren">(</span><em>o</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.o2sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.o2sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell offset for a specific orbital.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.optimize_nsc">
<code class="descname">optimize_nsc</code><span class="sig-paren">(</span><em>axis=None</em>, <em>R=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.optimize_nsc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.optimize_nsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the number of supercell connections based on <code class="docutils literal"><span class="pre">self.maxR()</span></code></p>
<p>After this routine the number of supercells may not necessarily be the same.</p>
<p>This is an in-place operation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : int or array_like, optional</p>
<blockquote>
<div><p>only optimize the specified axis (default to all)</p>
</div></blockquote>
<p><strong>R</strong> : float, optional</p>
<blockquote class="last">
<div><p>the maximum connection radius for each atom</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.orbitals">
<code class="descname">orbitals</code><a class="headerlink" href="#sisl.Geometry.orbitals" title="Permalink to this definition">¶</a></dt>
<dd><p>List of orbitals per atom</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.orij">
<code class="descname">orij</code><span class="sig-paren">(</span><em>io</em>, <em>jo</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.orij"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.orij" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance between orbital <a class="reference internal" href="sisl.io.html#module-sisl.io" title="sisl.io"><code class="xref py py-obj docutils literal"><span class="pre">io</span></code></a> and <em class="xref py py-obj">jo</em>, orbitals can be in super-cell indices</p>
<p>Returns the distance between two orbitals:</p>
<div class="math">
\[r_{ij} = |r_j - r_i|\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>io</strong> : int or array_like</p>
<blockquote>
<div><p>orbital index of first orbital</p>
</div></blockquote>
<p><strong>jo</strong> : int or array_like</p>
<blockquote class="last">
<div><p>orbital indices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.osc2uc">
<code class="descname">osc2uc</code><span class="sig-paren">(</span><em>orbs</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.osc2uc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.osc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns orbitals from super-cell indices to unit-cell indices, possibly removing dublicates</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.prepend">
<code class="descname">prepend</code><span class="sig-paren">(</span><em>other</em>, <em>axis</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.prepend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.prepend" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepends structure along <code class="docutils literal"><span class="pre">axis</span></code>. This will automatically
add the <code class="docutils literal"><span class="pre">self.cell[axis,:]</span></code> to all atomic coordiates in the
<code class="docutils literal"><span class="pre">other</span></code> structure before prepending.</p>
<p>The basic algorithm is this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oxa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oxa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="bp">None</span><span class="p">,:])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span>
</pre></div>
</div>
<p>NOTE: The cell prepended is only in the axis that
is prependend, which means that the other cell directions
need not conform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>other</strong> : Geometry or SuperCell</p>
<blockquote>
<div><p>Other geometry class which needs to be prepended
If a <code class="docutils literal"><span class="pre">SuperCell</span></code> only the super cell will be extended</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>Cell direction to which the <code class="docutils literal"><span class="pre">other</span></code> geometry should be
prepended</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal"><span class="pre">add</span></code></a></dt>
<dd>add geometries</dd>
<dt><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal"><span class="pre">append</span></code></a></dt>
<dd>appending geometries</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code></a></dt>
<dd>attach a geometry</dd>
<dt><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal"><span class="pre">insert</span></code></a></dt>
<dd>insert a geometry</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.rcell">
<code class="descname">rcell</code><a class="headerlink" href="#sisl.Geometry.rcell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.rcell" title="sisl.Geometry.rcell"><code class="xref py py-obj docutils literal"><span class="pre">rcell</span></code></a></p>
</dd></dl>

<dl class="staticmethod">
<dt id="sisl.Geometry.read">
<em class="property">static </em><code class="descname">read</code><span class="sig-paren">(</span><em>sile</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads geometry from the <code class="xref py py-obj docutils literal"><span class="pre">Sile</span></code> using <em class="xref py py-obj">Sile.read_geometry</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sile</strong> : <code class="xref py py-obj docutils literal"><span class="pre">Sile</span></code>, str</p>
<blockquote class="last">
<div><p>a <code class="xref py py-obj docutils literal"><span class="pre">Sile</span></code> object which will be used to read the geometry
if it is a string it will create a new sile using <code class="xref py py-obj docutils literal"><span class="pre">get_sile</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.write" title="sisl.Geometry.write"><code class="xref py py-obj docutils literal"><span class="pre">write</span></code></a></dt>
<dd>writes a <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal"><span class="pre">Geometry</span></code></a> to a given <code class="xref py py-obj docutils literal"><span class="pre">Sile</span></code>/file</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.reduce">
<code class="descname">reduce</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.reduce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all atoms not currently used in the <code class="docutils literal"><span class="pre">self.atom</span></code> object</p>
<p class="rubric">Notes</p>
<p>This is an in-place operation.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>atom</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove atoms from the geometry.</p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : array_like</p>
<blockquote class="last">
<div><p>indices of all atoms to be removed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.sub" title="sisl.Geometry.sub"><code class="xref py py-obj docutils literal"><span class="pre">sub</span></code></a></dt>
<dd>the negative of this routine, i.e. retain a subset of atoms</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.reorder">
<code class="descname">reorder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.reorder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorders atoms according to first occurence in the geometry</p>
<p class="rubric">Notes</p>
<p>This is an in-place operation.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.repeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a repeated geometry</p>
<p>The atomic indices are <em>NOT</em> retained for the base structure.</p>
<p>The expansion of the atoms are basically performed using this
algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ja</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="gp">... </span>          <span class="n">ja</span> <span class="o">=</span> <span class="n">ia</span> <span class="o">+</span> <span class="n">cell</span><span class="p">[</span><span class="nb">id</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">i</span>
</pre></div>
</div>
<p>This method allows to utilise Bloch’s theorem when creating
Hamiltonian parameter sets for TBtrans.</p>
<p>For geometries with a single atom this routine returns the same as
<a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a>.</p>
<p>It is adviced to only use this for electrode Bloch’s theorem
purposes as <a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a> is faster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reps</strong> : int</p>
<blockquote>
<div><p>number of repetitions</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>direction of repetition, 0, 1, 2 according to the cell-direction</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a></dt>
<dd>equivalent but different ordering of final structure</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span><span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 0.   1.   0. ]</span>
<span class="go"> [ 1.   1.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]</span>
<span class="go"> [ 0.5  1.   0. ]</span>
<span class="go"> [ 1.5  1.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.reverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reversed geometry</p>
<p>Also enables reversing a subset of the atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int or array_like, optional</p>
<blockquote class="last">
<div><p>only reverse the given atomic indices, if not specified, all
atoms will be reversed</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.rij">
<code class="descname">rij</code><span class="sig-paren">(</span><em>ia</em>, <em>ja</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.rij"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.rij" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</p>
<p>Returns the distance between two atoms:</p>
<div class="math">
\[r_{ij} = |r_j - r_i|\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ia</strong> : int or array_like</p>
<blockquote>
<div><p>atomic index of first atom</p>
</div></blockquote>
<p><strong>ja</strong> : int or array_like</p>
<blockquote class="last">
<div><p>atomic indices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>angle</em>, <em>v</em>, <em>origo=None</em>, <em>atom=None</em>, <em>only='abc+xyz'</em>, <em>rad=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate geometry around vector and return a new geometry</p>
<p>Per default will the entire geometry be rotated, such that everything
is aligned as before rotation.</p>
<p>However, by supplying <code class="docutils literal"><span class="pre">only</span> <span class="pre">=</span> <span class="pre">'abc|xyz'</span></code> one can designate which
part of the geometry that will be rotated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>angle</strong> : float</p>
<blockquote>
<div><p>the angle in radians of which the geometry should be rotated</p>
</div></blockquote>
<p><strong>v</strong> : array_like</p>
<blockquote>
<div><p>the normal vector to the rotated plane, i.e.
v = [1,0,0] will rotate the <code class="docutils literal"><span class="pre">yz</span></code> plane</p>
</div></blockquote>
<p><strong>origo</strong> : int or array_like, optional</p>
<blockquote>
<div><p>the origin of rotation. Anything but [0, 0, 0] is equivalent
to a <em class="xref py py-obj">self.move(-origo).rotate(…).move(origo)</em>.
If this is an <em class="xref py py-obj">int</em> it corresponds to the atomic index.</p>
</div></blockquote>
<p><strong>atom</strong> : int or array_like, optional</p>
<blockquote>
<div><p>only rotate the given atomic indices, if not specified, all
atoms will be rotated.</p>
</div></blockquote>
<p><strong>only</strong> : {‘abc+xyz’, ‘xyz’, ‘abc’}</p>
<blockquote class="last">
<div><p>which coordinate subject should be rotated,
if <code class="docutils literal"><span class="pre">abc</span></code> is in this string the cell will be rotated
if <code class="docutils literal"><span class="pre">xyz</span></code> is in this string the coordinates will be rotated</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="sisl.Quaternion.html#sisl.Quaternion" title="sisl.Quaternion"><code class="xref py py-obj docutils literal"><span class="pre">Quaternion</span></code></a></dt>
<dd>class to rotate</dd>
<dt><a class="reference internal" href="#sisl.Geometry.rotatea" title="sisl.Geometry.rotatea"><code class="xref py py-obj docutils literal"><span class="pre">rotatea</span></code></a></dt>
<dd>generic function for rotating around first lattice vector</dd>
<dt><a class="reference internal" href="#sisl.Geometry.rotateb" title="sisl.Geometry.rotateb"><code class="xref py py-obj docutils literal"><span class="pre">rotateb</span></code></a></dt>
<dd>generic function for rotating around second lattice vector</dd>
<dt><a class="reference internal" href="#sisl.Geometry.rotatec" title="sisl.Geometry.rotatec"><code class="xref py py-obj docutils literal"><span class="pre">rotatec</span></code></a></dt>
<dd>generic function for rotating around third lattice vector</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.rotate_miller">
<code class="descname">rotate_miller</code><span class="sig-paren">(</span><em>m</em>, <em>v</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.rotate_miller"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.rotate_miller" title="Permalink to this definition">¶</a></dt>
<dd><p>Align Miller direction along <code class="docutils literal"><span class="pre">v</span></code></p>
<p>Rotate geometry and cell such that the Miller direction
points along the Cartesian vector <code class="docutils literal"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.rotatea">
<code class="descname">rotatea</code><span class="sig-paren">(</span><em>angle</em>, <em>origo=None</em>, <em>atom=None</em>, <em>only='abc+xyz'</em>, <em>rad=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.rotatea"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.rotatea" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate around first lattice vector</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.rotate" title="sisl.Geometry.rotate"><code class="xref py py-obj docutils literal"><span class="pre">rotate</span></code></a></dt>
<dd>generic function of this, this routine calls <a class="reference internal" href="#sisl.Geometry.rotate" title="sisl.Geometry.rotate"><code class="xref py py-obj docutils literal"><span class="pre">rotate</span></code></a> with <em class="xref py py-obj">v = self.cell[0, :]</em></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.rotateb">
<code class="descname">rotateb</code><span class="sig-paren">(</span><em>angle</em>, <em>origo=None</em>, <em>atom=None</em>, <em>only='abc+xyz'</em>, <em>rad=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.rotateb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.rotateb" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate around second lattice vector</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.rotate" title="sisl.Geometry.rotate"><code class="xref py py-obj docutils literal"><span class="pre">rotate</span></code></a></dt>
<dd>generic function of this, this routine calls <a class="reference internal" href="#sisl.Geometry.rotate" title="sisl.Geometry.rotate"><code class="xref py py-obj docutils literal"><span class="pre">rotate</span></code></a> with <em class="xref py py-obj">v = self.cell[1, :]</em></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.rotatec">
<code class="descname">rotatec</code><span class="sig-paren">(</span><em>angle</em>, <em>origo=None</em>, <em>atom=None</em>, <em>only='abc+xyz'</em>, <em>rad=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.rotatec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.rotatec" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate around third lattice vector</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.rotate" title="sisl.Geometry.rotate"><code class="xref py py-obj docutils literal"><span class="pre">rotate</span></code></a></dt>
<dd>generic function of this, this routine calls <a class="reference internal" href="#sisl.Geometry.rotate" title="sisl.Geometry.rotate"><code class="xref py py-obj docutils literal"><span class="pre">rotate</span></code></a> with <em class="xref py py-obj">v = self.cell[2, :]</em></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.sc2uc">
<code class="descname">sc2uc</code><span class="sig-paren">(</span><em>atom</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.sc2uc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.sc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atom from super-cell indices to unit-cell indices, possibly removing dublicates</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.sc_index">
<code class="descname">sc_index</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.sc_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Call local <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> object <a class="reference internal" href="#sisl.Geometry.sc_index" title="sisl.Geometry.sc_index"><code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code></a> function</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.sc_off">
<code class="descname">sc_off</code><a class="headerlink" href="#sisl.Geometry.sc_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.sc_off" title="sisl.Geometry.sc_off"><code class="xref py py-obj docutils literal"><span class="pre">sc_off</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>scale</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale coordinates and unit-cell to get a new geometry with proper scaling</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scale</strong> : float</p>
<blockquote class="last">
<div><p>the scale factor for the new geometry (lattice vectors, coordinates
and the atomic radii are scaled).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.set_nsc">
<code class="descname">set_nsc</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.set_nsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the number of super-cells in the <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> object</p>
<p>See <a class="reference internal" href="#sisl.Geometry.set_nsc" title="sisl.Geometry.set_nsc"><code class="xref py py-obj docutils literal"><span class="pre">set_nsc</span></code></a> for allowed parameters.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell.set_nsc" title="sisl.SuperCell.set_nsc"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell.set_nsc</span></code></a></dt>
<dd>the underlying called method</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.set_sc">
<code class="descname">set_sc</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.set_sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the local supercell</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.set_supercell">
<code class="descname">set_supercell</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.set_supercell" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the local supercell</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.sparserij">
<code class="descname">sparserij</code><span class="sig-paren">(</span><em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>na_iR=1000</em>, <em>method='rand'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.sparserij"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.sparserij" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sparse matrix with all distances in the matrix</p>
<p>The sparse matrix will only be defined for the elements which have
orbitals overlapping with other atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dtype</strong> : numpy.dtype, numpy.float64</p>
<blockquote>
<div><p>the data-type of the sparse matrix</p>
</div></blockquote>
<p><strong>na_iR</strong> : int, 1000</p>
<blockquote>
<div><p>number of atoms within the sphere for speeding
up the <a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal"><span class="pre">iter_block</span></code></a> loop.</p>
</div></blockquote>
<p><strong>method</strong> : str, ‘rand’</p>
<blockquote>
<div><p>see <a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal"><span class="pre">iter_block</span></code></a> for details</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">SparseAtom</p>
<blockquote class="last">
<div><p>sparse matrix with all rij elements</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal"><span class="pre">iter_block</span></code></a></dt>
<dd>the method for looping the atoms</dd>
<dt><a class="reference internal" href="#sisl.Geometry.distance" title="sisl.Geometry.distance"><code class="xref py py-obj docutils literal"><span class="pre">distance</span></code></a></dt>
<dd>create a list of distances</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.sub">
<code class="descname">sub</code><span class="sig-paren">(</span><em>atom</em>, <em>cell=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal"><span class="pre">Geometry</span></code></a> with a subset of this <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal"><span class="pre">Geometry</span></code></a></p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : array_like</p>
<blockquote>
<div><p>indices of all atoms to be removed.</p>
</div></blockquote>
<p><strong>cell</strong> : array_like or SuperCell, optional</p>
<blockquote class="last">
<div><p>the new associated cell of the geometry (defaults to the same cell)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell.fit" title="sisl.SuperCell.fit"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell.fit</span></code></a></dt>
<dd>update the supercell according to a reference supercell</dd>
<dt><a class="reference internal" href="#sisl.Geometry.remove" title="sisl.Geometry.remove"><code class="xref py py-obj docutils literal"><span class="pre">remove</span></code></a></dt>
<dd>the negative of this routine, i.e. remove a subset of atoms</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.swap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap a set of atoms in the geometry and return a new one</p>
<p>This can be used to reorder elements of a geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>the first list of atomic coordinates</p>
</div></blockquote>
<p><strong>b</strong> : array_like</p>
<blockquote class="last">
<div><p>the second list of atomic coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.swapaxes">
<code class="descname">swapaxes</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>swap='cell+xyz'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.swapaxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the axis for the atomic coordinates and the cell vectors</p>
<p>If <code class="docutils literal"><span class="pre">swapaxes(0,1)</span></code> it returns the 0 and 1 values
swapped in the <code class="docutils literal"><span class="pre">cell</span></code> variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : int</p>
<blockquote>
<div><p>axes 1, swaps with <code class="docutils literal"><span class="pre">b</span></code></p>
</div></blockquote>
<p><strong>b</strong> : int</p>
<blockquote>
<div><p>axes 2, swaps with <code class="docutils literal"><span class="pre">a</span></code></p>
</div></blockquote>
<p><strong>swap</strong> : {‘cell+xyz’, ‘cell’, ‘xyz’}</p>
<blockquote class="last">
<div><p>decide what to swap, if <em class="xref py py-obj">‘cell’</em> is in <a class="reference internal" href="#sisl.Geometry.swap" title="sisl.Geometry.swap"><code class="xref py py-obj docutils literal"><span class="pre">swap</span></code></a> then
the cell axis are swapped.
if <em class="xref py py-obj">‘xyz’</em> is in <a class="reference internal" href="#sisl.Geometry.swap" title="sisl.Geometry.swap"><code class="xref py py-obj docutils literal"><span class="pre">swap</span></code></a> then
the xyz (Cartesian) axis are swapped.
Both may be in <a class="reference internal" href="#sisl.Geometry.swap" title="sisl.Geometry.swap"><code class="xref py py-obj docutils literal"><span class="pre">swap</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.tile">
<code class="descname">tile</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.tile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Tile the geometry to create a bigger one</p>
<p>The atomic indices are retained for the base structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reps</strong> : int</p>
<blockquote>
<div><p>number of tiles (repetitions)</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>direction of tiling, 0, 1, 2 according to the cell-direction</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.repeat" title="sisl.Geometry.repeat"><code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code></a></dt>
<dd>equivalent but different ordering of final structure</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span><span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]</span>
<span class="go"> [ 0.   1.   0. ]</span>
<span class="go"> [ 0.5  1.   0. ]</span>
<span class="go"> [ 1.   1.   0. ]</span>
<span class="go"> [ 1.5  1.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.toASE">
<code class="descname">toASE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.toASE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.toASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the geometry as an ASE <code class="docutils literal"><span class="pre">Atoms</span></code> object</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>v</em>, <em>atom=None</em>, <em>cell=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></p>
<p>One can translate a subset of the atoms by supplying <code class="docutils literal"><span class="pre">atom</span></code>.</p>
<p>Returns a copy of the structure translated by <code class="docutils literal"><span class="pre">v</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>v</strong> : array_like</p>
<blockquote>
<div><p>the vector to displace all atomic coordinates</p>
</div></blockquote>
<p><strong>atom</strong> : int or array_like, optional</p>
<blockquote>
<div><p>only displace the given atomic indices, if not specified, all
atoms will be displaced</p>
</div></blockquote>
<p><strong>cell</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If True the supercell also gets enlarged by the vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.vol">
<code class="descname">vol</code><a class="headerlink" href="#sisl.Geometry.vol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.vol" title="sisl.Geometry.vol"><code class="xref py py-obj docutils literal"><span class="pre">vol</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.within">
<code class="descname">within</code><span class="sig-paren">(</span><em>shapes</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_xyz=False</em>, <em>ret_rij=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.within"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.within" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of atoms in the entire supercell within a given shape from a given coordinate</p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.Geometry.within_sc" title="sisl.Geometry.within_sc"><code class="xref py py-obj docutils literal"><span class="pre">within_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shapes</strong> : Shape, list of Shape</p>
<p><strong>idx</strong> : array_like, optional</p>
<blockquote>
<div><p>List of indices for atoms that are to be considered</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : array_like, optional</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <code class="docutils literal"><span class="pre">idx</span></code> variable (<code class="docutils literal"><span class="pre">idx</span></code> must also be passed)</p>
</div></blockquote>
<p><strong>ret_xyz</strong> : bool, optional</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_rij</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If true this method will return the distances from the <code class="docutils literal"><span class="pre">xyz_ia</span></code>
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.within_sc">
<code class="descname">within_sc</code><span class="sig-paren">(</span><em>shapes</em>, <em>isc=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_xyz=False</em>, <em>ret_rij=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.within_sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.within_sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of atoms in a given supercell within a given shape from a given coordinate</p>
<p>This returns a set of atomic indices which are within a
sphere of radius <code class="docutils literal"><span class="pre">R</span></code>.</p>
<p>If R is a tuple/list/array it will return the indices:
in the ranges:
&gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shapes</strong> : Shape or list of Shape</p>
<blockquote>
<div><p>A list of increasing shapes that define the extend of the geometric
volume that is searched.
It is vital that:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>isc</strong> : array_like, optional</p>
<blockquote>
<div><p>The super-cell which the coordinates are checked in. Defaults to <em class="xref py py-obj">[0, 0, 0]</em></p>
</div></blockquote>
<p><strong>idx</strong> : array_like, optional</p>
<blockquote>
<div><p>List of atoms that will be considered. This can
be used to only take out a certain atoms.</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : array_like, optional</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <code class="docutils literal"><span class="pre">idx</span></code> variable (<code class="docutils literal"><span class="pre">idx</span></code> must also be passed)</p>
</div></blockquote>
<p><strong>ret_xyz</strong> : bool, optional</p>
<blockquote>
<div><p>If True this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_rij</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If True this method will return the distance
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>sile</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes geometry to the <code class="xref py py-obj docutils literal"><span class="pre">Sile</span></code> using <em class="xref py py-obj">sile.write_geometry</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sile</strong> : <code class="docutils literal"><span class="pre">Sile</span></code>, <code class="docutils literal"><span class="pre">str</span></code></p>
<blockquote>
<div><p>a <code class="xref py py-obj docutils literal"><span class="pre">Sile</span></code> object which will be used to write the geometry
if it is a string it will create a new sile using <code class="xref py py-obj docutils literal"><span class="pre">get_sile</span></code></p>
</div></blockquote>
<p><strong>*args, **kwargs:</strong></p>
<blockquote class="last">
<div><p>Any other args will be passed directly to the
underlying routine</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.Geometry.read" title="sisl.Geometry.read"><code class="xref py py-obj docutils literal"><span class="pre">read</span></code></a></dt>
<dd>reads a <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal"><span class="pre">Geometry</span></code></a> from a given <code class="xref py py-obj docutils literal"><span class="pre">Sile</span></code>/file</dd>
</dl>
</div>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, Nick R. Papior.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.8.5-282',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>