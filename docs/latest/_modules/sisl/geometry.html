

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sisl.geometry &mdash; sisl |release| documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="sisl |release| documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                0.9.2-190
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cite.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">sisl</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>sisl.geometry</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sisl.geometry</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="c1"># To check for integers</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Real</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="k">import</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">acos</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">square</span><span class="p">,</span> <span class="n">sqrt</span>

<span class="kn">import</span> <span class="nn">sisl._plot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sisl._array</span> <span class="k">as</span> <span class="nn">_a</span>
<span class="kn">import</span> <span class="nn">sisl.linalg</span> <span class="k">as</span> <span class="nn">lin</span>

<span class="kn">from</span> <span class="nn">._help</span> <span class="k">import</span> <span class="n">_str</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="k">import</span> <span class="n">_range</span> <span class="k">as</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="k">import</span> <span class="n">ensure_array</span><span class="p">,</span> <span class="n">ensure_dtype</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="k">import</span> <span class="n">isndarray</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">default_ArgumentParser</span><span class="p">,</span> <span class="n">default_namespace</span><span class="p">,</span> <span class="n">cmd</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">angle</span><span class="p">,</span> <span class="n">direction</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">lstranges</span><span class="p">,</span> <span class="n">strmap</span><span class="p">,</span> <span class="n">array_arange</span>
<span class="kn">from</span> <span class="nn">.quaternion</span> <span class="k">import</span> <span class="n">Quaternion</span>
<span class="kn">from</span> <span class="nn">.supercell</span> <span class="k">import</span> <span class="n">SuperCell</span><span class="p">,</span> <span class="n">SuperCellChild</span>
<span class="kn">from</span> <span class="nn">.atom</span> <span class="k">import</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atoms</span>
<span class="kn">from</span> <span class="nn">.shape</span> <span class="k">import</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">Sphere</span><span class="p">,</span> <span class="n">Cube</span>
<span class="kn">from</span> <span class="nn">.sparse_geometry</span> <span class="k">import</span> <span class="n">SparseAtom</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;sgeom&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Geometry"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry">[docs]</a><span class="k">class</span> <span class="nc">Geometry</span><span class="p">(</span><span class="n">SuperCellChild</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Holds atomic information, coordinates, species, lattice vectors</span>

<span class="sd">    The `Geometry` class holds information regarding atomic coordinates,</span>
<span class="sd">    the atomic species, the corresponding lattice-vectors.</span>

<span class="sd">    It enables the interaction and conversion of atomic structures via</span>
<span class="sd">    simple routine methods.</span>

<span class="sd">    All lengths are assumed to be in units of Angstrom, however, as</span>
<span class="sd">    long as units are kept same the exact units are irrespective.</span>

<span class="sd">    .. code::</span>

<span class="sd">       &gt;&gt;&gt; square = Geometry([[0.5, 0.5, 0.5]], Atom(1),</span>
<span class="sd">       ...                   sc=SuperCell([1, 1, 10], nsc=[3, 3, 1]))</span>
<span class="sd">       &gt;&gt;&gt; print(square)</span>
<span class="sd">       Geometry{na: 1, no: 1,</span>
<span class="sd">        Atoms{species: 1,</span>
<span class="sd">         Atom{H, Z: 1, mass(au): 1.0079, maxR: -1.00000,</span>
<span class="sd">          Orbital{R: -1.0}</span>
<span class="sd">         }: 1,</span>
<span class="sd">        },</span>
<span class="sd">        nsc: [3, 3, 1], maxR: -1.0</span>
<span class="sd">       }</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    na : int</span>
<span class="sd">        number of atoms, ``len(self)``</span>
<span class="sd">    xyz : ndarray</span>
<span class="sd">        atomic coordinates</span>
<span class="sd">    atom : Atoms</span>
<span class="sd">        the atomic objects associated with each atom (indexable)</span>
<span class="sd">    sc : SuperCell</span>
<span class="sd">        the supercell describing the periodicity of the</span>
<span class="sd">        geometry</span>
<span class="sd">    no: int</span>
<span class="sd">        total number of orbitals in the geometry</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xyz : array_like</span>
<span class="sd">        atomic coordinates</span>
<span class="sd">        ``xyz[i, :]`` is the atomic coordinate of the i&#39;th atom.</span>
<span class="sd">    atom : array_like or Atoms</span>
<span class="sd">        atomic species retrieved from the `PeriodicTable`</span>
<span class="sd">    sc : SuperCell</span>
<span class="sd">        the unit-cell describing the atoms in a periodic</span>
<span class="sd">        super-cell</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    An atomic lattice consisting of Hydrogen atoms.</span>
<span class="sd">    An atomic square lattice of Hydrogen atoms</span>

<span class="sd">    &gt;&gt;&gt; xyz = [[0, 0, 0],</span>
<span class="sd">    ...        [1, 1, 1]]</span>
<span class="sd">    &gt;&gt;&gt; sc = SuperCell([2,2,2])</span>
<span class="sd">    &gt;&gt;&gt; g = Geometry(xyz, Atom(&#39;H&#39;), sc)</span>

<span class="sd">    The following estimates the lattice vectors from the</span>
<span class="sd">    atomic coordinates, although possible, it is not recommended</span>
<span class="sd">    to be used.</span>

<span class="sd">    &gt;&gt;&gt; xyz = [[0, 0, 0],</span>
<span class="sd">    ...        [1, 1, 1]]</span>
<span class="sd">    &gt;&gt;&gt; g = Geometry(xyz, Atom(&#39;H&#39;))</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Atoms : contained atoms `self.atom`</span>
<span class="sd">    Atom : contained atoms are each an object of this</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Create the geometry coordinate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Default value</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>

        <span class="c1"># Create the local Atoms object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atom</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__init_sc</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initializes the supercell by *calculating* the size if not supplied</span>

<span class="sd">        If the supercell has not been passed we estimate the unit cell size</span>
<span class="sd">        by calculating the bond-length in each direction for a square</span>
<span class="sd">        Cartesian coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We still need the *default* super cell for</span>
        <span class="c1"># estimating the supercell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># First create an initial guess for the supercell</span>
        <span class="c1"># It HAS to be VERY large to not interact</span>
        <span class="n">closest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">5.</span><span class="p">))[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We could not find any atoms very close,</span>
            <span class="c1"># hence we simply return and now it becomes</span>
            <span class="c1"># the users responsibility</span>

            <span class="c1"># We create a molecule box with +10 A in each direction</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">10.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">m</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">sc_cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Initialize cartesian direction</span>
            <span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="c1"># Get longest distance between atoms</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">closest</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># Project onto the direction</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">cart</span><span class="p">))</span>

            <span class="c1"># Remove all below .4</span>
            <span class="n">tmp_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&gt;=</span> <span class="o">.</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We have a success</span>
                <span class="c1"># Add the bond-distance in the Cartesian direction</span>
                <span class="c1"># to the maximum distance in the same direction</span>
                <span class="n">sc_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_dist</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">dd</span><span class="p">[</span><span class="n">tmp_idx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default to LARGE array so as no</span>
                <span class="c1"># interaction occurs (it may be 2D)</span>
                <span class="n">sc_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">)</span>
            <span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Re-set the supercell to the newly found one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">sc_cart</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Atoms for the geometry (`Atoms` object) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom</span>

    <span class="c1"># Backwards compatability (do not use)</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="n">atom</span>

<div class="viewcode-block" id="Geometry.maxR"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.maxR">[docs]</a>    <span class="k">def</span> <span class="nf">maxR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Maximum orbital range of the atoms &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">maxR</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">na</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of atoms in geometry &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">na_s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of supercell atoms &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of atoms in geometry &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">no</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of orbitals &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">no</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">no_s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of supercell orbitals &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">firsto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The first orbital on the corresponding atom &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">firsto</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lasto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The last orbital on the corresponding atom &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">lasto</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; List of orbitals per atom &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">orbitals</span>

    <span class="c1">## End size of geometry</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Geometry coordinates (allows supercell indices) &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na_s</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">atom</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">atom</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="o">...</span><span class="p">,</span> <span class="n">atom</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">elif</span> <span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">()[:,</span> <span class="n">atom</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.reorder"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.reorder">[docs]</a>    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reorders atoms according to first occurence in the geometry</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is an in-place operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom</span><span class="o">.</span><span class="n">reorder</span><span class="p">()</span></div>

<div class="viewcode-block" id="Geometry.reduce"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove all atoms not currently used in the ``self.atom`` object</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is an in-place operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span></div>

<div class="viewcode-block" id="Geometry.rij"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.rij">[docs]</a>    <span class="k">def</span> <span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ja</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Distance between atom `ia` and `ja`, atoms can be in super-cell indices</span>

<span class="sd">        Returns the distance between two atoms:</span>

<span class="sd">        .. math::</span>
<span class="sd">            r_{ij} = |r_j - r_i|</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia : int or array_like</span>
<span class="sd">           atomic index of first atom</span>
<span class="sd">        ja : int or array_like</span>
<span class="sd">           atomic indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">ja</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>

        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Geometry.Rij"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.Rij">[docs]</a>    <span class="k">def</span> <span class="nf">Rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ja</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Vector between atom `ia` and `ja`, atoms can be in super-cell indices</span>

<span class="sd">        Returns the vector between two atoms:</span>

<span class="sd">        .. math::</span>
<span class="sd">            R_{ij} = r_j - r_i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia : int or array_like</span>
<span class="sd">           atomic index of first atom</span>
<span class="sd">        ja : int or array_like</span>
<span class="sd">           atomic indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>
        <span class="n">xj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ja</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ja</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">xj</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[:]</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">xj</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span>

        <span class="k">return</span> <span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="Geometry.orij"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.orij">[docs]</a>    <span class="k">def</span> <span class="nf">orij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">jo</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Distance between orbital `io` and `jo`, orbitals can be in super-cell indices</span>

<span class="sd">        Returns the distance between two orbitals:</span>

<span class="sd">        .. math::</span>
<span class="sd">            r_{ij} = |r_j - r_i|</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        io : int or array_like</span>
<span class="sd">           orbital index of first orbital</span>
<span class="sd">        jo : int or array_like</span>
<span class="sd">           orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">io</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">jo</span><span class="p">))</span></div>

<div class="viewcode-block" id="Geometry.oRij"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.oRij">[docs]</a>    <span class="k">def</span> <span class="nf">oRij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">jo</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Vector between orbital `io` and `jo`, orbitals can be in super-cell indices</span>

<span class="sd">        Returns the vector between two orbitals:</span>

<span class="sd">        .. math::</span>
<span class="sd">            R_{ij} = r_j - r_i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        io : int or array_like</span>
<span class="sd">           orbital index of first orbital</span>
<span class="sd">        jo : int or array_like</span>
<span class="sd">           orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">io</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">jo</span><span class="p">))</span></div>

<div class="viewcode-block" id="Geometry.read"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.read">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reads geometry from the `Sile` using `Sile.read_geometry`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sile : `Sile` or str</span>
<span class="sd">            a `Sile` object which will be used to read the geometry</span>
<span class="sd">            if it is a string it will create a new sile using `get_sile`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        write : writes a `Geometry` to a given `Sile`/file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This only works because, they *must*</span>
        <span class="c1"># have been imported previously</span>
        <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="k">import</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">BaseSile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sile</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">sile</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fh</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.write"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sile</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes geometry to the `Sile` using `sile.write_geometry`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sile : Sile or str</span>
<span class="sd">            a `Sile` object which will be used to write the geometry</span>
<span class="sd">            if it is a string it will create a new sile using `get_sile`</span>
<span class="sd">        *args, **kwargs:</span>
<span class="sd">            Any other args will be passed directly to the</span>
<span class="sd">            underlying routine</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read : reads a `Geometry` from a given `Sile`/file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This only works because, they *must*</span>
        <span class="c1"># have been imported previously</span>
        <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="k">import</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">BaseSile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
            <span class="n">sile</span><span class="o">.</span><span class="n">write_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">write_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Representation of the object &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;{{na: </span><span class="si">{0}</span><span class="s1">, no: </span><span class="si">{1}</span><span class="s1">,</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1"> nsc: [</span><span class="si">{1}</span><span class="s1">, </span><span class="si">{2}</span><span class="s1">, </span><span class="si">{3}</span><span class="s1">], maxR: </span><span class="si">{0}</span><span class="se">\n</span><span class="s1">}}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">(),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">))</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<div class="viewcode-block" id="Geometry.iter"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.iter">[docs]</a>    <span class="k">def</span> <span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; An iterator over all atomic indices</span>

<span class="sd">        This iterator is the same as:</span>

<span class="sd">        &gt;&gt;&gt; for ia in range(len(self)): # doctest: +SKIP</span>
<span class="sd">        ...    &lt;do something&gt;</span>

<span class="sd">        or equivalently</span>

<span class="sd">        &gt;&gt;&gt; for ia in self: # doctest: +SKIP</span>
<span class="sd">        ...    &lt;do something&gt;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter_species : iterate across indices and atomic species</span>
<span class="sd">        iter_orbitals : iterate across atomic indices and orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">ia</span></div>

    <span class="fm">__iter__</span> <span class="o">=</span> <span class="nb">iter</span>

<div class="viewcode-block" id="Geometry.iter_species"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.iter_species">[docs]</a>    <span class="k">def</span> <span class="nf">iter_species</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterator over all atoms (or a subset) and species as a tuple in this geometry</span>

<span class="sd">        &gt;&gt;&gt; for ia, a, idx_specie in self.iter_species(): # doctest: +SKIP</span>
<span class="sd">        ...     isinstance(ia, int) == True</span>
<span class="sd">        ...     isinstance(a, Atom) == True</span>
<span class="sd">        ...     isinstance(idx_specie, int) == True</span>

<span class="sd">        with ``ia`` being the atomic index, ``a`` the `Atom` object, ``idx_specie``</span>
<span class="sd">        is the index of the specie</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like, optional</span>
<span class="sd">           only loop on the given atoms, default to all atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter : iterate over atomic indices</span>
<span class="sd">        iter_orbitals : iterate across atomic indices and orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span></div>

<div class="viewcode-block" id="Geometry.iter_orbitals"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.iter_orbitals">[docs]</a>    <span class="k">def</span> <span class="nf">iter_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">local</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all atoms and their associated orbitals</span>

<span class="sd">        &gt;&gt;&gt; for ia, io in self.iter_orbitals(): # doctest: +SKIP</span>

<span class="sd">        with ``ia`` being the atomic index, ``io`` the associated orbital index on atom ``ia``.</span>
<span class="sd">        Note that ``io`` will start from ``0``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like, optional</span>
<span class="sd">           only loop on the given atoms, default to all atoms</span>
<span class="sd">        local : bool, optional</span>
<span class="sd">           whether the orbital index is the global index, or the local index relative to</span>
<span class="sd">           the atom it resides on.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter : iterate over atomic indices</span>
<span class="sd">        iter_species : iterate across indices and atomic species</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">IO</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">IO</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">IO</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IO</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io1</span><span class="p">,</span> <span class="n">io2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atom</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">io2</span> <span class="o">-</span> <span class="n">io1</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io1</span><span class="p">,</span> <span class="n">io2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atom</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">io1</span><span class="p">,</span> <span class="n">io2</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span></div>

<div class="viewcode-block" id="Geometry.iR"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.iR">[docs]</a>    <span class="k">def</span> <span class="nf">iR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">iR</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return an integer number of maximum radii (``self.maxR()``) which holds approximately `na` atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        na : int, optional</span>
<span class="sd">           number of atoms within the radius</span>
<span class="sd">        iR : int, optional</span>
<span class="sd">           initial `iR` value, which the sphere is estitametd from</span>
<span class="sd">        R : float, optional</span>
<span class="sd">           the value used for atomic range (defaults to ``self.maxR()``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># default block iterator</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to determine a number of atoms within a sphere with negative radius, is maxR() defined?&quot;</span><span class="p">)</span>

        <span class="c1"># Number of atoms within 20 * R</span>
        <span class="n">naiR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span> <span class="o">*</span> <span class="n">iR</span><span class="p">)))</span>

        <span class="c1"># Convert to na atoms spherical radii</span>
        <span class="n">iR</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">R</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="n">naiR</span> <span class="o">*</span> <span class="n">na</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">iR</span></div>

<div class="viewcode-block" id="Geometry.iter_block_rand"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.iter_block_rand">[docs]</a>    <span class="k">def</span> <span class="nf">iter_block_rand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iR</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform the *random* block-iteration by randomly selecting the next center of block &quot;&quot;&quot;</span>

        <span class="c1"># We implement yields as we can then do nested iterators</span>
        <span class="c1"># create a boolean array</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Reverse the values</span>
            <span class="n">not_passed</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_passed</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Figure out how many we need to loop on</span>
        <span class="n">not_passed_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="c1"># The boundaries (ensure complete overlap)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">iR</span> <span class="o">-</span> <span class="mf">0.975</span><span class="p">,</span> <span class="n">iR</span> <span class="o">+</span> <span class="o">.</span><span class="mi">025</span><span class="p">])</span> <span class="o">*</span> <span class="n">R</span>

        <span class="n">append</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span>

        <span class="c1"># loop until all passed are true</span>
        <span class="k">while</span> <span class="n">not_passed_N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># Take a random non-passed element</span>
            <span class="n">all_true</span> <span class="o">=</span> <span class="n">not_passed</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Shuffle should increase the chance of hitting a</span>
            <span class="c1"># completely &quot;fresh&quot; segment, thus we take the most</span>
            <span class="c1"># atoms at any single time.</span>
            <span class="c1"># Shuffling will cut down needed iterations.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">all_true</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">all_true</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">all_true</span>

            <span class="c1"># Now we have found a new index, from which</span>
            <span class="c1"># we want to create the index based stuff on</span>

            <span class="c1"># get all elements within two radii</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>

            <span class="c1"># Get unit-cell atoms</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uniq</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># First extend the search-space (before reducing)</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">uniq</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Only select those who have not been runned yet</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Internal error, please report to the developers&#39;</span><span class="p">)</span>

            <span class="c1"># Tell the next loop to skip those passed</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Update looped variables</span>
            <span class="n">not_passed_N</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Now we want to yield the stuff revealed</span>
            <span class="c1"># all_idx[0] contains the elements that should be looped</span>
            <span class="c1"># all_idx[1] contains the indices that can be searched</span>
            <span class="k">yield</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">not_passed</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error on iterations. Not all atoms has been visited.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.iter_block_shape"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.iter_block_shape">[docs]</a>    <span class="k">def</span> <span class="nf">iter_block_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iR</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform the *grid* block-iteration by looping a grid &quot;&quot;&quot;</span>

        <span class="c1"># We implement yields as we can then do nested iterators</span>
        <span class="c1"># create a boolean array</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Reverse the values</span>
            <span class="n">not_passed</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_passed</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Figure out how many we need to loop on</span>
        <span class="n">not_passed_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we default to the Cube shapes</span>
            <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cube</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">-</span> <span class="mf">1.975</span><span class="p">)),</span>
                  <span class="n">Cube</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">+</span> <span class="mf">0.025</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dS</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">+=</span> <span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of Shapes *must* be one or two&#39;</span><span class="p">)</span>

        <span class="c1"># Now create the Grid</span>
        <span class="c1"># convert the radius to a square Grid</span>
        <span class="c1"># We do this by examining the x, y, z coordinates</span>
        <span class="n">xyz_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xyz_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dxyz</span> <span class="o">=</span> <span class="n">xyz_M</span> <span class="o">-</span> <span class="n">xyz_m</span>

        <span class="c1"># Retrieve the internal diameter</span>
        <span class="n">ir</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">displacement</span>

        <span class="c1"># Figure out number of segments in each iteration</span>
        <span class="c1"># (minimum 1)</span>
        <span class="n">ixyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dxyz</span> <span class="o">/</span> <span class="n">ir</span> <span class="o">+</span> <span class="mf">0.0001</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Calculate the steps required for each iteration</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">ixyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Correct the initial position to offset the initial displacement</span>
            <span class="c1"># so that we are at the border.</span>
            <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ir</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">xyz_M</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># This is the case where one of the cell dimensions</span>
                <span class="c1"># is far too great.</span>
                <span class="c1"># In this case ixyz[i] should be 1</span>
                <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyz_M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Shorthand function</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span>
        <span class="n">append</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span>

        <span class="c1"># Now we loop in each direction</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                               <span class="nb">range</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                               <span class="nb">range</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>

            <span class="c1"># Create the new center</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">xyz_m</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">dxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">*</span> <span class="n">dxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span> <span class="o">*</span> <span class="n">dxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="c1"># Correct in case the iteration steps across the maximum</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">center</span> <span class="o">&lt;</span> <span class="n">xyz_M</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">xyz_M</span><span class="p">)</span>
            <span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_center</span><span class="p">(</span><span class="n">center</span><span class="p">[:])</span>
            <span class="n">dS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_center</span><span class="p">(</span><span class="n">center</span><span class="p">[:])</span>

            <span class="c1"># Now perform the iteration</span>
            <span class="c1"># get all elements within two radii</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span>

            <span class="c1"># Get unit-cell atoms</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uniq</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># First extend the search-space (before reducing)</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">uniq</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Only select those who have not been runned yet</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Tell the next loop to skip those passed</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Update looped variables</span>
            <span class="n">not_passed_N</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Now we want to yield the stuff revealed</span>
            <span class="c1"># all_idx[0] contains the elements that should be looped</span>
            <span class="c1"># all_idx[1] contains the indices that can be searched</span>
            <span class="k">yield</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">not_passed</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">not_passed</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error on iterations. Not all atoms has been visited.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.iter_block"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.iter_block">[docs]</a>    <span class="k">def</span> <span class="nf">iter_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iR</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rand&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterator for performance critical loops</span>

<span class="sd">        NOTE: This requires that `R` has been set correctly as the maximum interaction range.</span>

<span class="sd">        I.e. the loop would look like this:</span>

<span class="sd">        &gt;&gt;&gt; for ias, idxs in self.iter_block(): # doctest: +SKIP</span>
<span class="sd">        ...    for ia in ias:</span>
<span class="sd">        ...        idx_a = self.close(ia, R = R, idx = idxs)</span>

<span class="sd">        This iterator is intended for systems with more than 1000 atoms.</span>

<span class="sd">        Remark that the iterator used is non-deterministic, i.e. any two iterators need</span>
<span class="sd">        not return the same atoms in any way.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iR  : int, optional</span>
<span class="sd">            the number of `R` ranges taken into account when doing the iterator</span>
<span class="sd">        R  : float, optional</span>
<span class="sd">            enables overwriting the local R quantity. Defaults to ``self.maxR()``</span>
<span class="sd">        atom : array_like, optional</span>
<span class="sd">            enables only effectively looping a subset of the full geometry</span>
<span class="sd">        method : {&#39;rand&#39;, &#39;sphere&#39;, &#39;cube&#39;}</span>
<span class="sd">            select the method by which the block iteration is performed.</span>
<span class="sd">            Possible values are:</span>

<span class="sd">             `rand`: a spherical object is constructed with a random center according to the internal atoms</span>
<span class="sd">             `sphere`: a spherical equispaced shape is constructed and looped</span>
<span class="sd">             `cube`: a cube shape is constructed and looped</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Two lists with ``[0]`` being a list of atoms to be looped and ``[1]`` being the atoms that</span>
<span class="sd">        need searched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;rand&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block_rand</span><span class="p">(</span><span class="n">iR</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>

            <span class="c1"># Create shapes</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sphere&#39;</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sphere</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">-</span> <span class="mf">0.975</span><span class="p">)),</span>
                      <span class="n">Sphere</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">+</span> <span class="mf">0.025</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cube&#39;</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cube</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iR</span> <span class="o">-</span> <span class="mf">0.975</span><span class="p">)),</span>
                      <span class="n">Cube</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iR</span> <span class="o">+</span> <span class="mf">0.025</span><span class="p">)))</span>

            <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block_shape</span><span class="p">(</span><span class="n">dS</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span></div>

<div class="viewcode-block" id="Geometry.copy"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A copy of the object. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">),</span>
                              <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="Geometry.optimize_nsc"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.optimize_nsc">[docs]</a>    <span class="k">def</span> <span class="nf">optimize_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Optimize the number of supercell connections based on ``self.maxR()``</span>

<span class="sd">        After this routine the number of supercells may not necessarily be the same.</span>

<span class="sd">        This is an in-place operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int or array_like, optional</span>
<span class="sd">           only optimize the specified axis (default to all)</span>
<span class="sd">        R : float, optional</span>
<span class="sd">           the maximum connection radius for each atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span>
                              <span class="s2">&quot;.optimize_nsc could not determine the radius from the &quot;</span>
                              <span class="s2">&quot;internal atoms. Provide a radius as an argument.&quot;</span><span class="p">))</span>

        <span class="c1"># Now we need to find the number of supercells</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>
        <span class="c1"># Reset the number of supercells of the wanted optimized</span>
        <span class="c1"># directions to 1</span>
        <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
            <span class="c1"># Initialize the isc for this direction</span>
            <span class="c1"># (note we do not take non-orthogonal directions</span>
            <span class="c1">#  into account)</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1"># Initialize the actual number of supercell connections</span>
            <span class="c1"># along this direction.</span>
            <span class="n">prev_isc</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">prev_isc</span> <span class="o">==</span> <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># Try next supercell connection</span>
                <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">prev_isc</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">break</span>

            <span class="c1"># Save the reached supercell connection</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_isc</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nsc</span></div>

<div class="viewcode-block" id="Geometry.sub"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.sub">[docs]</a>    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a new `Geometry` with a subset of this `Geometry`</span>

<span class="sd">        Indices passed *MUST* be unique.</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom  : array_like</span>
<span class="sd">            indices of all atoms to be removed.</span>
<span class="sd">        cell   : array_like or SuperCell, optional</span>
<span class="sd">            the new associated cell of the geometry (defaults to the same cell)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SuperCell.fit : update the supercell according to a reference supercell</span>
<span class="sd">        remove : the negative of this routine, i.e. remove a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atms</span><span class="p">,</span> <span class="p">:],</span>
                                  <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atms</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atms</span><span class="p">,</span> <span class="p">:],</span>
                              <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atms</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">cell</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.cut"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">seg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a subset of atoms from the geometry by cutting the</span>
<span class="sd">        geometry into ``seps`` parts along the direction ``axis``.</span>
<span class="sd">        It will then _only_ return the first cut.</span>

<span class="sd">        This will effectively change the unit-cell in the ``axis`` as-well</span>
<span class="sd">        as removing ``self.na/seps`` atoms.</span>
<span class="sd">        It requires that ``self.na % seps == 0``.</span>

<span class="sd">        REMARK: You need to ensure that all atoms within the first</span>
<span class="sd">        cut out region are within the primary unit-cell.</span>

<span class="sd">        Doing ``geom.cut(2, 1).tile(2, 1)``, could for symmetric setups,</span>
<span class="sd">        be equivalent to a no-op operation. A ``UserWarning`` will be issued</span>
<span class="sd">        if this is not the case.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seps  : int</span>
<span class="sd">            number of times the structure will be cut.</span>
<span class="sd">        axis  : int</span>
<span class="sd">            the axis that will be cut</span>
<span class="sd">        seg : int, optional</span>
<span class="sd">            returns the i&#39;th segment of the cut structure</span>
<span class="sd">            Currently the atomic coordinates are not translated,</span>
<span class="sd">            this may change in the future.</span>
<span class="sd">        rtol : (tolerance for checking tiling, see `numpy.allclose`)</span>
<span class="sd">        atol : (tolerance for checking tiling, see `numpy.allclose`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">%</span> <span class="n">seps</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The system cannot be cut into </span><span class="si">{0}</span><span class="s1"> different &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seps</span><span class="p">)</span> <span class="o">+</span>
                <span class="s1">&#39;pieces. Please check your geometry and input.&#39;</span><span class="p">)</span>
        <span class="c1"># Truncate to the correct segments</span>
        <span class="n">lseg</span> <span class="o">=</span> <span class="n">seg</span> <span class="o">%</span> <span class="n">seps</span>
        <span class="c1"># Cut down cell</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="c1"># List of atoms</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">//</span> <span class="n">seps</span>
        <span class="n">off</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">lseg</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="n">off</span> <span class="o">+</span> <span class="n">n</span><span class="p">),</span> <span class="n">cell</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span>
                           <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="s1">&#39;The cut structure cannot be re-created by tiling&#39;</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">The difference between the coordinates can be altered using rtol, atol&#39;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="Geometry.remove"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove atoms from the geometry.</span>

<span class="sd">        Indices passed *MUST* be unique.</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom  : array_like</span>
<span class="sd">            indices of all atoms to be removed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sub : the negative of this routine, i.e. retain a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">),</span> <span class="n">atom</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.tile"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Tile the geometry to create a bigger one</span>

<span class="sd">        The atomic indices are retained for the base structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps  : int</span>
<span class="sd">           number of tiles (repetitions)</span>
<span class="sd">        axis  : int</span>
<span class="sd">           direction of tiling, 0, 1, 2 according to the cell-direction</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], sc=1.)</span>
<span class="sd">        &gt;&gt;&gt; g = geom.tile(2,axis=0)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz)</span>
<span class="sd">        [[ 0.   0.   0. ]</span>
<span class="sd">         [ 0.5  0.   0. ]</span>
<span class="sd">         [ 1.   0.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]]</span>
<span class="sd">        &gt;&gt;&gt; g = geom.tile(2,0).tile(2,axis=1)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz)</span>
<span class="sd">        [[ 0.   0.   0. ]</span>
<span class="sd">         [ 0.5  0.   0. ]</span>
<span class="sd">         [ 1.   0.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]</span>
<span class="sd">         [ 0.   1.   0. ]</span>
<span class="sd">         [ 0.5  1.   0. ]</span>
<span class="sd">         [ 1.   1.   0. ]</span>
<span class="sd">         [ 1.5  1.   0. ]]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        repeat : equivalent but different ordering of final structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reps</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.tile() requires a repetition above 0&#39;</span><span class="p">)</span>

        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="c1"># Our first repetition *must* be with</span>
        <span class="c1"># the former coordinate</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># We may use broadcasting rules instead of repeating stuff</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="n">nr</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Correct the unit-cell offsets along `i`</span>
            <span class="n">xyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Create the geometry and return it (note the smaller atoms array</span>
        <span class="c1"># will also expand via tiling)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.repeat"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a repeated geometry</span>

<span class="sd">        The atomic indices are *NOT* retained for the base structure.</span>

<span class="sd">        The expansion of the atoms are basically performed using this</span>
<span class="sd">        algorithm:</span>

<span class="sd">        &gt;&gt;&gt; ja = 0 # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; for ia in range(self.na):</span>
<span class="sd">        ...     for id,r in args:</span>
<span class="sd">        ...        for i in range(r):</span>
<span class="sd">        ...           ja = ia + cell[id,:] * i</span>

<span class="sd">        This method allows to utilise Bloch&#39;s theorem when creating</span>
<span class="sd">        Hamiltonian parameter sets for TBtrans.</span>

<span class="sd">        For geometries with a single atom this routine returns the same as</span>
<span class="sd">        `tile`.</span>

<span class="sd">        It is adviced to only use this for electrode Bloch&#39;s theorem</span>
<span class="sd">        purposes as `tile` is faster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps  : int</span>
<span class="sd">           number of repetitions</span>
<span class="sd">        axis  : int</span>
<span class="sd">           direction of repetition, 0, 1, 2 according to the cell-direction</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], sc=1)</span>
<span class="sd">        &gt;&gt;&gt; g = geom.repeat(2,axis=0)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz)</span>
<span class="sd">        [[ 0.   0.   0. ]</span>
<span class="sd">         [ 1.   0.   0. ]</span>
<span class="sd">         [ 0.5  0.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]]</span>
<span class="sd">        &gt;&gt;&gt; g = geom.repeat(2,0).repeat(2,1)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz)</span>
<span class="sd">        [[ 0.   0.   0. ]</span>
<span class="sd">         [ 0.   1.   0. ]</span>
<span class="sd">         [ 1.   0.   0. ]</span>
<span class="sd">         [ 1.   1.   0. ]</span>
<span class="sd">         [ 0.5  0.   0. ]</span>
<span class="sd">         [ 0.5  1.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]</span>
<span class="sd">         [ 1.5  1.   0. ]]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tile : equivalent but different ordering of final structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reps</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.repeat() requires a repetition above 0&#39;</span><span class="p">)</span>

        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="c1"># Our first repetition *must* be with</span>
        <span class="c1"># the former coordinate</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># We may use broadcasting rules instead of repeating stuff</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="n">nr</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Correct the unit-cell offsets along `i`</span>
            <span class="n">xyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Create the geometry and return it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Implement easy repeat function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : int or tuple or list or (tuple, str) or (list, str)</span>
<span class="sd">           a tuple/list may be of length 2 or 3. A length of 2 corresponds</span>
<span class="sd">           to tuple[0] == *number of multiplications*, tuple[1] is the</span>
<span class="sd">           axis.</span>
<span class="sd">           A length of 3 corresponds to each of the directions.</span>
<span class="sd">           An optional string may be used to specify the `tile` or `repeat` function.</span>
<span class="sd">           The default is the `tile` function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geometry = Geometry([0.] * 3, sc=[1.5, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; geometry * 2 == geometry.tile(2, 0).tile(2, 1).tile(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * [2, 1, 2] == geometry.tile(2, 0).tile(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * [2, 2] == geometry.tile(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 1, 2], &#39;repeat&#39;) == geometry.repeat(2, 0).repeat(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 1, 2], &#39;r&#39;) == geometry.repeat(2, 0).repeat(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 0], &#39;r&#39;) == geometry.repeat(2, 0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 2], &#39;r&#39;) == geometry.repeat(2, 2)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tile : specific method to enlarge the geometry</span>
<span class="sd">        repeat : specific method to enlarge the geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Reverse arguments in case it is on the LHS</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="bp">self</span>

        <span class="c1"># Simple form</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>

        <span class="c1"># Error in argument, fall-back</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Look-up table</span>
        <span class="n">method_tbl</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;repeat&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;repeat&#39;</span><span class="p">:</span> <span class="s1">&#39;repeat&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="s1">&#39;tile&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;tile&#39;</span><span class="p">:</span> <span class="s1">&#39;tile&#39;</span><span class="p">}</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;tile&#39;</span>

        <span class="c1"># Determine the type</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># either</span>
            <span class="c1">#  (r, axis)</span>
            <span class="c1">#  ((...), method</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_str</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">method_tbl</span><span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#  r</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1">#  (r, axis)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1">#  (r, r, r)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Multiplying a geometry has received a wrong argument&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">g</span>

    <span class="fm">__rmul__</span> <span class="o">=</span> <span class="fm">__mul__</span>

<div class="viewcode-block" id="Geometry.angle"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.angle">[docs]</a>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The angle between atom `atom` and the direction `dir`, with possibility of a reference coordinate `ref`</span>

<span class="sd">        The calculated angle can be written as this</span>

<span class="sd">        .. math::</span>
<span class="sd">            \alpha = \arccos \frac{(\mathrm{atom} - \mathrm{ref})\cdot \mathrm{dir}}</span>
<span class="sd">            {|\mathrm{atom}-\mathrm{ref}||\mathrm{dir}|}</span>

<span class="sd">        and thus lies in the interval :math:`[0 ; \pi]` as one cannot distinguish orientation without</span>
<span class="sd">        additional vectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like</span>
<span class="sd">           atomic index</span>
<span class="sd">        dir : str, int or vector</span>
<span class="sd">           the direction from which the angle is calculated from, default to ``x``</span>
<span class="sd">        ref : int or coordinate, optional</span>
<span class="sd">           the reference point from which the vectors are drawn, default to origo</span>
<span class="sd">        rad : bool, optional</span>
<span class="sd">           whether the returned value is in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ensure_array</span><span class="p">(</span><span class="n">atom</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="p">(</span><span class="n">_str</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">direction</span><span class="p">(</span><span class="nb">dir</span><span class="p">),</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># Normalize so we don&#39;t have to have this in the</span>
        <span class="c1"># below formula</span>
        <span class="nb">dir</span> <span class="o">/=</span> <span class="p">(</span><span class="nb">dir</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
        <span class="c1"># Broad-casting</span>
        <span class="nb">dir</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">xi</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ref</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">-=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nx</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">xi</span> <span class="o">*</span> <span class="nb">dir</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span><span class="p">),</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rad</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ang</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.rotatea"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.rotatea">[docs]</a>    <span class="k">def</span> <span class="nf">rotatea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="s1">&#39;abc+xyz&#39;</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Rotate around first lattice vector</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        rotate : generic function of this, this routine calls `rotate` with `v = self.cell[0, :]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">origo</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">only</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.rotateb"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.rotateb">[docs]</a>    <span class="k">def</span> <span class="nf">rotateb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="s1">&#39;abc+xyz&#39;</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Rotate around second lattice vector</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        rotate : generic function of this, this routine calls `rotate` with `v = self.cell[1, :]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">origo</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">only</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.rotatec"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.rotatec">[docs]</a>    <span class="k">def</span> <span class="nf">rotatec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="s1">&#39;abc+xyz&#39;</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Rotate around third lattice vector</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        rotate : generic function of this, this routine calls `rotate` with `v = self.cell[2, :]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">origo</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">only</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.rotate"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">origo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="s1">&#39;abc+xyz&#39;</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Rotate geometry around vector and return a new geometry</span>

<span class="sd">        Per default will the entire geometry be rotated, such that everything</span>
<span class="sd">        is aligned as before rotation.</span>

<span class="sd">        However, by supplying ``only = &#39;abc|xyz&#39;`` one can designate which</span>
<span class="sd">        part of the geometry that will be rotated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float</span>
<span class="sd">             the angle in radians of which the geometry should be rotated</span>
<span class="sd">        v     : array_like</span>
<span class="sd">             the normal vector to the rotated plane, i.e.</span>
<span class="sd">             v = [1,0,0] will rotate the ``yz`` plane</span>
<span class="sd">        origo : int or array_like, optional</span>
<span class="sd">             the origin of rotation. Anything but [0, 0, 0] is equivalent</span>
<span class="sd">             to a `self.move(-origo).rotate(...).move(origo)`.</span>
<span class="sd">             If this is an `int` it corresponds to the atomic index.</span>
<span class="sd">        atom : int or array_like, optional</span>
<span class="sd">             only rotate the given atomic indices, if not specified, all</span>
<span class="sd">             atoms will be rotated.</span>
<span class="sd">        only  : {&#39;abc+xyz&#39;, &#39;xyz&#39;, &#39;abc&#39;}</span>
<span class="sd">             which coordinate subject should be rotated,</span>
<span class="sd">             if ``abc`` is in this string the cell will be rotated</span>
<span class="sd">             if ``xyz`` is in this string the coordinates will be rotated</span>
<span class="sd">        rad : bool, optional</span>
<span class="sd">             if ``True`` the angle is provided in radians (rather than degrees)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Quaternion : class to rotate</span>
<span class="sd">        rotatea : generic function for rotating around first lattice vector</span>
<span class="sd">        rotateb : generic function for rotating around second lattice vector</span>
<span class="sd">        rotatec : generic function for rotating around third lattice vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">origo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origo</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origo</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">origo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">origo</span><span class="p">)</span>
        <span class="n">origo</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">origo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Only rotate the unique values</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">uniq</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Ensure the normal vector is normalized...</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">vn</span> <span class="o">/=</span> <span class="p">(</span><span class="n">vn</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>

        <span class="c1"># Prepare quaternion...</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="n">rad</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">/=</span> <span class="n">q</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>

        <span class="c1"># Rotate by direct call</span>
        <span class="k">if</span> <span class="s1">&#39;abc&#39;</span> <span class="ow">in</span> <span class="n">only</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="n">rad</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="n">only</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Copy</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">only</span><span class="p">:</span>
            <span class="c1"># subtract and add origo, before and after rotation</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">origo</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span> <span class="o">+</span> <span class="n">origo</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.rotate_miller"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.rotate_miller">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_miller</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Align Miller direction along ``v``</span>

<span class="sd">        Rotate geometry and cell such that the Miller direction</span>
<span class="sd">        points along the Cartesian vector ``v``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create normal vector to miller direction and cartesian</span>
        <span class="c1"># direction</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">cp</span> <span class="o">/=</span> <span class="p">(</span><span class="n">cp</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>

        <span class="n">lm</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">lm</span> <span class="o">/=</span> <span class="p">(</span><span class="n">lm</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
        <span class="n">lv</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">lv</span> <span class="o">/=</span> <span class="p">(</span><span class="n">lv</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>

        <span class="c1"># Now rotate the angle between them</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lm</span> <span class="o">*</span> <span class="n">lv</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.move"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Translates the geometry by `v`</span>

<span class="sd">        One can translate a subset of the atoms by supplying `atom`.</span>

<span class="sd">        Returns a copy of the structure translated by `v`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v     : array_like</span>
<span class="sd">             the vector to displace all atomic coordinates</span>
<span class="sd">        atom : int or array_like, optional</span>
<span class="sd">             only displace the given atomic indices, if not specified, all</span>
<span class="sd">             atoms will be displaced</span>
<span class="sd">        cell  : bool, optional</span>
<span class="sd">             If True the supercell also gets enlarged by the vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ensure_array</span><span class="p">(</span><span class="n">atom</span><span class="p">),</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">cell</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">g</span></div>
    <span class="n">translate</span> <span class="o">=</span> <span class="n">move</span>

<div class="viewcode-block" id="Geometry.swap"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.swap">[docs]</a>    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Swap a set of atoms in the geometry and return a new one</span>

<span class="sd">        This can be used to reorder elements of a geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : array_like</span>
<span class="sd">             the first list of atomic coordinates</span>
<span class="sd">        b : array_like</span>
<span class="sd">             the second list of atomic coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">xyz</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">xyz</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="Geometry.swapaxes"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.swapaxes">[docs]</a>    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="s1">&#39;cell+xyz&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Swap the axis for the atomic coordinates and the cell vectors</span>

<span class="sd">        If ``swapaxes(0,1)`` it returns the 0 and 1 values</span>
<span class="sd">        swapped in the ``cell`` variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : int</span>
<span class="sd">           axes 1, swaps with `b`</span>
<span class="sd">        b : int</span>
<span class="sd">           axes 2, swaps with `a`</span>
<span class="sd">        swap : {&#39;cell+xyz&#39;, &#39;cell&#39;, &#39;xyz&#39;}</span>
<span class="sd">           decide what to swap, if `&#39;cell&#39;` is in `swap` then</span>
<span class="sd">           the cell axis are swapped.</span>
<span class="sd">           if `&#39;xyz&#39;` is in `swap` then</span>
<span class="sd">           the xyz (Cartesian) axis are swapped.</span>
<span class="sd">           Both may be in `swap`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">swap</span><span class="p">:</span>
            <span class="n">xyz</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">b</span><span class="p">]</span>
            <span class="n">xyz</span><span class="p">[:,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">in</span> <span class="n">swap</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.center"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.center">[docs]</a>    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the center of the geometry</span>

<span class="sd">        By specifying `what` one can control whether it should be:</span>

<span class="sd">        * ``xyz|position``: Center of coordinates (default)</span>
<span class="sd">        * ``mass``: Center of mass</span>
<span class="sd">        * ``cell``: Center of cell</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like</span>
<span class="sd">            list of atomic indices to find center of</span>
<span class="sd">        what : {&#39;xyz&#39;, &#39;mass&#39;, &#39;cell&#39;}</span>
<span class="sd">            determine whether center should be of &#39;cell&#39;, mass-centered (&#39;mass&#39;),</span>
<span class="sd">            or absolute center of the positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">in</span> <span class="n">what</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">ensure_array</span><span class="p">(</span><span class="n">atom</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;mass&#39;</span> <span class="ow">in</span> <span class="n">what</span><span class="p">:</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mass</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">what</span> <span class="ow">or</span> <span class="s1">&#39;position&#39;</span> <span class="ow">in</span> <span class="n">what</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Unknown what, not one of [xyz,position,mass,cell]&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.append"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Appends structure along `axis`. This will automatically</span>
<span class="sd">        add the ``self.cell[axis,:]`` to all atomic coordiates in the</span>
<span class="sd">        `other` structure before appending.</span>

<span class="sd">        The basic algorithm is this:</span>

<span class="sd">        &gt;&gt;&gt; oxa = other.xyz + self.cell[axis,:][None,:] # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; self.xyz = np.append(self.xyz,oxa)</span>
<span class="sd">        &gt;&gt;&gt; self.cell[axis,:] += other.cell[axis,:]</span>

<span class="sd">        NOTE: The cell appended is only in the axis that</span>
<span class="sd">        is appended, which means that the other cell directions</span>
<span class="sd">        need not conform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry or SuperCell</span>
<span class="sd">            Other geometry class which needs to be appended</span>
<span class="sd">            If a `SuperCell` only the super cell will be extended</span>
<span class="sd">        axis  : int</span>
<span class="sd">            Cell direction to which the `other` geometry should be</span>
<span class="sd">            appended.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        attach : attach a geometry</span>
<span class="sd">        insert : insert a geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="c1"># Only extend the supercell.</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.prepend"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.prepend">[docs]</a>    <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepends structure along `axis`. This will automatically</span>
<span class="sd">        add the ``self.cell[axis,:]`` to all atomic coordiates in the</span>
<span class="sd">        `other` structure before prepending.</span>

<span class="sd">        The basic algorithm is this:</span>

<span class="sd">        &gt;&gt;&gt; oxa = other.xyz # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; self.xyz = np.append(oxa, self.xyz + other.cell[axis,:][None,:])</span>
<span class="sd">        &gt;&gt;&gt; self.cell[axis,:] += other.cell[axis,:]</span>

<span class="sd">        NOTE: The cell prepended is only in the axis that</span>
<span class="sd">        is prependend, which means that the other cell directions</span>
<span class="sd">        need not conform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry or SuperCell</span>
<span class="sd">            Other geometry class which needs to be prepended</span>
<span class="sd">            If a `SuperCell` only the super cell will be extended</span>
<span class="sd">        axis  : int</span>
<span class="sd">            Cell direction to which the `other` geometry should be</span>
<span class="sd">            prepended</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        attach : attach a geometry</span>
<span class="sd">        insert : insert a geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="c1"># Only extend the supercell.</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.add"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Merge two geometries (or a Geometry and SuperCell) by adding the two atoms together</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry or SuperCell</span>
<span class="sd">            Other geometry class which is added</span>
<span class="sd">        only_atoms : bool, optional</span>
<span class="sd">            If ``True`` only the atoms are added, else both the atoms and lattice vectors are added</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        attach : attach a geometry</span>
<span class="sd">        insert : insert a geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span> <span class="o">+</span> <span class="n">other</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.insert"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">geom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Inserts other atoms right before index</span>

<span class="sd">        We insert the `geom` `Geometry` before `atom`.</span>
<span class="sd">        Note that this will not change the unit cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int</span>
<span class="sd">           the index at which atom the other geometry is inserted</span>
<span class="sd">        geom : Geometry</span>
<span class="sd">           the other geometry to be inserted</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        attach : attach a geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Merge two geometries (or geometry and supercell)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b : Geometry or SuperCell or tuple or list</span>
<span class="sd">           when adding a Geometry with a Geometry it defaults to using `add` function</span>
<span class="sd">           with the LHS retaining the cell-vectors.</span>
<span class="sd">           a tuple/list may be of length 2 with the first element being a Geometry and the second</span>
<span class="sd">           being an integer specifying the lattice vector where it is appended.</span>
<span class="sd">           One may also use a `SuperCell` instead of a `Geometry` which behaves similarly.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; A + B == A.add(B) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 1) == A.append(B, 1)</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 2) == A.append(B, 2)</span>
<span class="sd">        &gt;&gt;&gt; (A, 1) + B == A.prepend(B, 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">SuperCell</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Arguments for adding (add/append/prepend) are incorrect&#39;</span><span class="p">)</span>

    <span class="fm">__radd__</span> <span class="o">=</span> <span class="fm">__add__</span>

<div class="viewcode-block" id="Geometry.attach"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.attach">[docs]</a>    <span class="k">def</span> <span class="nf">attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_idx</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">o_idx</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Attaches another `Geometry` at the `s_idx` index with respect to `o_idx` using different methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s_idx : int</span>
<span class="sd">           atomic index which is the base position of the attachment. The distance</span>
<span class="sd">           between `s_idx` and `o_idx` are `dist`.</span>
<span class="sd">        other : Geometry</span>
<span class="sd">           the other Geometry to attach at the given point. In this case `dist` from</span>
<span class="sd">           `s_idx`.</span>
<span class="sd">        o_idx : int</span>
<span class="sd">           the index of the atom in `other` that is inserted at `s_idx`.</span>
<span class="sd">        dist : array_like or float or str, optional</span>
<span class="sd">           the distance (in `Ang`) between the attached coordinates.</span>
<span class="sd">           If `dist` is `arraylike it should be the vector between</span>
<span class="sd">           the atoms;</span>
<span class="sd">           if `dist` is `float` the argument `axis` is required</span>
<span class="sd">           and the vector will be calculated along the corresponding latticevector;</span>
<span class="sd">           else if `dist` is `str` this will correspond to the</span>
<span class="sd">           `method` argument of the ``Atom.radius`` class of the two</span>
<span class="sd">           atoms. Here `axis` is also required.</span>
<span class="sd">        axis : int</span>
<span class="sd">           specify the direction of the lattice vectors used.</span>
<span class="sd">           Not used if `dist` is an array-like argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="c1"># We have a single rational number</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument `axis` has not been specified, please specify the axis when using a distance&quot;</span><span class="p">)</span>

            <span class="c1"># Now calculate the vector that we should have</span>
            <span class="c1"># between the atoms</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">dist</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="c1"># We have a single rational number</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument `axis` has not been specified, please specify the axis when using a distance&quot;</span><span class="p">)</span>

            <span class="c1"># This is the empirical distance between the atoms</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="n">s_idx</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="n">o_idx</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">d</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The user *must* have supplied a vector</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

        <span class="c1"># Now create a copy of the other geometry</span>
        <span class="c1"># so that we move it...</span>
        <span class="c1"># Translate to origo, then back to position in new cell</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">o_idx</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">s_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># We do not know how to handle the lattice-vectors,</span>
        <span class="c1"># so we will do nothing...</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.reverse"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.reverse">[docs]</a>    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a reversed geometry</span>

<span class="sd">        Also enables reversing a subset of the atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like, optional</span>
<span class="sd">             only reverse the given atomic indices, if not specified, all</span>
<span class="sd">             atoms will be reversed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">atom</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="Geometry.mirror"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Mirrors the structure around the center of the atoms &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lplane</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">lplane</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">lplane</span> <span class="o">==</span> <span class="s1">&#39;yz&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">lplane</span> <span class="o">==</span> <span class="s1">&#39;xz&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns geometry coordinates in fractional coordinates &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">lin</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="Geometry.axyz"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.axyz">[docs]</a>    <span class="k">def</span> <span class="nf">axyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the atomic coordinates in the supercell of a given atom.</span>

<span class="sd">        The ``Geometry[...]`` slicing is calling this function with appropriate options.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like</span>
<span class="sd">          atom(s) from which we should return the coordinates, the atomic indices</span>
<span class="sd">          may be in supercell format.</span>
<span class="sd">        isc   : array_like, optional</span>
<span class="sd">            Returns the atomic coordinates shifted according to the integer</span>
<span class="sd">            parts of the cell. Defaults to the unit-cell</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], sc=1.)</span>
<span class="sd">        &gt;&gt;&gt; print(geom.axyz(isc=[1,0,0]))</span>
<span class="sd">        [[ 1.   0.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]]</span>

<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], sc=1.)</span>
<span class="sd">        &gt;&gt;&gt; print(geom.axyz(0))</span>
<span class="sd">        [ 0.  0.  0.]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>

        <span class="c1"># If only atom has been specified</span>
        <span class="k">if</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get offsets from atomic indices (note that this will be per atom)</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atom</span><span class="p">),</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="k">elif</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Neither of atom, or isc are `None`, we add the offset to all coordinates</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="Geometry.scale"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Scale coordinates and unit-cell to get a new geometry with proper scaling</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : float</span>
<span class="sd">           the scale factor for the new geometry (lattice vectors, coordinates</span>
<span class="sd">           and the atomic radii are scaled).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.within_sc"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.within_sc">[docs]</a>    <span class="k">def</span> <span class="nf">within_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indices of atoms in a given supercell within a given shape from a given coordinate</span>

<span class="sd">        This returns a set of atomic indices which are within a</span>
<span class="sd">        sphere of radius ``R``.</span>

<span class="sd">        If R is a tuple/list/array it will return the indices:</span>
<span class="sd">        in the ranges:</span>

<span class="sd">        &gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] ) # doctest: +SKIP</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapes  : Shape or list of Shape</span>
<span class="sd">            A list of increasing shapes that define the extend of the geometric</span>
<span class="sd">            volume that is searched.</span>
<span class="sd">            It is vital that::</span>

<span class="sd">               shapes[0] in shapes[1] in shapes[2] ...</span>
<span class="sd">        isc       : array_like, optional</span>
<span class="sd">            The super-cell which the coordinates are checked in. Defaults to ``[0, 0, 0]``</span>
<span class="sd">        idx       : array_like, optional</span>
<span class="sd">            List of atoms that will be considered. This can</span>
<span class="sd">            be used to only take out a certain atoms.</span>
<span class="sd">        idx_xyz : array_like, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `idx` variable (`idx` must also be passed)</span>
<span class="sd">        ret_xyz : bool, optional</span>
<span class="sd">            If True this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij : bool, optional</span>
<span class="sd">            If True this method will return the distance</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that `shapes` is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapes</span><span class="p">]</span>
        <span class="n">nshapes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>

        <span class="c1"># Convert to actual array</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If idx is None, then idx_xyz cannot be used!</span>
            <span class="c1"># So we force it to None</span>
            <span class="n">idx_xyz</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Get shape centers</span>
        <span class="n">off</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[:]</span>
        <span class="c1"># Get the supercell offset</span>
        <span class="n">soff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)[:]</span>

        <span class="c1"># Get atomic coordinate in principal cell</span>
        <span class="k">if</span> <span class="n">idx_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">soff</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For extremely large systems re-using the</span>
            <span class="c1"># idx_xyz is faster than indexing</span>
            <span class="c1"># a very large array</span>
            <span class="c1"># However, this idx_xyz should not</span>
            <span class="c1"># be offset by any supercell</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">idx_xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">soff</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Get indices and coordinates of the largest shape</span>
        <span class="c1"># The largest part of the calculation are to calculate</span>
        <span class="c1"># the content in the largest shape.</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">iwithin</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
        <span class="c1"># Reduce search space</span>
        <span class="n">xa</span> <span class="o">=</span> <span class="n">xa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This is because of the pre-check of the distance checks</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Quick return if there are no entries...</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">]</span>
            <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">rd</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nshapes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Calculate distance</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">xa</span> <span class="o">-</span> <span class="n">off</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Create the initial lists that we will build up</span>
        <span class="c1"># Then finally, we will return the reversed lists</span>

        <span class="c1"># Quick return</span>
        <span class="k">if</span> <span class="n">nshapes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">idx</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO Check that all shapes coincide with the following shapes</span>

        <span class="c1"># Now we create a list of indices which coincide</span>
        <span class="c1"># in each of the shapes</span>
        <span class="c1"># Do a reduction on each of the list elements</span>
        <span class="n">ixS</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">idx</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">iwithin</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cum</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Update elements to remove in next loop</span>
            <span class="n">cum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cum</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">ixS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Do for the first shape</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ensure_array</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="mi">0</span><span class="p">]])]]</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">rc</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]])</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nshapes</span><span class="p">):</span>
            <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ensure_array</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">rc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Geometry.close_sc"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.close_sc">[docs]</a>    <span class="k">def</span> <span class="nf">close_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_ia</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indices of atoms in a given supercell within a given radius from a given coordinate</span>

<span class="sd">        This returns a set of atomic indices which are within a</span>
<span class="sd">        sphere of radius `R`.</span>

<span class="sd">        If `R` is a tuple/list/array it will return the indices:</span>
<span class="sd">        in the ranges:</span>

<span class="sd">        &gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] ) # doctest: +SKIP</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_ia : array_like of floats or int</span>
<span class="sd">            Either a point in space or an index of an atom.</span>
<span class="sd">            If an index is passed it is the equivalent of passing</span>
<span class="sd">            the atomic coordinate ``close_sc(self.xyz[xyz_ia,:])``.</span>
<span class="sd">        isc : array_like, optional</span>
<span class="sd">            The super-cell which the coordinates are checked in.</span>
<span class="sd">        R : float or array_like, optional</span>
<span class="sd">            The radii parameter to where the atomic connections are found.</span>
<span class="sd">            If `R` is an array it will return the indices:</span>
<span class="sd">            in the ranges ``( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )``.</span>
<span class="sd">            If a single float it will return ``x &lt;= R``.</span>
<span class="sd">        idx : array_like of int, optional</span>
<span class="sd">            List of atoms that will be considered. This can</span>
<span class="sd">            be used to only take out a certain atoms.</span>
<span class="sd">        idx_xyz : array_like of float, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `idx` variable (`idx` must also be passed)</span>
<span class="sd">        ret_xyz : bool, optional</span>
<span class="sd">            If True this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij : bool, optional</span>
<span class="sd">            If True this method will return the distance</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Common numpy used functions (reduces function look-ups)</span>
        <span class="n">log_and</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span>
        <span class="n">fabs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span>

        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Maximum distance queried</span>
        <span class="n">max_R</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Convert to actual array</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If idx is None, then idx_xyz cannot be used!</span>
            <span class="n">idx_xyz</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">):</span>
            <span class="n">off</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">off</span> <span class="o">=</span> <span class="n">xyz_ia</span>

        <span class="c1"># Calculate the complete offset</span>
        <span class="n">foff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)[:]</span> <span class="o">-</span> <span class="n">off</span><span class="p">[:]</span>

        <span class="c1"># Get atomic coordinate in principal cell</span>
        <span class="k">if</span> <span class="n">idx_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">foff</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For extremely large systems re-using the</span>
            <span class="c1"># idx_xyz is faster than indexing</span>
            <span class="c1"># a very large array</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="n">idx_xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">foff</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Immediately downscale by easy checking</span>
        <span class="c1"># This will reduce the computation of the vector-norm</span>
        <span class="c1"># which is the main culprit of the time-consumption</span>
        <span class="c1"># This abstraction will _only_ help very large</span>
        <span class="c1"># systems.</span>
        <span class="c1"># For smaller ones this will actually be a slower</span>
        <span class="c1"># method...</span>
        <span class="k">if</span> <span class="n">dxa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># first</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">dxa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">max_R</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ix</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dxa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># second</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">dxa</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">max_R</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                <span class="n">dxa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># third</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">dxa</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">max_R</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                <span class="n">dxa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">dxa</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">max_R</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                    <span class="n">dxa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">log_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">dxa</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_R</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This is because of the pre-check of the</span>
                <span class="c1"># distance checks</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ix</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Create default return</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">rc</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">rc</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dxa</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Quick return if there are</span>
            <span class="c1"># no entries...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Retrieve all atomic indices which are closer</span>
        <span class="c1"># than our delta-R</span>
        <span class="c1"># The linear algebra norm function could be used, but it</span>
        <span class="c1"># has a lot of checks, hence we do it manually</span>
        <span class="c1"># xaR = np.linalg.norm(dxa,axis=-1)</span>

        <span class="c1"># It is faster to do a single multiplacation than</span>
        <span class="c1"># a sqrt of MANY values</span>
        <span class="c1"># After having reduced the dxa array, we may then</span>
        <span class="c1"># take the sqrt</span>
        <span class="n">max_R</span> <span class="o">=</span> <span class="n">max_R</span> <span class="o">*</span> <span class="n">max_R</span>
        <span class="n">xaR</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="n">dxa</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="n">xaR</span> <span class="o">&lt;=</span> <span class="n">max_R</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Reduce search space and correct distances</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">xaR</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">off</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">del</span> <span class="n">xaR</span><span class="p">,</span> <span class="n">dxa</span>  <span class="c1"># just because these arrays could be very big...</span>

        <span class="c1"># Check whether we only have one range to check.</span>
        <span class="c1"># If so, we need not reduce the index space</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Proximity checks for several quantities &#39;</span>
                              <span class="s1">&#39;at a time requires ascending R values.&#39;</span><span class="p">))</span>

        <span class="c1"># The more neigbours you wish to find the faster this becomes</span>
        <span class="c1"># We only do &quot;one&quot; heavy duty search,</span>
        <span class="c1"># then we immediately reduce search space to this subspace</span>
        <span class="n">tidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ensure_array</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])]]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">rc</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
            <span class="c1"># Search in the sub-space</span>
            <span class="c1"># Notice that this sub-space reduction will never</span>
            <span class="c1"># allow the same indice to be in two ranges (due to</span>
            <span class="c1"># numerics)</span>
            <span class="n">tidx</span> <span class="o">=</span> <span class="n">log_and</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ensure_array</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="n">tidx</span><span class="p">]]))</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">rc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Geometry.bond_correct"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.bond_correct">[docs]</a>    <span class="k">def</span> <span class="nf">bond_correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Corrects the bond between `ia` and the `atom`.</span>

<span class="sd">        Corrects the bond-length between atom `ia` and `atom` in such</span>
<span class="sd">        a way that the atomic radius is preserved.</span>
<span class="sd">        I.e. the sum of the bond-lengths minimizes the distance matrix.</span>

<span class="sd">        Only atom `ia` is moved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia : int</span>
<span class="sd">            The atom to be displaced according to the atomic radius</span>
<span class="sd">        atom : array_like or int</span>
<span class="sd">            The atom(s) from which the radius should be reduced.</span>
<span class="sd">        method : str, float, optional</span>
<span class="sd">            If str will use that as lookup in `Atom.radius`.</span>
<span class="sd">            Else it will be the new bond-length.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Decide which algorithm to choose from</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># a single point</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="n">atom</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># signal a list of atoms</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">algo</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># We have a single atom</span>
            <span class="c1"># Get bond length in the closest direction</span>
            <span class="c1"># A bond-length HAS to be below 10</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.</span><span class="p">),</span> <span class="n">idx</span><span class="o">=</span><span class="n">algo</span><span class="p">,</span>
                                   <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Convert to unitcell atom (and get the one atom)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Calculate the bond vector</span>
            <span class="n">bv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">c</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If it is a number, we use that.</span>
                <span class="n">rad</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># get radius</span>
                <span class="n">rad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> \
                      <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

            <span class="c1"># Update the coordinate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">bv</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">rad</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;Changing bond-length dependent on several lacks implementation.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.within"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.within">[docs]</a>    <span class="k">def</span> <span class="nf">within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span>
            <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indices of atoms in the entire supercell within a given shape from a given coordinate</span>

<span class="sd">        This heavily relies on the `within_sc` method.</span>

<span class="sd">        Note that if a connection is made in a neighbouring super-cell</span>
<span class="sd">        then the atomic index is shifted by the super-cell index times</span>
<span class="sd">        number of atoms.</span>
<span class="sd">        This allows one to decipher super-cell atoms from unit-cell atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapes : Shape, list of Shape</span>
<span class="sd">        idx     : array_like, optional</span>
<span class="sd">            List of indices for atoms that are to be considered</span>
<span class="sd">        idx_xyz : array_like, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `idx` variable (`idx` must also be passed)</span>
<span class="sd">        ret_xyz : bool, optional</span>
<span class="sd">            If true this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij : bool, optional</span>
<span class="sd">            If true this method will return the distances from the `xyz_ia`</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that `shapes` is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapes</span><span class="p">]</span>
        <span class="n">nshapes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>

        <span class="c1"># Get global calls</span>
        <span class="c1"># Is faster for many loops</span>
        <span class="n">concat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>

        <span class="n">ret_special</span> <span class="o">=</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">):</span>
            <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">sret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">within_sc</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:],</span>
                                  <span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="n">idx_xyz</span><span class="p">,</span>
                                  <span class="n">ret_xyz</span><span class="o">=</span><span class="n">ret_xyz</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="n">ret_rij</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ret_special</span><span class="p">:</span>
                <span class="c1"># This is to &quot;fake&quot; the return</span>
                <span class="c1"># of a list (we will do indexing!)</span>
                <span class="n">sret</span> <span class="o">=</span> <span class="p">[</span><span class="n">sret</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># we have a list of arrays (nshapes &gt; 1)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We can add it to the list (nshapes == 1)</span>
                <span class="c1"># We add the atomic offset for the supercell index</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">c</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">d</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nshapes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ret_special</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Geometry.close"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indices of atoms in the entire supercell within a given radius from a given coordinate</span>

<span class="sd">        This heavily relies on the `close_sc` method.</span>

<span class="sd">        Note that if a connection is made in a neighbouring super-cell</span>
<span class="sd">        then the atomic index is shifted by the super-cell index times</span>
<span class="sd">        number of atoms.</span>
<span class="sd">        This allows one to decipher super-cell atoms from unit-cell atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_ia : coordinate/index</span>
<span class="sd">            Either a point in space or an index of an atom.</span>
<span class="sd">            If an index is passed it is the equivalent of passing</span>
<span class="sd">            the atomic coordinate ``close_sc(self.xyz[xyz_ia,:])``.</span>
<span class="sd">        R      : (None), float/tuple of float</span>
<span class="sd">            The radii parameter to where the atomic connections are found.</span>
<span class="sd">            If `R` is an array it will return the indices:</span>
<span class="sd">            in the ranges:</span>

<span class="sd">            &gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] ) # doctest: +SKIP</span>

<span class="sd">            If a single float it will return:</span>

<span class="sd">            &gt;&gt;&gt; x &lt;= R # doctest: +SKIP</span>

<span class="sd">        idx     : array_like, optional</span>
<span class="sd">            List of indices for atoms that are to be considered</span>
<span class="sd">        idx_xyz : array_like, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `idx` variable (`idx` must also be passed)</span>
<span class="sd">        ret_xyz : bool, optional</span>
<span class="sd">            If true this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij : bool, optional</span>
<span class="sd">            If true this method will return the distances from the `xyz_ia`</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Convert inedx coordinate to point</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">xyz_ia</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">):</span>
            <span class="n">xyz_ia</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Get global calls</span>
        <span class="c1"># Is faster for many loops</span>
        <span class="n">concat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>

        <span class="n">ret_special</span> <span class="o">=</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">):</span>

            <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">sret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:],</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                <span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="n">idx_xyz</span><span class="p">,</span>
                <span class="n">ret_xyz</span><span class="o">=</span><span class="n">ret_xyz</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="n">ret_rij</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">ret_special</span><span class="p">:</span>
                <span class="c1"># This is to &quot;fake&quot; the return</span>
                <span class="c1"># of a list (we will do indexing!)</span>
                <span class="n">sret</span> <span class="o">=</span> <span class="p">[</span><span class="n">sret</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># we have a list of arrays (len(R) &gt; 1)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We can add it to the list (len(R) == 1)</span>
                <span class="c1"># We add the atomic offset for the supercell index</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">c</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">d</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ret_special</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="c1"># Hence ``close_all`` has exact meaning</span>
    <span class="c1"># but ``close`` is shorten and retains meaning</span>
    <span class="n">close_all</span> <span class="o">=</span> <span class="n">close</span>

<div class="viewcode-block" id="Geometry.a2o"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.a2o">[docs]</a>    <span class="k">def</span> <span class="nf">a2o</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an orbital index of the first orbital of said atom.</span>
<span class="sd">        This is particularly handy if you want to create</span>
<span class="sd">        TB models with more than one orbital per atom.</span>

<span class="sd">        Note that this will preserve the super-cell offsets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia : array_like</span>
<span class="sd">             Atomic indices</span>
<span class="sd">        all : bool, optional</span>
<span class="sd">             ``False``, return only the first orbital corresponding to the atom,</span>
<span class="sd">             ``True``, returns list of the full atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">ia</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">ia</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">ia</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span>
        <span class="n">oe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Create ranges</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">oe</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">oe</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.o2a"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.o2a">[docs]</a>    <span class="k">def</span> <span class="nf">o2a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">uniq</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Atomic index corresponding to the orbital indicies.</span>

<span class="sd">        This is a particurlaly slow algorithm due to for-loops.</span>

<span class="sd">        Note that this will preserve the super-cell offsets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        io: array_like</span>
<span class="sd">             List of indices to return the atoms for</span>
<span class="sd">        uniq : bool, optional</span>
<span class="sd">             If True only return the unique atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">uniq</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">io</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">io</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">io</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">io</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">io</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="c1"># Use b-casting rules</span>
        <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">uniq</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">io</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">io</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span></div>

<div class="viewcode-block" id="Geometry.sc2uc"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.sc2uc">[docs]</a>    <span class="k">def</span> <span class="nf">sc2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">uniq</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns atom from super-cell indices to unit-cell indices, possibly removing dublicates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like or int</span>
<span class="sd">           the atomic indices converted from supercell indices to unit-cell indices</span>
<span class="sd">        uniq : bool, optional</span>
<span class="sd">           If True the returned indices are unique and sorted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">ensure_dtype</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="k">if</span> <span class="n">uniq</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atom</span></div>
    <span class="n">asc2uc</span> <span class="o">=</span> <span class="n">sc2uc</span>

<div class="viewcode-block" id="Geometry.osc2uc"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.osc2uc">[docs]</a>    <span class="k">def</span> <span class="nf">osc2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orb</span><span class="p">,</span> <span class="n">uniq</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns orbitals from super-cell indices to unit-cell indices, possibly removing dublicates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orb : array_like or int</span>
<span class="sd">           the orbital indices converted from supercell indices to unit-cell indices</span>
<span class="sd">        uniq : bool, optional</span>
<span class="sd">           If True the returned indices are unique and sorted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orb</span> <span class="o">=</span> <span class="n">ensure_dtype</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="k">if</span> <span class="n">uniq</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orb</span></div>

<div class="viewcode-block" id="Geometry.a2isc"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.a2isc">[docs]</a>    <span class="k">def</span> <span class="nf">a2isc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns super-cell index for a specific/list atom</span>

<span class="sd">        Returns a vector of 3 numbers with integers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">ensure_dtype</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span></div>

    <span class="c1"># This function is a bit weird, it returns a real array,</span>
    <span class="c1"># however, there should be no ambiguity as it corresponds to th</span>
    <span class="c1"># offset and &quot;what else&quot; is there to query?</span>
<div class="viewcode-block" id="Geometry.a2sc"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.a2sc">[docs]</a>    <span class="k">def</span> <span class="nf">a2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the super-cell offset for a specific atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">a</span><span class="p">))</span></div>

<div class="viewcode-block" id="Geometry.o2isc"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.o2isc">[docs]</a>    <span class="k">def</span> <span class="nf">o2isc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">io</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the super-cell index for a specific orbital.</span>

<span class="sd">        Returns a vector of 3 numbers with integers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">ensure_dtype</span><span class="p">(</span><span class="n">io</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="Geometry.o2sc"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.o2sc">[docs]</a>    <span class="k">def</span> <span class="nf">o2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the super-cell offset for a specific orbital.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">o</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__plot__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig_axes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_sc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Plot the geometry in a specified ``matplotlib.Axes`` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fig_axes : bool or matplotlib.Axes, optional</span>
<span class="sd">           the figure axes to plot in (if ``matplotlib.Axes`` object).</span>
<span class="sd">           If `True` it will create a new figure to plot in.</span>
<span class="sd">           If `False` it will try and grap the current figure and the current axes.</span>
<span class="sd">        axes : array_like, optional</span>
<span class="sd">           only plot a subset of the axis, defaults to all axes&quot;</span>
<span class="sd">        plot_sc : bool, optional</span>
<span class="sd">           If `True` also plot the supercell structure</span>
<span class="sd">           only plot a subset of the axis, defaults to all axes&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default dictionary for passing to newly created figures</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">plot_sc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">__plot__</span><span class="p">(</span><span class="n">fig_axes</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fig_axes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">fig_axes</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Ensure we have a new 3D Axes3D</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;projection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;3d&#39;</span>

        <span class="k">if</span> <span class="n">fig_axes</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fig_axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">mlibplt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">fig_axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">mlibplt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fig_axes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fig_axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">mlibplt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">atom</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">specie</span><span class="p">]</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">Z</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">atom</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="n">area</span><span class="p">[:]</span> <span class="o">*=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">ma</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">specie</span><span class="p">]</span>

        <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fig_axes</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">mlib3d</span><span class="o">.</span><span class="n">Axes3D</span><span class="p">):</span>
            <span class="c1"># We should plot in 3D plots</span>
            <span class="n">fig_axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">mlibplt</span><span class="o">.</span><span class="n">zlabel</span><span class="p">(</span><span class="s1">&#39;Ang&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig_axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">s</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">mlibplt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Ang&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">mlibplt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Ang&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.fromASE"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.fromASE">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromASE</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">aseg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns geometry from an ASE object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        aseg : ASE ``Atoms`` object which contains the following routines:</span>
<span class="sd">            ``get_atomic_numbers``, ``get_positions``, ``get_cell``.</span>
<span class="sd">            From those methods a `sisl` object will be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_cell</span><span class="p">()</span>
        <span class="c1"># Convert to sisl object</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">cell</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.toASE"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.toASE">[docs]</a>    <span class="k">def</span> <span class="nf">toASE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the geometry as an ASE ``Atoms`` object &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ase</span> <span class="k">import</span> <span class="n">Atoms</span>
        <span class="k">return</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                     <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the mass of all atoms as an array &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">mass</span>

<div class="viewcode-block" id="Geometry.equal"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.equal">[docs]</a>    <span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Whether two geometries are the same (optional not check of the orbital radius)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry</span>
<span class="sd">            the other Geometry to check against</span>
<span class="sd">        maxR : bool, optional</span>
<span class="sd">            if True also check if the orbital radii are the same (see `Atom.equal`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">same</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sc</span>
        <span class="n">same</span> <span class="o">=</span> <span class="n">same</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">same</span> <span class="o">=</span> <span class="n">same</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">same</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.sparserij"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.sparserij">[docs]</a>    <span class="k">def</span> <span class="nf">sparserij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">na_iR</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rand&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the sparse matrix with all distances in the matrix</span>

<span class="sd">        The sparse matrix will only be defined for the elements which have</span>
<span class="sd">        orbitals overlapping with other atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, numpy.float64</span>
<span class="sd">           the data-type of the sparse matrix</span>
<span class="sd">        na_iR : int, 1000</span>
<span class="sd">           number of atoms within the sphere for speeding</span>
<span class="sd">           up the `iter_block` loop.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">           see `iter_block` for details</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseAtom</span>
<span class="sd">           sparse matrix with all rij elements</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter_block : the method for looping the atoms</span>
<span class="sd">        distance : create a list of distances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rij</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get R</span>
        <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">())</span>
        <span class="n">iR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iR</span><span class="p">(</span><span class="n">na_iR</span><span class="p">)</span>

        <span class="c1"># Do the loop</span>
        <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block</span><span class="p">(</span><span class="n">iR</span><span class="o">=</span><span class="n">iR</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">):</span>

            <span class="c1"># Get all the indexed atoms...</span>
            <span class="c1"># This speeds up the searching for</span>
            <span class="c1"># coordinates...</span>
            <span class="n">idxs_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Loop the atoms inside</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="n">idxs_xyz</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rij</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">rij</span></div>

<div class="viewcode-block" id="Geometry.distance"><a class="viewcode-back" href="../../api-generated/sisl.Geometry.html#sisl.Geometry.distance">[docs]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the distances for all atoms in shells of radius `tol` within `max_R`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like, optional</span>
<span class="sd">           only create list of distances from the given atoms, default to all atoms</span>
<span class="sd">        R : float, optional</span>
<span class="sd">           the maximum radius to consider, default to ``self.maxR()``.</span>
<span class="sd">           To retrieve all distances for atoms within the supercell structure</span>
<span class="sd">           you can pass `numpy.inf`.</span>
<span class="sd">        tol : float or array_like, optional</span>
<span class="sd">           the tolerance for grouping a set of atoms.</span>
<span class="sd">           This parameter sets the shell radius for each shell.</span>
<span class="sd">           I.e. the returned distances between two shells will be maximally</span>
<span class="sd">           ``2*tol``, but only if atoms are within two consecutive lists.</span>
<span class="sd">           If this is a list, the shells will be of unequal size.</span>

<span class="sd">           The first shell size will be ``tol * .5`` or ``tol[0] * .5`` if `tol` is a list.</span>

<span class="sd">        method : {&#39;average&#39;, &#39;mode&#39;, &#39;&lt;numpy.func&gt;&#39;, func}</span>
<span class="sd">           How the distance in each shell is determined.</span>
<span class="sd">           A list of distances within each shell is gathered and the equivalent</span>
<span class="sd">           method will be used to extract a single quantity from the list of</span>
<span class="sd">           distances in the shell.</span>
<span class="sd">           If `&#39;mode&#39;` is chosen it will use `scipy.stats.mode`.</span>
<span class="sd">           If a string is given it will correspond to ``getattr(numpy, method)``,</span>
<span class="sd">           while any callable function may be passed. The passed function</span>
<span class="sd">           will only be passed a list of unsorted distances that needs to be</span>
<span class="sd">           processed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([0]*3, Atom(1, R=1.), sc=SuperCell(1., nsc=[5, 5, 1]))</span>
<span class="sd">        &gt;&gt;&gt; geom.distance() # use geom.maxR()</span>
<span class="sd">        array([ 1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.distance(tol=[0.5, 0.4, 0.3, 0.2])</span>
<span class="sd">        array([ 1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.distance(R=2, tol=[0.5, 0.4, 0.3, 0.2])</span>
<span class="sd">        array([ 1.        ,  1.41421356,  2.        ])</span>
<span class="sd">        &gt;&gt;&gt; geom.distance(R=2, tol=[0.5, 0.7]) # the R = 1 and R = 2 ** .5 gets averaged</span>
<span class="sd">        array([ 1.20710678,  2.        ])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           an array of positive numbers yielding the distances from the atoms in reduced form</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sparserij : return a sparse matrix will all distances between atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Correct atom input</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

        <span class="c1"># Figure out maximum distance</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span>
                                  <span class="s2">&quot;.distance cannot determine the `R` parameter. &quot;</span>
                                  <span class="s2">&quot;The internal `maxR()` is negative and thus not set. &quot;</span>
                                  <span class="s2">&quot;Set an explicit value for `R`.&quot;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">maxR</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
            <span class="c1"># These loops could be leveraged if we look at angles...</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span>
                                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span>
                                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">sc</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">ii</span> <span class="o">+</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">jj</span> <span class="o">+</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">kk</span>
                    <span class="n">maxR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxR</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">R</span> <span class="o">&gt;</span> <span class="n">maxR</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">maxR</span>

        <span class="c1"># Convert to list</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">tol</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Now we are in a position to determine the sizes</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">tol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="n">tol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">55</span><span class="p">,</span> <span class="n">tol</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">tol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">dR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="c1"># The first tolerance, is for it-self, the second</span>
            <span class="c1"># has to have the first tolerance as the field</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">cumsumd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tol</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">dR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">:</span>
                <span class="c1"># Now finalize dR by ensuring all remaining segments are captured</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">tol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">dR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dR</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">dR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="o">.</span><span class="mi">55</span><span class="p">,</span> <span class="n">t</span><span class="p">)))</span>

            <span class="c1"># Reduce to the largest value above R</span>
            <span class="c1"># This ensures that R, truly is the largest considered element</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">dR</span><span class="p">[:(</span><span class="n">dR</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Now we can figure out the list of atoms in each shell</span>
        <span class="c1"># First create the initial lists of shell atoms</span>
        <span class="c1"># The inner shell will never be used, because it should correspond</span>
        <span class="c1"># to the atom it-self.</span>
        <span class="n">shells</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atom</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">dR</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rlist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rlist</span><span class="p">)</span>

        <span class="c1"># Now parse all of the shells with the correct routine</span>
        <span class="c1"># First we grap the routine:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">_str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mode&#39;</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">mode</span>
                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">mode</span><span class="p">(</span><span class="n">lst</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.distance `method` has wrong input value.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">method</span>

        <span class="c1"># Reduce lists</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">)):</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Reduce elements</span>
            <span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

        <span class="c1"># Convert to flattened numpy array and ensure shape</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">shells</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="k">return</span> <span class="n">d</span></div>

    <span class="c1"># Create pickling routines</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the state of this object &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Re-create the state of this object &quot;&quot;&quot;</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">()</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">],</span> <span class="n">atom</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_ArgumentParser_args_single</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the options for `Geometry.ArgumentParser` in case they are the only options &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;limit_arguments&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;short&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;positional_out&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">}</span>

    <span class="c1"># Hook into the Geometry class to create</span>
    <span class="c1"># an automatic ArgumentParser which makes actions</span>
    <span class="c1"># as the options are read.</span>
    <span class="nd">@default_ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Manipulate a Geometry object in sisl.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ArgumentParser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create and return a group of argument parsers which manipulates it self `Geometry`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parser: ArgumentParser, optional</span>
<span class="sd">           in case the arguments should be added to a specific parser. It defaults</span>
<span class="sd">           to create a new.</span>
<span class="sd">        limit_arguments: bool, optional</span>
<span class="sd">           If ``False`` additional options will be created which are similar to other options.</span>
<span class="sd">           For instance ``--repeat-x`` which is equivalent to ``--repeat x``.</span>
<span class="sd">           Default `True`.</span>
<span class="sd">        short: bool, optional</span>
<span class="sd">           Create short options for a selected range of options.</span>
<span class="sd">        positional_out: bool, optional</span>
<span class="sd">           If ``True``, adds a positional argument which acts as --out. This may be handy if only the geometry is in the argument list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">limit_args</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;limit_arguments&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">short</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;short&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">opts</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">short</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">args</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># We limit the import to occur here</span>
        <span class="kn">import</span> <span class="nn">argparse</span>

        <span class="c1"># The first thing we do is adding the geometry to the NameSpace of the</span>
        <span class="c1"># parser.</span>
        <span class="c1"># This will enable custom actions to interact with the geometry in a</span>
        <span class="c1"># straight forward manner.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;_geometry&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="s2">&quot;_stored_geometry&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="n">default_namespace</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># Create actions</span>
        <span class="k">class</span> <span class="nc">Format</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geom_fmt</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--format&#39;</span><span class="p">),</span> <span class="n">action</span><span class="o">=</span><span class="n">Format</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;.8f&#39;</span><span class="p">,</span>
                   <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify output format for coordinates.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">MoveOrigin</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--origin&#39;</span><span class="p">,</span> <span class="s1">&#39;-O&#39;</span><span class="p">),</span> <span class="n">action</span><span class="o">=</span><span class="n">MoveOrigin</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Move all atoms such that one atom will be at the origin.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">MoveCenterOf</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">what</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">what</span><span class="o">=</span><span class="n">value</span><span class="p">)</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--center-of&#39;</span><span class="p">,</span> <span class="s1">&#39;-co&#39;</span><span class="p">),</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;cell&#39;</span><span class="p">],</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">MoveCenterOf</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Move coordinates to the center of the designated choice.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">MoveUnitCell</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;translate&#39;</span><span class="p">,</span> <span class="s1">&#39;tr&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">]:</span>
                    <span class="c1"># Simple translation</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">tmp</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mod&#39;</span><span class="p">]:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span>
                    <span class="c1"># Change all coordinates using the reciprocal cell and move to unit-cell (% 1.)</span>
                    <span class="n">fxyz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">fxyz</span> <span class="o">%</span> <span class="mf">1.</span>
                    <span class="n">fxyz</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">fxyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fxyz</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--unit-cell&#39;</span><span class="p">,</span> <span class="s1">&#39;-uc&#39;</span><span class="p">),</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;translate&#39;</span><span class="p">,</span> <span class="s1">&#39;tr&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;mod&#39;</span><span class="p">],</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">MoveUnitCell</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Moves the coordinates into the unit-cell by translation or the mod-operator&#39;</span><span class="p">)</span>

        <span class="c1"># Rotation</span>
        <span class="k">class</span> <span class="nc">Rotation</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Convert value[0] to the direction</span>
                <span class="c1"># The rotate function expects degree</span>
                <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--rotate&#39;</span><span class="p">,</span> <span class="s1">&#39;-R&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;ANGLE&#39;</span><span class="p">,</span> <span class="s1">&#39;DIR&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">Rotation</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate geometry around given axis. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_args</span><span class="p">:</span>
            <span class="k">class</span> <span class="nc">RotationX</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># The rotate function expects degree</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--rotate-x&#39;</span><span class="p">,</span> <span class="s1">&#39;-Rx&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ANGLE&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">RotationX</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate geometry around first cell vector. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">RotationY</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># The rotate function expects degree</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--rotate-y&#39;</span><span class="p">,</span> <span class="s1">&#39;-Ry&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ANGLE&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">RotationY</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate geometry around second cell vector. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">RotationZ</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># The rotate function expects degree</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--rotate-z&#39;</span><span class="p">,</span> <span class="s1">&#39;-Rz&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ANGLE&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">RotationZ</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate geometry around third cell vector. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">)</span>

        <span class="c1"># Reduce size of geometry</span>
        <span class="k">class</span> <span class="nc">ReduceSub</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Get atomic indices</span>
                <span class="n">rng</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--sub&#39;</span><span class="p">,</span> <span class="s1">&#39;-s&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;RNG&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">ReduceSub</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Removes specified atoms, can be complex ranges.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">ReduceCut</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--cut&#39;</span><span class="p">,</span> <span class="s1">&#39;-c&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SEPS&#39;</span><span class="p">,</span> <span class="s1">&#39;DIR&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">ReduceCut</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Cuts the geometry into `seps` parts along the unit-cell direction `dir`.&#39;</span><span class="p">)</span>

        <span class="c1"># Swaps atoms</span>
        <span class="k">class</span> <span class="nc">AtomSwap</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Get atomic indices</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;swapping atoms requires equal number of LHS and RHS atomic ranges&#39;</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--swap&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">AtomSwap</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Swaps groups of atoms (can be complex ranges). The groups must be of equal length.&#39;</span><span class="p">)</span>

        <span class="c1"># Add an atom</span>
        <span class="k">class</span> <span class="nc">AtomAdd</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create an atom from the input</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)],</span> <span class="n">atom</span><span class="o">=</span><span class="n">Atom</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--add&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;COORD&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">AtomAdd</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Adds an atom, coordinate is comma separated (in Ang). Z is the atomic number.&#39;</span><span class="p">)</span>

        <span class="c1"># Translate</span>
        <span class="k">class</span> <span class="nc">Translate</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create an atom from the input</span>
                <span class="k">if</span> <span class="s1">&#39;,&#39;</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--translate&#39;</span><span class="p">,</span> <span class="s1">&#39;-t&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;COORD&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">Translate</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Translates the coordinates via a comma separated list (in Ang).&#39;</span><span class="p">)</span>

        <span class="c1"># Periodicly increase the structure</span>
        <span class="k">class</span> <span class="nc">PeriodRepeat</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--repeat&#39;</span><span class="p">,</span> <span class="s1">&#39;-r&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span> <span class="s1">&#39;DIR&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeat</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Repeats the geometry in the specified direction.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_args</span><span class="p">:</span>
            <span class="k">class</span> <span class="nc">PeriodRepeatX</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--repeat-x&#39;</span><span class="p">,</span> <span class="s1">&#39;-rx&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeatX</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Repeats the geometry along the first cell vector.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">PeriodRepeatY</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--repeat-y&#39;</span><span class="p">,</span> <span class="s1">&#39;-ry&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeatY</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Repeats the geometry along the second cell vector.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">PeriodRepeatZ</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--repeat-z&#39;</span><span class="p">,</span> <span class="s1">&#39;-rz&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeatZ</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Repeats the geometry along the third cell vector.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">PeriodTile</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--tile&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span> <span class="s1">&#39;DIR&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">PeriodTile</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Tiles the geometry in the specified direction.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_args</span><span class="p">:</span>
            <span class="k">class</span> <span class="nc">PeriodTileX</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--tile-x&#39;</span><span class="p">,</span> <span class="s1">&#39;-tx&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodTileX</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Tiles the geometry along the first cell vector.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">PeriodTileY</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--tile-y&#39;</span><span class="p">,</span> <span class="s1">&#39;-ty&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodTileY</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Tiles the geometry along the second cell vector.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">PeriodTileZ</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--tile-z&#39;</span><span class="p">,</span> <span class="s1">&#39;-tz&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodTileZ</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Tiles the geometry along the third cell vector.&#39;</span><span class="p">)</span>

        <span class="c1"># Print some common information about the</span>
        <span class="c1"># geometry (to stdout)</span>
        <span class="k">class</span> <span class="nc">PrintInfo</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># We fake that it has been stored...</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_stored_geometry</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--info&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">PrintInfo</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Print, to stdout, some regular information about the geometry.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">Out</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="c1"># If the vector, exists, we should write it</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_geom_fmt&#39;</span><span class="p">):</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fmt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geom_fmt</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_vector&#39;</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_vector&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_vector_scale&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                        <span class="n">v</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="c1"># Issue to the namespace that the geometry has been written, at least once.</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_stored_geometry</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--out&#39;</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Store the geometry (at its current invocation) to the out file.&#39;</span><span class="p">)</span>

        <span class="c1"># If the user requests positional out arguments, we also add that.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;positional_out&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Store the geometry (at its current invocation) to the out file.&#39;</span><span class="p">)</span>

        <span class="c1"># We have now created all arguments</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">namespace</span></div>


<span class="k">def</span> <span class="nf">sgeom</span><span class="p">(</span><span class="n">geom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">argv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ret_geometry</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Main script for sgeom.</span>

<span class="sd">    This routine may be called with `argv` and/or a `Sile` which is the geometry at hand.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    geom : Geometry or BaseSile</span>
<span class="sd">       this may either be the geometry, as-is, or a `Sile` which contains</span>
<span class="sd">       the geometry.</span>
<span class="sd">    argv : list of str</span>
<span class="sd">       the arguments passed to sgeom</span>
<span class="sd">    ret_geometry : bool, optional</span>
<span class="sd">       whether the function should return the geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">osp</span>
    <span class="kn">import</span> <span class="nn">argparse</span>

    <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="k">import</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">BaseSile</span>

    <span class="c1"># The geometry-file *MUST* be the first argument</span>
    <span class="c1"># (except --help|-h)</span>

    <span class="c1"># We cannot create a separate ArgumentParser to retrieve a positional arguments</span>
    <span class="c1"># as that will grab the first argument for an option!</span>

    <span class="c1"># Start creating the command-line utilities that are the actual ones.</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">This manipulation utility is highly advanced and one should note that the ORDER of</span>
<span class="s2">options is determining the final structure. For instance:</span>

<span class="s2">   </span><span class="si">{0}</span><span class="s2"> geom.xyz --repeat x 2 --repeat y 2</span>

<span class="s2">is NOT equivalent to:</span>

<span class="s2">   </span><span class="si">{0}</span><span class="s2"> geom.xyz --repeat y 2 --repeat x 2</span>

<span class="s2">This may be unexpected but enables one to do advanced manipulations.</span>

<span class="s2">Additionally, in between arguments, one may store the current state of the geometry</span>
<span class="s2">by writing to a standard file.</span>

<span class="s2">   </span><span class="si">{0}</span><span class="s2"> geom.xyz --repeat y 2 geom_repy.xyz --repeat x 2 geom_repy_repx.xyz</span>

<span class="s2">will create two files:</span>
<span class="s2">   geom_repy.xyz</span>
<span class="s2">will only be repeated 2 times along the second lattice vector, while:</span>
<span class="s2">   geom_repy_repx.xyz</span>
<span class="s2">will be repeated 2 times along the second lattice vector, and then the first</span>
<span class="s2">lattice vector.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">osp</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">argv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--help&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># no arguments</span>
        <span class="c1"># fake a help</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--help&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Ensure that the arguments have pre-pended spaces</span>
    <span class="n">argv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">argv_negative_fix</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="s1">&#39;Manipulates geometries from any Sile.&#39;</span><span class="p">,</span>
                                <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span><span class="p">,</span>
                                <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>

    <span class="c1"># First read the input &quot;Sile&quot;</span>
    <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">argv</span><span class="p">,</span> <span class="n">input_file</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">collect_input</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
        <span class="c1"># Do nothing, the geometry is already created</span>
        <span class="k">pass</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="c1"># Store the input file...</span>
        <span class="n">input_file</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">file</span>

    <span class="c1"># Do the argument parser</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">geom</span><span class="o">.</span><span class="n">_ArgumentParser_args_single</span><span class="p">())</span>

    <span class="c1"># Now the arguments should have been populated</span>
    <span class="c1"># and we will sort out if the input options</span>
    <span class="c1"># is only a help option.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_input_file&#39;</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_input_file&#39;</span><span class="p">,</span> <span class="n">input_file</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Now try and figure out the actual arguments</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">argv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">collect_arguments</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">argumentparser</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                                        <span class="n">namespace</span><span class="o">=</span><span class="n">ns</span><span class="p">)</span>

    <span class="c1"># We are good to go!!!</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">ns</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">_geometry</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">_stored_geometry</span><span class="p">:</span>
        <span class="c1"># We should write out the information to the stdout</span>
        <span class="c1"># This is merely for testing purposes and may not be used for anything.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cell:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{0:10.6f}</span><span class="s1"> </span><span class="si">{1:10.6f}</span><span class="s1"> </span><span class="si">{2:10.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SuperCell:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{0:d}</span><span class="s1"> </span><span class="si">{1:d}</span><span class="s1"> </span><span class="si">{2:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">nsc</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; </span><span class="si">{:&gt;10s}</span><span class="s1"> </span><span class="si">{:&gt;10s}</span><span class="s1"> </span><span class="si">{:&gt;10s}</span><span class="s1">  </span><span class="si">{:&gt;3s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; </span><span class="si">{1:10.6f}</span><span class="s1"> </span><span class="si">{2:10.6f}</span><span class="s1"> </span><span class="si">{3:10.6f}</span><span class="s1">  </span><span class="si">{0:3d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span>
                                                                  <span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]))</span>

    <span class="k">if</span> <span class="n">ret_geometry</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2018, Nick R. Papior.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.9.2-190',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>