

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sisl.io.tbtrans.tbt &mdash; sisl |release| documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="sisl |release| documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                0.9.2-122
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cite.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">API documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">sisl</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>sisl.io.tbtrans.tbt</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sisl.io.tbtrans.tbt</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">StringIO</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">in1d</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="c1"># The sparse matrix for the orbital/bond currents</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">csr_matrix</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">isspmatrix_csr</span>

<span class="c1"># Import sile objects</span>
<span class="kn">from</span> <span class="nn">..sile</span> <span class="k">import</span> <span class="n">add_sile</span><span class="p">,</span> <span class="n">sile_raise_write</span>
<span class="kn">from</span> <span class="nn">._cdf</span> <span class="k">import</span> <span class="n">_devncSileTBtrans</span>
<span class="kn">from</span> <span class="nn">sisl.utils</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sisl._array</span> <span class="k">as</span> <span class="nn">_a</span>

<span class="c1"># Import the geometry object</span>
<span class="kn">from</span> <span class="nn">sisl</span> <span class="k">import</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atoms</span><span class="p">,</span> <span class="n">SuperCell</span>
<span class="kn">from</span> <span class="nn">sisl._help</span> <span class="k">import</span> <span class="n">_str</span><span class="p">,</span> <span class="n">ensure_array</span>
<span class="kn">from</span> <span class="nn">sisl._help</span> <span class="k">import</span> <span class="n">_range</span> <span class="k">as</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">sisl.unit.siesta</span> <span class="k">import</span> <span class="n">unit_convert</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tbtncSileTBtrans&#39;</span><span class="p">,</span> <span class="s1">&#39;phtncSileTBtrans&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;tbtavncSileTBtrans&#39;</span><span class="p">,</span> <span class="s1">&#39;phtavncSileTBtrans&#39;</span><span class="p">]</span>

<span class="n">Bohr2Ang</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Bohr&#39;</span><span class="p">,</span> <span class="s1">&#39;Ang&#39;</span><span class="p">)</span>
<span class="n">Ry2eV</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Ry&#39;</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span>
<span class="n">Ry2K</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Ry&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="n">eV2Ry</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;eV&#39;</span><span class="p">,</span> <span class="s1">&#39;Ry&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="tbtncSileTBtrans"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans">[docs]</a><span class="k">class</span> <span class="nc">tbtncSileTBtrans</span><span class="p">(</span><span class="n">_devncSileTBtrans</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; TBtrans output file object</span>

<span class="sd">    Implementation of the TBtrans output ``*.TBT.nc`` files which contains</span>
<span class="sd">    calculated quantities related to the NEGF code TBtrans.</span>

<span class="sd">    Although the TBtrans code is in fortran and the resulting NetCDF file variables</span>
<span class="sd">    are in fortran indexing (1-based), everything is returned as Python indexing (0-based)</span>
<span class="sd">    when using Python scripts.</span>

<span class="sd">    In the following equations we will use this notation:</span>

<span class="sd">    * :math:`\alpha` and :math:`\beta` are atomic indices</span>
<span class="sd">    * :math:`\nu` and :math:`\mu` are orbital indices</span>

<span class="sd">    A word on DOS normalization:</span>

<span class="sd">    All the device region DOS functions may request a normalization depending</span>
<span class="sd">    on a variety of functions. You are highly encouraged to read the documentation for</span>
<span class="sd">    the `norm` function and to consider the benefit of using the ``norm=&#39;atom&#39;``</span>
<span class="sd">    normalization to more easily compare various partitions of DOS.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The API for this class are largely equivalent to the arguments of the `sdata` command-line</span>
<span class="sd">    tool, with the execption that the command-line tool uses Fortran indexing numbers (1-based).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_trans_type</span> <span class="o">=</span> <span class="s1">&#39;TBT&#39;</span>
    <span class="n">_k_avg</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="tbtncSileTBtrans.write_tbtav"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.write_tbtav">[docs]</a>    <span class="k">def</span> <span class="nf">write_tbtav</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert this to a TBT.AV.nc file, i.e. all k dependent quantites are averaged out.</span>

<span class="sd">        This command will overwrite any previous file with the ending TBT.AV.nc and thus</span>
<span class="sd">        will not take notice of any older files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tbtavncSileTBtrans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.nc&#39;</span><span class="p">,</span> <span class="s1">&#39;.AV.nc&#39;</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tbtav</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_value_avg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Local method for obtaining the data from the SileCDF.</span>

<span class="sd">        This method checks how the file is access, i.e. whether</span>
<span class="sd">        data is stored in the object or it should be read consequtively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_access</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_avg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">[:]</span>

        <span class="n">wkpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wk</span>

        <span class="c1"># Perform normalization</span>
        <span class="n">orig_shape</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kavg</span><span class="p">:</span>
                <span class="n">nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wkpt</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nk</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">kavg</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">kavg</span><span class="p">]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We assume kavg is some kind of iterable</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">kavg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">kavg</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kavg</span><span class="p">)):</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">kavg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">kavg</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Return data</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_value_E</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Local method for obtaining the data from the SileCDF using an E index.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">kavg</span><span class="p">)</span>

        <span class="c1"># Ensure that it is an index</span>
        <span class="n">iE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_avg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

        <span class="n">wkpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wk</span>

        <span class="c1"># Perform normalization</span>
        <span class="n">orig_shape</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kavg</span><span class="p">:</span>
                <span class="n">nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wkpt</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nk</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">kavg</span><span class="p">,</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">kavg</span><span class="p">]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We assume kavg is some kind of itterable</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">kavg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">kavg</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">kavg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="c1"># Return data</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_elec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Converts a string or integer to the corresponding electrode name</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : str or int</span>
<span class="sd">           if `str` it is the *exact* electrode name, if `int` it is the electrode</span>
<span class="sd">           index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str : the electrode name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">elec</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elecs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; List of electrodes &quot;&quot;&quot;</span>
        <span class="n">elecs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># in cases of not calculating all</span>
        <span class="c1"># electrode transmissions we must ensure that</span>
        <span class="c1"># we add the last one</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">elecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tvar</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tvar</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.T&#39;</span><span class="p">):</span>
                <span class="n">tvar</span> <span class="o">=</span> <span class="n">tvar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tvar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elecs</span><span class="p">:</span>
                    <span class="n">elecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tvar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">elecs</span>

<div class="viewcode-block" id="tbtncSileTBtrans.chemical_potential"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.chemical_potential">[docs]</a>    <span class="k">def</span> <span class="nf">chemical_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the chemical potential associated with the electrode `elec` &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(</span><span class="s1">&#39;mu&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Ry2eV</span></div>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">chemical_potential</span>

<div class="viewcode-block" id="tbtncSileTBtrans.electronic_temperature"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.electronic_temperature">[docs]</a>    <span class="k">def</span> <span class="nf">electronic_temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return temperature of the electrode electronic distribution in Kelvin &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(</span><span class="s1">&#39;kT&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Ry2K</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.kT"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.kT">[docs]</a>    <span class="k">def</span> <span class="nf">kT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return temperature of the electrode electronic distribution in eV &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(</span><span class="s1">&#39;kT&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Ry2eV</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.eta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.eta">[docs]</a>    <span class="k">def</span> <span class="nf">eta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The imaginary part used when calculating the self-energies in eV &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Ry2eV</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.transmission"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.transmission">[docs]</a>    <span class="k">def</span> <span class="nf">transmission</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec_from</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">elec_to</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Transmission from `elec_from` to `elec_to`.</span>

<span class="sd">        The transmission between two electrodes may be retrieved</span>
<span class="sd">        from the `Sile`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from: str, int, optional</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_to: str, int, optional</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned transmission is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transmission_eig : the transmission decomposed in eigenchannels</span>
<span class="sd">        transmission_bulk : the total transmission in a periodic lead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elec_from</span> <span class="o">==</span> <span class="n">elec_to</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Supplied elec_from and elec_to must not be the same.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span><span class="n">elec_to</span> <span class="o">+</span> <span class="s1">&#39;.T&#39;</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.transmission_eig"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.transmission_eig">[docs]</a>    <span class="k">def</span> <span class="nf">transmission_eig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec_from</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">elec_to</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Transmission eigenvalues from `elec_from` to `elec_to`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from: str, int, optional</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_to: str, int, optional</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned transmission is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transmission : the total transmission</span>
<span class="sd">        transmission_bulk : the total transmission in a periodic lead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elec_from</span> <span class="o">==</span> <span class="n">elec_to</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Supplied elec_from and elec_to must not be the same.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span><span class="n">elec_to</span> <span class="o">+</span> <span class="s1">&#39;.T.Eig&#39;</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.transmission_bulk"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.transmission_bulk">[docs]</a>    <span class="k">def</span> <span class="nf">transmission_bulk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Bulk transmission for the `elec` electrode</span>

<span class="sd">        The bulk transmission is equivalent to creating a 2 terminal device with</span>
<span class="sd">        electrode `elec` tiled 3 times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str, int, optional</span>
<span class="sd">           the bulk electrode</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned transmission is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transmission : the total transmission</span>
<span class="sd">        transmission_eig : the transmission decomposed in eigenchannels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">),</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.norm"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbital</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Normalization factor depending on the input</span>

<span class="sd">        The normalization can be performed in one of the below methods.</span>
<span class="sd">        In the following :math:`N` refers to the normalization constant</span>
<span class="sd">        that is to be used (i.e. the divisor):</span>

<span class="sd">        ``&#39;none&#39;``</span>
<span class="sd">           :math:`N=1`</span>
<span class="sd">        ``&#39;all&#39;``</span>
<span class="sd">           :math:`N` equals the number of orbitals in the total device region.</span>
<span class="sd">        ``&#39;atom&#39;``</span>
<span class="sd">           :math:`N` equals the total number of orbitals in the selected</span>
<span class="sd">           atoms. If `orbital` is an argument a conversion of `orbital` to the equivalent</span>
<span class="sd">           unique atoms is performed, and subsequently the total number of orbitals on the</span>
<span class="sd">           atoms is used. This makes it possible to compare the fraction of orbital DOS easier.</span>
<span class="sd">        ``&#39;orbital&#39;``</span>
<span class="sd">           :math:`N` is the sum of selected orbitals, if `atom` is specified, this</span>
<span class="sd">           is equivalent to the &#39;atom&#39; option.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of atoms (default to all).</span>
<span class="sd">           *NOT* allowed with `orbital` keyword</span>
<span class="sd">        orbital : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of orbitals (default to all)</span>
<span class="sd">           *NOT* allowed with `atom` keyword</span>
<span class="sd">        norm : {&#39;none&#39;, &#39;atom&#39;, &#39;orbital&#39;, &#39;all&#39;}</span>
<span class="sd">           how the normalization of the summed DOS is performed (see `norm` routine)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cast to lower</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="s1">&#39;orbital&#39;</span><span class="p">]:</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no_d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error on norm keyword in when requesting normalization&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbital</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NORM</span>

        <span class="c1"># Now figure out what to do</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get pivoting indices to average over</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;orbital&#39;</span><span class="p">:</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2p</span><span class="p">(</span><span class="n">orbital</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;atom&#39;</span><span class="p">:</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbital</span><span class="p">))</span>
                <span class="c1"># Now sum the orbitals per atom</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">sumi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">a</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">NORM</span>

        <span class="c1"># atom is specified</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;orbital&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">]:</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2p</span><span class="p">(</span><span class="n">atom</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">NORM</span></div>

    <span class="k">def</span> <span class="nf">_DOS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">orbital</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Averages/sums the DOS</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of atoms (default to all).</span>
<span class="sd">           *NOT* allowed with `orbital` keyword</span>
<span class="sd">        orbital : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of orbitals (default to all)</span>
<span class="sd">           *NOT* allowed with `atom` keyword</span>
<span class="sd">        sum : bool, optional</span>
<span class="sd">           whether the returned quantities are summed or returned *as is*, i.e. resolved per atom/orbital.</span>
<span class="sd">        norm : {&#39;none&#39;, &#39;atom&#39;, &#39;orbital&#39;, &#39;all&#39;}</span>
<span class="sd">           how the normalization of the summed DOS is performed (see `norm` routine)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray : in order of the geometry orbitals (i.e. pivoted back to the device region).</span>
<span class="sd">                        If `atom` or `orbital` is specified they are returned in that order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">orbital</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Both atom and orbital keyword in DOS request &#39;</span>
                              <span class="s1">&#39;cannot be specified, only one at a time.&#39;</span><span class="p">))</span>
        <span class="c1"># Cast to lower</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="s1">&#39;orbital&#39;</span><span class="p">]:</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no_d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error on norm keyword in DOS request&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbital</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We simply return *everything*</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">sumd</span><span class="p">(</span><span class="n">DOS</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">NORM</span>
            <span class="c1"># We return the sorted DOS</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pivot</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="c1"># Now figure out what to do</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># orbital *must* be specified</span>

            <span class="c1"># Get pivoting indices to average over</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2p</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;orbital&#39;</span><span class="p">:</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;atom&#39;</span><span class="p">:</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbital</span><span class="p">))</span>
                <span class="c1"># Now sum the orbitals per atom</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">sumi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">a</span><span class="p">]))</span>

            <span class="k">if</span> <span class="nb">sum</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">sumd</span><span class="p">(</span><span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">NORM</span>
            <span class="c1"># Else, we have to return the full subset</span>
            <span class="k">return</span> <span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="c1"># atom is specified</span>
        <span class="c1"># Return the pivoting orbitals for the atom</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2p</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;orbital&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">]:</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">sum</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># Regardless of SUM, when requesting a single atom</span>
            <span class="c1"># we return it</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">sumd</span><span class="p">(</span><span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="c1"># We default the case where 1-orbital systems are in use</span>
        <span class="c1"># Then it becomes *very* easy</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="c1"># This is the multi-orbital case...</span>

        <span class="c1"># We will return per-atom</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">DOS</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nDOS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shp</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">atom</span><span class="p">)],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Quicker than re-creating the geometry on every instance</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span>

        <span class="c1"># Sum for new return stuff</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
            <span class="n">pvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2p</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nDOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nDOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">sumd</span><span class="p">(</span><span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">pvt</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="k">return</span> <span class="n">nDOS</span>

<div class="viewcode-block" id="tbtncSileTBtrans.DOS"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.DOS">[docs]</a>    <span class="k">def</span> <span class="nf">DOS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbital</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Green function density of states (DOS) (1/eV).</span>

<span class="sd">        Extract the DOS on a selected subset of atoms/orbitals in the device region</span>

<span class="sd">        .. math::</span>

<span class="sd">           \mathrm{DOS}(E) = -\frac{1}{\pi N} \sum_{\nu\in \mathrm{atom}/\mathrm{orbital}} \Im \mathbf{G}_{\nu\nu}(E)</span>

<span class="sd">        The normalization constant (:math:`N`) is defined in the routine `norm` and depends on the</span>
<span class="sd">        arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : float or int, optional</span>
<span class="sd">           optionally only return the DOS of atoms at a given energy point</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned DOS is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        atom : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of atoms (default to all).</span>
<span class="sd">           *NOT* allowed with `orbital` keyword</span>
<span class="sd">        orbital : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of orbitals (default to all)</span>
<span class="sd">           *NOT* allowed with `atom` keyword</span>
<span class="sd">        sum : bool, optional</span>
<span class="sd">           whether the returned quantities are summed or returned *as is*, i.e. resolved per atom/orbital.</span>
<span class="sd">        norm : {&#39;none&#39;, &#39;atom&#39;, &#39;orbital&#39;, &#39;all&#39;}</span>
<span class="sd">           how the normalization of the summed DOS is performed (see `norm` routine)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ADOS : the spectral density of states from an electrode</span>
<span class="sd">        BDOS : the bulk density of states in an electrode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DOS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="s1">&#39;DOS&#39;</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">),</span>
                                  <span class="n">atom</span><span class="p">,</span> <span class="n">orbital</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span> <span class="o">*</span> <span class="n">eV2Ry</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.ADOS"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.ADOS">[docs]</a>    <span class="k">def</span> <span class="nf">ADOS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbital</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Spectral density of states (DOS) (1/eV).</span>

<span class="sd">        Extract the spectral DOS from electrode `elec` on a selected subset of atoms/orbitals in the device region</span>

<span class="sd">        .. math::</span>
<span class="sd">           \mathrm{ADOS}_\mathfrak{el}(E) = \frac{1}{2\pi N} \sum_{\nu\in \mathrm{atom}/\mathrm{orbital}} [\mathbf{G}(E)\Gamma_\mathfrak{el}\mathbf{G}^\dagger]_{\nu\nu}(E)</span>

<span class="sd">        The normalization constant (:math:`N`) is defined in the routine `norm` and depends on the</span>
<span class="sd">        arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str, int, optional</span>
<span class="sd">           electrode originating spectral function</span>
<span class="sd">        E : float or int, optional</span>
<span class="sd">           optionally only return the DOS of atoms at a given energy point</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned DOS is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        atom : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of atoms (default to all).</span>
<span class="sd">           *NOT* allowed with `orbital` keyword</span>
<span class="sd">        orbital : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of orbitals (default to all)</span>
<span class="sd">           *NOT* allowed with `atom` keyword</span>
<span class="sd">        sum : bool, optional</span>
<span class="sd">           whether the returned quantities are summed or returned *as is*, i.e. resolved per atom/orbital.</span>
<span class="sd">        norm : {&#39;none&#39;, &#39;atom&#39;, &#39;orbital&#39;, &#39;all&#39;}</span>
<span class="sd">           how the normalization of the summed DOS is performed (see `norm` routine).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DOS : the total density of states (including bound states)</span>
<span class="sd">        BDOS : the bulk density of states in an electrode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DOS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="s1">&#39;ADOS&#39;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">),</span>
                         <span class="n">atom</span><span class="p">,</span> <span class="n">orbital</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span> <span class="o">*</span> <span class="n">eV2Ry</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.BDOS"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.BDOS">[docs]</a>    <span class="k">def</span> <span class="nf">BDOS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Bulk density of states (DOS) (1/eV).</span>

<span class="sd">        Extract the bulk DOS from electrode `elec` on a selected subset of atoms/orbitals in the device region</span>

<span class="sd">        .. math::</span>

<span class="sd">           \mathrm{BDOS}_\mathfrak{el}(E) = -\frac{1}{\pi} \Im\mathbf{G}(E)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str, int, optional</span>
<span class="sd">           electrode where the bulk DOS is returned</span>
<span class="sd">        E : float or int, optional</span>
<span class="sd">           optionally only return the DOS of atoms at a given energy point</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned DOS is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        sum : bool, optional</span>
<span class="sd">           whether the returned quantities are summed or returned *as is*, i.e. resolved per atom/orbital.</span>
<span class="sd">        norm : {&#39;none&#39;, &#39;atom&#39;, &#39;orbital&#39;, &#39;all&#39;}</span>
<span class="sd">           whether the returned quantities are summed or normed by total number of orbitals.</span>
<span class="sd">           Currently one cannot extract DOS per atom/orbital.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DOS : the total density of states (including bound states)</span>
<span class="sd">        ADOS : the spectral density of states from an electrode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The bulk DOS is already normalized per non-expanded cell</span>
        <span class="c1"># Hence the non-normalized quantity needs to be multiplied by</span>
        <span class="c1">#  product(bloch)</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="s1">&#39;orbital&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]:</span>
            <span class="c1"># This is normalized per non-expanded unit-cell, so no need to do Bloch</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">(</span><span class="s1">&#39;no_u&#39;</span><span class="p">,</span> <span class="n">elec</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">sumd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="s1">&#39;DOS&#39;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">eV2Ry</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="s1">&#39;DOS&#39;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">eV2Ry</span> <span class="o">*</span> <span class="n">N</span></div>

    <span class="k">def</span> <span class="nf">_E_T_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Internal routine for returning energies and transmission in a sorted array &quot;&quot;&quot;</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span>
        <span class="n">idx_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="c1"># Get transmission</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">E</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">],</span> <span class="n">T</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>

<div class="viewcode-block" id="tbtncSileTBtrans.current"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.current">[docs]</a>    <span class="k">def</span> <span class="nf">current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec_from</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">elec_to</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Current from `from` to `to` using the k-weights and energy spacings in the file.</span>

<span class="sd">        Calculates the current as:</span>

<span class="sd">        .. math::</span>
<span class="sd">           I(\mu_t - \mu_f) = \frac{e}{h}\int\!\mathrm{d}E\, T(E) [n_F(\mu_t, k_B T_t) - n_F(\mu_f, k_B T_f)]</span>

<span class="sd">        The chemical potential and the temperature are taken from this object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from: str, int, optional</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_to: str, int, optional</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned current is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        current_parameter : to explicitly set the electronic temperature and chemical potentials</span>
<span class="sd">        chemical_potential : routine that defines the chemical potential of the queried electrodes</span>
<span class="sd">        kT : routine that defines the electronic temperature of the queried electrodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="n">mu_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">kt_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kT</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">mu_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="n">kt_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kT</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_parameter</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">mu_f</span><span class="p">,</span> <span class="n">kt_f</span><span class="p">,</span>
                                      <span class="n">elec_to</span><span class="p">,</span> <span class="n">mu_t</span><span class="p">,</span> <span class="n">kt_t</span><span class="p">,</span> <span class="n">kavg</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.current_parameter"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.current_parameter">[docs]</a>    <span class="k">def</span> <span class="nf">current_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">,</span> <span class="n">mu_from</span><span class="p">,</span> <span class="n">kt_from</span><span class="p">,</span>
                          <span class="n">elec_to</span><span class="p">,</span> <span class="n">mu_to</span><span class="p">,</span> <span class="n">kt_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Current from `from` to `to` using the k-weights and energy spacings in the file.</span>

<span class="sd">        Calculates the current as:</span>

<span class="sd">        .. math::</span>
<span class="sd">           I(\mu_t - \mu_f) = \frac{e}{h}\int\!\mathrm{d}E\, T(E) [n_F(\mu_t, k_B T_t) - n_F(\mu_f, k_B T_f)]</span>

<span class="sd">        The chemical potential and the temperature are passed as arguments to</span>
<span class="sd">        this routine.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from: str, int</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        mu_from: float</span>
<span class="sd">           the chemical potential of the electrode (in eV)</span>
<span class="sd">        kt_from: float</span>
<span class="sd">           the electronic temperature of the electrode (in eV)</span>
<span class="sd">        elec_to: str, int</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        mu_to: float</span>
<span class="sd">           the chemical potential of the electrode (in eV)</span>
<span class="sd">        kt_to: float</span>
<span class="sd">           the electronic temperature of the electrode (in eV)</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned current is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        current : which calculates the current with the chemical potentials and temperatures set in the TBtrans calculation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="c1"># Get energies</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E_T_sorted</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="p">)</span>

        <span class="c1"># We expect the tbtrans calcluation was created with the simple</span>
        <span class="c1">#   mid-rule!</span>
        <span class="c1"># The mid-rule is equivalent to adding a dE = (E[1] - E[0]) / 2</span>
        <span class="c1"># to both ends.</span>
        <span class="n">dE</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check that the lower bound is sufficient</span>
        <span class="n">print_warning</span> <span class="o">=</span> <span class="n">mu_from</span> <span class="o">-</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span> <span class="ow">or</span> \
                        <span class="n">mu_to</span> <span class="o">-</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="mi">3</span>  <span class="o">&lt;</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">print_warning</span> <span class="o">=</span> <span class="n">mu_from</span> <span class="o">+</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="n">E</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span> <span class="ow">or</span> \
                        <span class="n">mu_to</span> <span class="o">+</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="mi">3</span>  <span class="o">&gt;</span> <span class="n">E</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span> <span class="ow">or</span> \
                        <span class="n">print_warning</span>
        <span class="k">if</span> <span class="n">print_warning</span><span class="p">:</span>
            <span class="c1"># We should pretty-print a table of data</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elec_from</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">elec_to</span><span class="p">),</span> <span class="mi">15</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;{:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;s} </span><span class="si">{:9.3f}</span><span class="s2"> : </span><span class="si">{:9.3f}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Energy range&#39;</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;{:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;s} </span><span class="si">{:9.3f}</span><span class="s2"> : </span><span class="si">{:9.3f}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">mu_from</span> <span class="o">-</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">mu_from</span> <span class="o">+</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;{:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;s} </span><span class="si">{:9.3f}</span><span class="s2"> : </span><span class="si">{:9.3f}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elec_to</span><span class="p">,</span> <span class="n">mu_to</span> <span class="o">-</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">mu_to</span> <span class="o">+</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">min_e</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mu_from</span> <span class="o">-</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">mu_to</span> <span class="o">-</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">max_e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mu_from</span> <span class="o">+</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">mu_to</span> <span class="o">+</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;{:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;s} </span><span class="si">{:9.3f}</span><span class="s2"> : </span><span class="si">{:9.3f}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;dFermi function&#39;</span><span class="p">,</span> <span class="n">min_e</span><span class="p">,</span> <span class="n">max_e</span><span class="p">)</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.current_parameter cannot &quot;</span>
                           <span class="s2">&quot;accurately calculate the current due to the calculated energy range. &quot;</span>
                           <span class="s2">&quot;I.e. increase your calculated energy-range.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">),</span>
                          <span class="ne">UserWarning</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">nf</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kT</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">E</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">kT</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>

        <span class="n">I</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">sumd</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="n">dE</span> <span class="o">*</span> <span class="p">(</span><span class="n">nf</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">mu_from</span><span class="p">,</span> <span class="n">kt_from</span><span class="p">)</span> <span class="o">-</span> <span class="n">nf</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">mu_to</span><span class="p">,</span> <span class="n">kt_to</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">I</span> <span class="o">*</span> <span class="mf">1.6021766208e-19</span> <span class="o">/</span> <span class="mf">4.135667662e-15</span></div>

    <span class="k">def</span> <span class="nf">_sparse_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Internal routine for retrieving sparse data (orbital current, COOP) &quot;&quot;&quot;</span>
        <span class="c1"># Get the geometry for obtaining the sparsity pattern.</span>
        <span class="k">if</span> <span class="n">elec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span>

        <span class="c1"># These are the row-pointers...</span>
        <span class="n">rptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(</span><span class="s1">&#39;n_col&#39;</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Get column indices</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(</span><span class="s1">&#39;list_col&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Default matrix size</span>
        <span class="n">mat_size</span> <span class="o">=</span> <span class="p">[</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span><span class="p">]</span>

        <span class="c1"># Figure out the super-cell indices that are requested</span>
        <span class="c1"># First we figure out the indices, then</span>
        <span class="c1"># we build the array of allowed columns</span>
        <span class="k">if</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">isc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_col</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The user has requested specific supercells</span>
            <span class="c1"># Here we create a list of supercell interactions.</span>

            <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>
            <span class="c1"># Shorten to the unit-cell if there are no more</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Small function for creating the supercells allowed</span>
            <span class="k">def</span> <span class="nf">ret_range</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">req</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">val</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">req</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">ret_range</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">isc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">ret_range</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">isc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ret_range</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">isc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># Make a shrinking logical array for selecting a subset of the</span>
            <span class="c1"># orbital currents...</span>
            <span class="n">all_col</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)):</span>
                <span class="n">all_col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc_index</span><span class="p">([</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">])</span>

            <span class="c1"># If the user requests a single supercell index, we will</span>
            <span class="c1"># return a square matrix</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_col</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mat_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Transfer all_col to the range</span>
            <span class="n">all_col</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">all_col</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">,</span>
                                   <span class="n">n</span><span class="o">=</span><span class="n">_a</span><span class="o">.</span><span class="n">fulli</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_col</span><span class="p">),</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">))</span>

            <span class="c1"># Create a logical array for sub-indexing</span>
            <span class="n">all_col</span> <span class="o">=</span> <span class="n">in1d</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">all_col</span><span class="p">))</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">all_col</span><span class="p">]</span>

            <span class="c1"># recreate row-pointer</span>
            <span class="n">cnz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span>
            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">ptr1</span><span class="p">,</span> <span class="n">ptr2</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cnz</span><span class="p">(</span><span class="n">all_col</span><span class="p">[</span><span class="n">ptr1</span><span class="p">:</span><span class="n">ptr2</span><span class="p">])</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">rptr</span><span class="p">[:</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">],</span> <span class="n">rptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">rptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">tmp</span>

        <span class="k">if</span> <span class="n">all_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">all_col</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="n">mat_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sparse_data_orb_to_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dij</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reduce orbital sparse data to atomic sparse data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dij : scipy.sparse.csr_matrix</span>
<span class="sd">           the input data</span>
<span class="sd">        uc : bool, optional</span>
<span class="sd">           whether the returned data are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `Geometry.sc_index`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span>
        <span class="n">na</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
        <span class="n">o2a</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">uc</span><span class="p">:</span>
            <span class="n">uc</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Dij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># We convert to atomic bond-currents</span>
        <span class="k">if</span> <span class="n">uc</span><span class="p">:</span>
            <span class="n">Dab</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Dij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">map_col</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">o2a</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="n">na</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">Dab</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Dij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">map_col</span> <span class="o">=</span> <span class="n">o2a</span>

        <span class="c1"># Lets do array notation for speeding up the computations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isspmatrix_csr</span><span class="p">(</span><span class="n">Dij</span><span class="p">):</span>
            <span class="n">Dij</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="c1"># Check for the simple case of 1-orbital systems</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">:</span>
            <span class="c1"># In this case it is extremely easy!</span>
            <span class="c1"># Just copy to the new data</span>

            <span class="c1"># Transfer all columns to the new columns</span>
            <span class="n">Dab</span><span class="o">.</span><span class="n">indptr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">indptr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">uc</span><span class="p">:</span>
                <span class="n">Dab</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dij</span><span class="o">.</span><span class="n">indices</span> <span class="o">%</span> <span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Dab</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The multi-orbital case</span>

            <span class="c1"># Loop all atoms to make the new pointer array</span>
            <span class="c1"># I.e. a consecutive array of pointers starting from</span>
            <span class="c1">#   firsto[.] .. lasto[.]</span>
            <span class="n">iptr</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">indptr</span>
            <span class="c1"># Get first orbital</span>
            <span class="n">fo</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span>
            <span class="c1"># Automatically create the new index pointer</span>
            <span class="c1"># from first and last orbital</span>
            <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">iptr</span><span class="p">[</span><span class="n">fo</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">-</span> <span class="n">iptr</span><span class="p">[</span><span class="n">fo</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Now we have a new indptr, and the column indices have also</span>
            <span class="c1"># been processed.</span>
            <span class="n">Dab</span><span class="o">.</span><span class="n">indptr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">indptr</span><span class="p">[:]</span>
            <span class="c1"># Transfer all columns to the new columns</span>
            <span class="n">Dab</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">map_col</span><span class="p">(</span><span class="n">Dij</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Copy data</span>
        <span class="n">Dab</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Dij</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># Note that we do not sum duplicates as that depends on the next routine</span>
        <span class="c1"># I.e. sometimes we want to remove negative values, etc.</span>
        <span class="k">return</span> <span class="n">Dab</span>

<div class="viewcode-block" id="tbtncSileTBtrans.orbital_current"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_current">[docs]</a>    <span class="k">def</span> <span class="nf">orbital_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Orbital current originating from `elec` as a sparse matrix</span>

<span class="sd">        This will return a sparse matrix, see ``scipy.sparse.csr_matrix`` for details.</span>
<span class="sd">        Each matrix element of the sparse matrix corresponds to the orbital indices of the</span>
<span class="sd">        underlying geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str, int</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or the energy index of the orbital current. If an integer</span>
<span class="sd">           is passed it is the index, otherwise the index corresponding to</span>
<span class="sd">           ``Eindex(E)`` is used.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned orbital current is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned bond currents from the unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all orbital currents for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        take : {&#39;all&#39;, &#39;+&#39;, &#39;-&#39;}</span>
<span class="sd">           which orbital currents to return, all, positive or negative values only.</span>
<span class="sd">           Default to ``&#39;all&#39;`` because it can then be used in the subsequent default</span>
<span class="sd">           arguments for `bond_current_from_orbital` and `atom_current_from_orbital`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_current(0, -1.0) # orbital current @ E = -1 eV originating from electrode ``0`` # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; Jij[10, 11] # orbital current from the 11th to the 12th orbital # doctest: +SKIP</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        bond_current_from_orbital : transfer the orbital current to bond current</span>
<span class="sd">        bond_current : the bond current (orbital current summed over orbitals)</span>
<span class="sd">        atom_current_from_orbital : transfer the orbital current to atomic current</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">take</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">J</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">J</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">take</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">J</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">J</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">take</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.orbital_current &quot;take&quot; keyword has &#39;</span>
                             <span class="s1">&#39;wrong value [&quot;all&quot;, &quot;+&quot;, &quot;-&quot;] allowed.&#39;</span><span class="p">)</span>

        <span class="c1"># We will always remove the zeroes and sort the indices... (they should be sorted anyways)</span>
        <span class="n">J</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">()</span>
        <span class="n">J</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">J</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.bond_current_from_orbital"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.bond_current_from_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">bond_current_from_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Jij</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Bond-current between atoms (sum of orbital currents) from an external orbital current</span>

<span class="sd">        Conversion routine from orbital currents into bond currents.</span>

<span class="sd">        The bond currents are a sum over all orbital currents:</span>

<span class="sd">        .. math::</span>
<span class="sd">           J_{\alpha\beta} = \sum_{\nu\in\alpha}\sum_{\mu\in\beta} J_{\nu\mu}</span>

<span class="sd">        where if</span>

<span class="sd">        * ``sum=&#39;+&#39;``:</span>
<span class="sd">          only :math:`J_{\nu\mu} &gt; 0` are summed,</span>
<span class="sd">        * ``sum=&#39;-&#39;``:</span>
<span class="sd">          only :math:`J_{\nu\mu} &lt; 0` are summed,</span>
<span class="sd">        * ``sum=&#39;all&#39;``:</span>
<span class="sd">          all :math:`J_{\nu\mu}` are summed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Jij : scipy.sparse.csr_matrix</span>
<span class="sd">           the orbital currents as retrieved from `orbital_current`</span>
<span class="sd">        sum : {&#39;+&#39;, &#39;all&#39;, &#39;-&#39;}</span>
<span class="sd">           If &quot;+&quot; is supplied only the positive orbital currents are used,</span>
<span class="sd">           for &quot;-&quot;, only the negative orbital currents are used,</span>
<span class="sd">           else return both.</span>
<span class="sd">        uc : bool, optional</span>
<span class="sd">           whether the returned bond-currents are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `Geometry.sc_index`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_current(0, -1.0) # orbital current @ E = -1 eV originating from electrode ``0`` # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; Jab = tbt.bond_current_from_orbital(Jij) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; Jab[2,3] # bond current between atom 3 and 4 # doctest: +SKIP</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_current : the orbital current between individual orbitals</span>
<span class="sd">        bond_current : the bond current (orbital current summed over orbitals)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Jab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data_orb_to_atom</span><span class="p">(</span><span class="n">Jij</span><span class="p">,</span> <span class="n">uc</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">Jab</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Jab</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Jab</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">Jab</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">sum</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">Jab</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Jab</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Jab</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">Jab</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">sum</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.bond_current_from_orbital &quot;sum&quot; keyword has &#39;</span>
                             <span class="s1">&#39;wrong value [&quot;+&quot;, &quot;-&quot;, &quot;all&quot;] allowed.&#39;</span><span class="p">)</span>

        <span class="c1"># Do in-place operations by removing all the things not required</span>
        <span class="n">Jab</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">()</span>
        <span class="n">Jab</span><span class="o">.</span><span class="n">sum_duplicates</span><span class="p">()</span>
        <span class="n">Jab</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Jab</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.bond_current"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.bond_current">[docs]</a>    <span class="k">def</span> <span class="nf">bond_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Bond-current between atoms (sum of orbital currents)</span>

<span class="sd">        Short hand function for calling `orbital_current` and `bond_current_from_orbital`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : str, int</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        E : float or int</span>
<span class="sd">           A `float` for energy in eV, `int` for explicit energy index</span>
<span class="sd">           Unlike `orbital_current` this may not be `None` as the down-scaling of the</span>
<span class="sd">           orbital currents may not be equivalent for all energy points.</span>
<span class="sd">        kavg : bool, int or array_like, optional</span>
<span class="sd">           whether the returned bond current is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc : array_like, optional</span>
<span class="sd">           the returned bond currents from the unit-cell (``[None, None, None]``) (default) to</span>
<span class="sd">           the given supercell. If ``[None, None, None]`` is passed all</span>
<span class="sd">           bond currents are returned.</span>
<span class="sd">        sum : {&#39;+&#39;, &#39;all&#39;, &#39;-&#39;}</span>
<span class="sd">           If &quot;+&quot; is supplied only the positive orbital currents are used,</span>
<span class="sd">           for &quot;-&quot;, only the negative orbital currents are used,</span>
<span class="sd">           else return the sum of both.</span>
<span class="sd">        uc : bool, optional</span>
<span class="sd">           whether the returned bond-currents are only in the unit-cell.</span>
<span class="sd">           If `True` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `Geometry.sc_index`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_current(0, -1.0) # orbital current @ E = -1 eV originating from electrode ``0`` # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; Jab1 = tbt.bond_current_from_orbital(Jij) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; Jab2 = tbt.bond_current(0, -1.0) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; Jab1 == Jab2 # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_current : the orbital current between individual orbitals</span>
<span class="sd">        bond_current_from_orbital : transfer the orbital current to bond current</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="n">Jij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_current</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_current_from_orbital</span><span class="p">(</span><span class="n">Jij</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="n">uc</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.atom_current_from_orbital"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_current_from_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">atom_current_from_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Jij</span><span class="p">,</span> <span class="n">activity</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Atomic current of atoms by passing the orbital current</span>

<span class="sd">        The atomic current is a single number specifying a figure of the *magnitude*</span>
<span class="sd">        current flowing through each atom. It is thus *not* a quantity that can be related to</span>
<span class="sd">        the physical current flowing in/out of atoms but is merely a number that provides an</span>
<span class="sd">        idea of *how much* current this atom is redistributing.</span>

<span class="sd">        The atomic current may have two meanings based on these two equations</span>

<span class="sd">        .. math::</span>
<span class="sd">            J_\alpha^{|a|} &amp;=\frac{1}{2} \sum_\beta \Big| \sum_{\nu\in \alpha}\sum_{\mu\in \beta} J_{\nu\mu} \Big|</span>
<span class="sd">            \\</span>
<span class="sd">            J_\alpha^{|o|} &amp;=\frac{1}{2} \sum_\beta \sum_{\nu\in \alpha}\sum_{\mu\in \beta} \big| J_{\nu\mu} \big|</span>

<span class="sd">        If the *activity* current is requested (``activity=True``)</span>
<span class="sd">        :math:`J_\alpha^{\mathcal A} = \sqrt{ J_\alpha^{|a|} J_\alpha^{|o|} }` is returned.</span>

<span class="sd">        If ``activity=False`` :math:`J_\alpha^{|a|}` is returned.</span>

<span class="sd">        For geometries with all atoms only having 1-orbital, they are equivalent.</span>

<span class="sd">        Generally the activity current is a more rigorous figure of merit for the current</span>
<span class="sd">        flowing through an atom. More so than than the summed absolute atomic current due to</span>
<span class="sd">        the following reasoning. The activity current is a geometric mean of the absolute bond current</span>
<span class="sd">        and the absolute orbital current. This means that if there is an atom with a large orbital current</span>
<span class="sd">        it will have a larger activity current.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Jij: scipy.sparse.csr_matrix</span>
<span class="sd">           the orbital currents as retrieved from `orbital_current`</span>
<span class="sd">        activity: bool, optional</span>
<span class="sd">           ``True`` to return the activity current, see explanation above</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_current(0, -1.03) # orbital current @ E = -1 eV originating from electrode ``0`` # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; Ja = tbt.atom_current_from_orbital(Jij) # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the bond-currents with all summations</span>
        <span class="n">Jab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_current_from_orbital</span><span class="p">(</span><span class="n">Jij</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="c1"># We take the absolute and sum it over all connecting atoms</span>
        <span class="n">Ja</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Jab</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">activity</span><span class="p">:</span>
            <span class="c1"># Calculate the absolute summation of all orbital</span>
            <span class="c1"># currents and transfer it to a bond-current</span>
            <span class="n">Jab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_current_from_orbital</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Jij</span><span class="p">),</span> <span class="nb">sum</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

            <span class="c1"># Sum to make it per atom, it is already the absolute</span>
            <span class="n">Jo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Jab</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="c1"># Return the geometric mean of the atomic current X orbital</span>
            <span class="c1"># current.</span>
            <span class="n">Ja</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ja</span> <span class="o">*</span> <span class="n">Jo</span><span class="p">)</span>

        <span class="c1"># Scale correctly</span>
        <span class="n">Ja</span> <span class="o">*=</span> <span class="mf">0.5</span>

        <span class="k">return</span> <span class="n">Ja</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.atom_current"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_current">[docs]</a>    <span class="k">def</span> <span class="nf">atom_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">activity</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Atomic current of atoms</span>

<span class="sd">        Short hand function for calling `orbital_current` and `atom_current_from_orbital`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str, int</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or energy index of the atom current.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned atomic current is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        activity: bool, optional</span>
<span class="sd">           whether the activity current is returned, see `atom_current_from_orbital` for details.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_current : the orbital current between individual orbitals</span>
<span class="sd">        bond_current_from_orbital : transfer the orbital current to bond current</span>
<span class="sd">        bond_current : the bond current (orbital current summed over orbitals)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="n">Jorb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_current</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_current_from_orbital</span><span class="p">(</span><span class="n">Jorb</span><span class="p">,</span> <span class="n">activity</span><span class="o">=</span><span class="n">activity</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.vector_current_from_bond"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.vector_current_from_bond">[docs]</a>    <span class="k">def</span> <span class="nf">vector_current_from_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Jab</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Vector for each atom being the sum of bond-current times the normalized bond between the atoms</span>

<span class="sd">        The vector current is defined as:</span>

<span class="sd">        .. math::</span>
<span class="sd">              \mathbf J_\alpha = \sum_\beta \frac{r_\beta - r_\alpha}{|r_\beta - r_\alpha|} \cdot J_{\alpha\beta}</span>

<span class="sd">        Where :math:`J_{\alpha\beta}` is the bond current between atom :math:`\alpha` and :math:`\beta` and</span>
<span class="sd">        :math:`r_\alpha` are the atomic coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Jab: scipy.sparse.csr_matrix</span>
<span class="sd">           the bond currents as retrieved from `bond_current`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray : an array of vectors per atom in the Geometry (only non-zero for device atoms)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_current : the orbital current between individual orbitals</span>
<span class="sd">        bond_current_from_orbital : transfer the orbital current to bond current</span>
<span class="sd">        bond_current : the bond current (orbital current summed over orbitals)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span>

        <span class="n">na</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
        <span class="c1"># vector currents</span>
        <span class="n">Ja</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="n">na</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

        <span class="c1"># Short-hand</span>
        <span class="n">sqrt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span>

        <span class="c1"># Loop atoms in the device region</span>
        <span class="c1"># These are the only atoms which may have bond-currents,</span>
        <span class="c1"># So no need to loop over any other atoms</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_dev</span><span class="p">:</span>
            <span class="c1"># Get csr matrix</span>
            <span class="n">Jia</span> <span class="o">=</span> <span class="n">Jab</span><span class="o">.</span><span class="n">getrow</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>

            <span class="c1"># Set diagonal to zero</span>
            <span class="n">Jia</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="c1"># Remove the diagonal (prohibits the calculation of the</span>
            <span class="c1"># norm of the zero vector, hence required)</span>
            <span class="n">Jia</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

            <span class="c1"># Now calculate the vector elements</span>
            <span class="c1"># Remark that the vector goes from ia -&gt; ja</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">Jia</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">rv</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">Ja</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jia</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">rv</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Ja</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.vector_current"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.vector_current">[docs]</a>    <span class="k">def</span> <span class="nf">vector_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Vector for each atom describing the *mean* path for the current travelling through the atom</span>

<span class="sd">        See `vector_current_from_bond` for details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str or int</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or energy index of the vector current.</span>
<span class="sd">           Unlike `orbital_current` this may not be `None` as the down-scaling of the</span>
<span class="sd">           orbital currents may not be equivalent for all energy points.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned vector current is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        sum : {&#39;+&#39;, &#39;-&#39;, &#39;all&#39;}</span>
<span class="sd">           By default only sum *outgoing* vector currents (``&#39;+&#39;``).</span>
<span class="sd">           The *incoming* vector currents may be retrieved by ``&#39;-&#39;``, while the</span>
<span class="sd">           average incoming and outgoing direction can be obtained with ``&#39;all&#39;``.</span>
<span class="sd">           In the last case the vector currents are divided by 2 to ensure the length</span>
<span class="sd">           of the vector is compatibile with the other options given a pristine system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray : an array of vectors per atom in the Geometry (only non-zero for device atoms)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_current : the orbital current between individual orbitals</span>
<span class="sd">        bond_current_from_orbital : transfer the orbital current to bond current</span>
<span class="sd">        bond_current : the bond current (orbital current summed over orbitals)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="c1"># Imperative that we use the entire supercell structure to</span>
        <span class="c1"># retain vectors crossing the boundaries</span>
        <span class="n">Jab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_current</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="nb">sum</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="c1"># When we divide by two one can *always* compare the bulk</span>
            <span class="c1"># vector currents using either of the sum-rules.</span>
            <span class="c1"># I.e. it will be much easier to distinguish differences</span>
            <span class="c1"># between &quot;incoming&quot; and &quot;outgoing&quot;.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_current_from_bond</span><span class="p">(</span><span class="n">Jab</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_current_from_bond</span><span class="p">(</span><span class="n">Jab</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.orbital_COOP"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_COOP">[docs]</a>    <span class="k">def</span> <span class="nf">orbital_COOP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Orbital COOP analysis of the Green function</span>

<span class="sd">        This will return a sparse matrix, see ``scipy.sparse.csr_matrix`` for details.</span>
<span class="sd">        Each matrix element of the sparse matrix corresponds to the COOP of the</span>
<span class="sd">        underlying geometry.</span>

<span class="sd">        The COOP analysis can be written as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COOP}^{\mathbf G}_{\nu\mu} &amp;= \frac{-1}{2\pi}</span>
<span class="sd">              \Im\big[(\mathbf G - \mathbf G^\dagger)_{\nu\mu} \mathbf S_{\mu\nu} \big]</span>

<span class="sd">        The sum of the COOP DOS is equal to the DOS:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{DOS}_{\nu} &amp;= \sum_\mu \mathrm{COOP}^{\mathbf G}_{\nu\mu}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or the energy index of COOP. If an integer</span>
<span class="sd">           is passed it is the index, otherwise the index corresponding to</span>
<span class="sd">           ``Eindex(E)`` is used.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned COOP is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COOP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COOP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; COOP = tbt.orbital_COOP(-1.0) # COOP @ E = -1 eV  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; COOP[10, 11] # COOP value between the 11th and 12th orbital</span>
<span class="sd">        &gt;&gt;&gt; COOP.sum(1).A[tbt.o_dev, 0] == tbt.DOS(sum=False)[tbt.Eindex(-1.0)]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        atom_COOP_from_orbital : transfer an orbital COOP to atomic COOP</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP_from_orbital : atomic COHP analysis from an orbital COHP</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_ACOOP</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.orbital_ACOOP"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_ACOOP">[docs]</a>    <span class="k">def</span> <span class="nf">orbital_ACOOP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Orbital COOP analysis of the spectral function</span>

<span class="sd">        This will return a sparse matrix, see ``scipy.sparse.csr_matrix`` for details.</span>
<span class="sd">        Each matrix element of the sparse matrix corresponds to the COOP of the</span>
<span class="sd">        underlying geometry.</span>

<span class="sd">        The COOP analysis can be written as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COOP}^{\mathbf A}_{\nu\mu} &amp;= \frac{1}{2\pi} \Re\big[\mathbf A_{\nu\mu} \mathbf S_{\mu\nu} \big]</span>

<span class="sd">        The sum of the COOP DOS is equal to the DOS:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{ADOS}_{\nu} &amp;= \sum_\mu \mathrm{COOP}^{\mathbf A}_{\nu\mu}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str or int</span>
<span class="sd">           the electrode of the spectral function</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or the energy index of COOP. If an integer</span>
<span class="sd">           is passed it is the index, otherwise the index corresponding to</span>
<span class="sd">           ``Eindex(E)`` is used.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned COOP is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COOP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COOP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; COOP = tbt.orbital_ACOOP(0, -1.0) # COOP @ E = -1 eV from ``0`` spectral function # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; COOP[10, 11] # COOP value between the 11th and 12th orbital</span>
<span class="sd">        &gt;&gt;&gt; COOP.sum(1).A[tbt.o_dev, 0] == tbt.ADOS(0, sum=False)[tbt.Eindex(-1.0)]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP_from_orbital : transfer an orbital COOP to atomic COOP</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP_from_orbital : atomic COHP analysis from an orbital COHP</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">COOP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data</span><span class="p">(</span><span class="s1">&#39;COOP&#39;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">eV2Ry</span>
        <span class="n">COOP</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">()</span>
        <span class="n">COOP</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">COOP</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.atom_COOP_from_orbital"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_COOP_from_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">atom_COOP_from_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">COOP</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculate the atomic COOP curve from the orbital COOP</span>

<span class="sd">        The atomic COOP are a sum over all orbital COOP:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COOP}_{\alpha\beta} = \sum_{\nu\in\alpha}\sum_{\mu\in\beta} \mathrm{COOP}_{\nu\mu}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        COOP : scipy.sparse.csr_matrix</span>
<span class="sd">           the orbital COOP as retrieved from `orbital_COOP` or `orbital_ACOOP`</span>
<span class="sd">        uc : bool, optional</span>
<span class="sd">           whether the returned COOP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">COOP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data_orb_to_atom</span><span class="p">(</span><span class="n">COOP</span><span class="p">,</span> <span class="n">uc</span><span class="p">)</span>
        <span class="n">COOP</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">()</span>
        <span class="n">COOP</span><span class="o">.</span><span class="n">sum_duplicates</span><span class="p">()</span>
        <span class="n">COOP</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">COOP</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.atom_COOP"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_COOP">[docs]</a>    <span class="k">def</span> <span class="nf">atom_COOP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Atomic COOP curve of the Green function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or the energy index of COOP. If an integer</span>
<span class="sd">           is passed it is the index, otherwise the index corresponding to</span>
<span class="sd">           ``Eindex(E)`` is used.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned COOP is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COOP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COOP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        uc : bool, optional</span>
<span class="sd">           whether the returned COOP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP_from_orbital : transfer an orbital COOP to atomic COOP</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_ACOOP</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">uc</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.atom_ACOOP"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_ACOOP">[docs]</a>    <span class="k">def</span> <span class="nf">atom_ACOOP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Atomic COOP curve of the spectral function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str or int</span>
<span class="sd">           the electrode of the spectral function</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or the energy index of COOP. If an integer</span>
<span class="sd">           is passed it is the index, otherwise the index corresponding to</span>
<span class="sd">           ``Eindex(E)`` is used.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned COOP is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COOP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COOP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        uc : bool, optional</span>
<span class="sd">           whether the returned COOP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP_from_orbital : transfer an orbital COOP to atomic COOP</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">COOP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_ACOOP</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_COOP_from_orbital</span><span class="p">(</span><span class="n">COOP</span><span class="p">,</span> <span class="n">uc</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.orbital_COHP"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_COHP">[docs]</a>    <span class="k">def</span> <span class="nf">orbital_COHP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Orbital resolved COHP analysis of the Green function</span>

<span class="sd">        This will return a sparse matrix, see ``scipy.sparse.csr_matrix`` for details.</span>
<span class="sd">        Each matrix element of the sparse matrix corresponds to the COHP of the</span>
<span class="sd">        underlying geometry.</span>

<span class="sd">        The COHP analysis can be written as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COHP}^{\mathbf G}_{\nu\mu} &amp;= \frac{-1}{2\pi}</span>
<span class="sd">              \Im\big[(\mathbf G - \mathbf G^\dagger)_{\nu\mu} \mathbf H_{\mu\nu} \big]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or the energy index of COHP. If an integer</span>
<span class="sd">           is passed it is the index, otherwise the index corresponding to</span>
<span class="sd">           ``Eindex(E)`` is used.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned COHP is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COHP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COHP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; COHP = tbt.orbital_COHP(-1.0) # COHP @ E = -1 eV  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; COHP[10, 11] # COHP value between the 11th and 12th orbital</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        atom_COHP_from_orbital : atomic COHP analysis from an orbital COHP</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP_from_orbital : transfer an orbital COOP to atomic COOP</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_ACOHP</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.orbital_ACOHP"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_ACOHP">[docs]</a>    <span class="k">def</span> <span class="nf">orbital_ACOHP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Orbital resolved COHP analysis of the spectral function</span>

<span class="sd">        This will return a sparse matrix, see ``scipy.sparse.csr_matrix`` for details.</span>
<span class="sd">        Each matrix element of the sparse matrix corresponds to the COHP of the</span>
<span class="sd">        underlying geometry.</span>

<span class="sd">        The COHP analysis can be written as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COHP}^{\mathbf A}_{\nu\mu} &amp;= \frac{1}{2\pi} \Re\big[\mathbf A_{\nu\mu}</span>
<span class="sd">                \mathbf H_{\nu\mu} \big]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str or int</span>
<span class="sd">           the electrode of the spectral function</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or the energy index of COHP. If an integer</span>
<span class="sd">           is passed it is the index, otherwise the index corresponding to</span>
<span class="sd">           ``Eindex(E)`` is used.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned COHP is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COHP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COHP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP_from_orbital : atomic COHP analysis from an orbital COHP</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP_from_orbital : transfer an orbital COOP to atomic COOP</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">COHP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data</span><span class="p">(</span><span class="s1">&#39;COHP&#39;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span>
        <span class="n">COHP</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">()</span>
        <span class="n">COHP</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">COHP</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.atom_COHP_from_orbital"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_COHP_from_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">atom_COHP_from_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">COHP</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculate the atomic COHP curve from the orbital COHP</span>

<span class="sd">        The atomic COHP are a sum over all orbital COHP:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COHP}_{\alpha\beta} = \sum_{\nu\in\alpha}\sum_{\mu\in\beta} \mathrm{COHP}_{\nu\mu}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        COHP : scipy.sparse.csr_matrix</span>
<span class="sd">           the orbital COHP as retrieved from `orbital_COHP` or `orbital_ACOHP`</span>
<span class="sd">        uc : bool, optional</span>
<span class="sd">           whether the returned COHP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_COOP_from_orbital</span><span class="p">(</span><span class="n">COHP</span><span class="p">,</span> <span class="n">uc</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.atom_COHP"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_COHP">[docs]</a>    <span class="k">def</span> <span class="nf">atom_COHP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Atomic COHP curve of the Green function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or the energy index of COHP. If an integer</span>
<span class="sd">           is passed it is the index, otherwise the index corresponding to</span>
<span class="sd">           ``Eindex(E)`` is used.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned COHP is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COHP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COHP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        uc : bool, optional</span>
<span class="sd">           whether the returned COHP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP_from_orbital : transfer an orbital COHP to atomic COHP</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_ACOHP</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">uc</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.atom_ACOHP"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_ACOHP">[docs]</a>    <span class="k">def</span> <span class="nf">atom_ACOHP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Atomic COHP curve of the spectral function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec: str or int</span>
<span class="sd">           the electrode of the spectral function</span>
<span class="sd">        E: float or int</span>
<span class="sd">           the energy or the energy index of COHP. If an integer</span>
<span class="sd">           is passed it is the index, otherwise the index corresponding to</span>
<span class="sd">           ``Eindex(E)`` is used.</span>
<span class="sd">        kavg: bool, int or array_like, optional</span>
<span class="sd">           whether the returned COHP is k-averaged, an explicit k-point</span>
<span class="sd">           or a selection of k-points</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COHP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COHP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        uc : bool, optional</span>
<span class="sd">           whether the returned COHP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP_from_orbital : transfer an orbital COHP to atomic COHP</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">COHP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_ACOHP</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_COHP_from_orbital</span><span class="p">(</span><span class="n">COHP</span><span class="p">,</span> <span class="n">uc</span><span class="p">)</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.read_data"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.read_data">[docs]</a>    <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read specific type of data.</span>

<span class="sd">        This is a generic routine for reading different parts of the data-file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geom: bool, optional</span>
<span class="sd">           return the geometry</span>
<span class="sd">        atom_current: bool, optional</span>
<span class="sd">           return the atomic current flowing through an atom (the *activity* current)</span>
<span class="sd">        vector_current: bool, optional</span>
<span class="sd">           return the orbital currents as vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]:</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">())</span>

            <span class="k">elif</span> <span class="n">kw</span> <span class="o">==</span> <span class="s1">&#39;atom_current&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]:</span>
                    <span class="c1"># TODO we need some way of handling arguments.</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_current</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">kw</span> <span class="o">==</span> <span class="s1">&#39;vector_current&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]:</span>
                    <span class="c1"># TODO we need some way of handling arguments.</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_current</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">val</span></div>

<div class="viewcode-block" id="tbtncSileTBtrans.info"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Information about the calculated quantities available for extracting in this file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : str or int</span>
<span class="sd">           the electrode to request information from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">elec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>

        <span class="c1"># Create a StringIO object to retain the information</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="c1"># Create wrapper function</span>
        <span class="k">def</span> <span class="nf">prnt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">truefalse</span><span class="p">(</span><span class="n">bol</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">fdf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bol</span><span class="p">:</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  + &quot;</span> <span class="o">+</span> <span class="n">string</span> <span class="o">+</span> <span class="s2">&quot;: true&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fdf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - &quot;</span> <span class="o">+</span> <span class="n">string</span> <span class="o">+</span> <span class="s2">&quot;: false&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - &quot;</span> <span class="o">+</span> <span class="n">string</span> <span class="o">+</span> <span class="s2">&quot;: false</span><span class="se">\t\t</span><span class="s2">[&quot;</span><span class="o">+</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fdf</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span><span class="p">)</span>

        <span class="c1"># Retrieve the device atoms</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;Device information:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_avg</span><span class="p">:</span>
            <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - all data is k-averaged&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Print out some more information related to the</span>
            <span class="c1"># k-point sampling.</span>
            <span class="c1"># However, we still do not know whether TRS is</span>
            <span class="c1"># applied.</span>
            <span class="n">kpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">nA</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">kpt</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">nB</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">kpt</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="n">nC</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">kpt</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>
            <span class="n">prnt</span><span class="p">((</span><span class="s2">&quot;  - number of kpoints: </span><span class="si">{}</span><span class="s2"> &lt;- &quot;</span>
                   <span class="s2">&quot;[ A = </span><span class="si">{}</span><span class="s2"> , B = </span><span class="si">{}</span><span class="s2"> , C = </span><span class="si">{}</span><span class="s2"> ] (time-reversal unknown)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nk</span><span class="p">,</span> <span class="n">nA</span><span class="p">,</span> <span class="n">nB</span><span class="p">,</span> <span class="n">nC</span><span class="p">))</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - energy range:&quot;</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span>
        <span class="n">Em</span><span class="p">,</span> <span class="n">EM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dEm</span><span class="p">,</span> <span class="n">dEM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">dE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">dE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span> <span class="c1"># convert to meV</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dEM</span> <span class="o">-</span> <span class="n">dEm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">:</span> <span class="c1"># 0.001 meV</span>
            <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;     </span><span class="si">{:.5f}</span><span class="s2"> -- </span><span class="si">{:.5f}</span><span class="s2"> eV  [</span><span class="si">{:.3f}</span><span class="s2"> meV]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Em</span><span class="p">,</span> <span class="n">EM</span><span class="p">,</span> <span class="n">dEm</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;     </span><span class="si">{:.5f}</span><span class="s2"> -- </span><span class="si">{:.5f}</span><span class="s2"> eV  [</span><span class="si">{:.3f}</span><span class="s2"> -- </span><span class="si">{:.3f}</span><span class="s2"> meV]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Em</span><span class="p">,</span> <span class="n">EM</span><span class="p">,</span> <span class="n">dEm</span><span class="p">,</span> <span class="n">dEM</span><span class="p">))</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - atoms with DOS (fortran indices):&quot;</span><span class="p">)</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;     &quot;</span> <span class="o">+</span> <span class="n">list2str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_dev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">truefalse</span><span class="p">(</span><span class="s1">&#39;DOS&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;DOS Green function&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TBT.DOS.Gf&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">elec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">elec</span><span class="p">]</span>

        <span class="c1"># Print out information for each electrode</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">elecs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">bloch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(</span><span class="s1">&#39;bloch&#39;</span><span class="p">,</span> <span class="n">elec</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">bloch</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
                <span class="n">prnt</span><span class="p">()</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;Electrode: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elec</span><span class="p">))</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - Bloch: [</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">bloch</span><span class="p">))</span>
                <span class="n">gelec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - chemical potential: </span><span class="si">{:.4f}</span><span class="s2"> eV&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec</span><span class="p">)))</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - electronic temperature: </span><span class="si">{:.2f}</span><span class="s2"> K&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">electronic_temperature</span><span class="p">(</span><span class="n">elec</span><span class="p">)))</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - imaginary part: </span><span class="si">{:.4f}</span><span class="s2"> meV&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e3</span><span class="p">))</span>
                <span class="n">truefalse</span><span class="p">(</span><span class="s1">&#39;DOS&#39;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;DOS bulk&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TBT.DOS.Elecs&#39;</span><span class="p">])</span>
                <span class="n">truefalse</span><span class="p">(</span><span class="s1">&#39;ADOS&#39;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;DOS spectral&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TBT.DOS.A&#39;</span><span class="p">])</span>
                <span class="n">truefalse</span><span class="p">(</span><span class="s1">&#39;J&#39;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;orbital-current&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TBT.DOS.A&#39;</span><span class="p">,</span> <span class="s1">&#39;TBT.Current.Orb&#39;</span><span class="p">])</span>
                <span class="n">truefalse</span><span class="p">(</span><span class="s1">&#39;T&#39;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;transmission bulk&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TBT.T.Bulk&#39;</span><span class="p">])</span>
                <span class="n">truefalse</span><span class="p">(</span><span class="n">elec</span> <span class="o">+</span> <span class="s1">&#39;.T&#39;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;transmission out&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TBT.T.Out&#39;</span><span class="p">])</span>
                <span class="n">truefalse</span><span class="p">(</span><span class="n">elec</span> <span class="o">+</span> <span class="s1">&#39;.C&#39;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;transmission out correction&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TBT.T.Out&#39;</span><span class="p">])</span>
                <span class="n">truefalse</span><span class="p">(</span><span class="n">elec</span> <span class="o">+</span> <span class="s1">&#39;.C.Eig&#39;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;transmission out correction (eigen)&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TBT.T.Out&#39;</span><span class="p">,</span> <span class="s1">&#39;TBT.T.Eig&#39;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">elec2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="c1"># Skip it self, checked above in .T and .C</span>
                    <span class="k">if</span> <span class="n">elec2</span> <span class="o">==</span> <span class="n">elec</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">truefalse</span><span class="p">(</span><span class="n">elec2</span> <span class="o">+</span> <span class="s1">&#39;.T&#39;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;transmission -&gt; &quot;</span> <span class="o">+</span> <span class="n">elec2</span><span class="p">)</span>
                    <span class="n">truefalse</span><span class="p">(</span><span class="n">elec2</span> <span class="o">+</span> <span class="s1">&#39;.T.Eig&#39;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;transmission (eigen) -&gt; &quot;</span> <span class="o">+</span> <span class="n">elec2</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TBT.T.Eig&#39;</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  * no information available&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elecs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Available electrodes are:&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot; - &quot;</span> <span class="o">+</span> <span class="n">elec</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">s</span></div>

    <span class="nd">@default_ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Extract data from a TBT.nc file&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ArgumentParser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the arguments that is available for this Sile &quot;&quot;&quot;</span>

        <span class="c1"># We limit the import to occur here</span>
        <span class="kn">import</span> <span class="nn">argparse</span>

        <span class="n">namespace</span> <span class="o">=</span> <span class="n">default_namespace</span><span class="p">(</span><span class="n">_tbt</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                      <span class="n">_geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="p">,</span>
                                      <span class="n">_data</span><span class="o">=</span><span class="p">[],</span> <span class="n">_data_description</span><span class="o">=</span><span class="p">[],</span>
                                      <span class="n">_data_header</span><span class="o">=</span><span class="p">[],</span>
                                      <span class="n">_norm</span><span class="o">=</span><span class="s1">&#39;atom&#39;</span><span class="p">,</span>
                                      <span class="n">_Ovalue</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                                      <span class="n">_Orng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_Erng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">_krng</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">ensure_E</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; This decorater ensures that E is the first element in the _data container &quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="nf">assign_E</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># We immediately extract the energies</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">E</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Energy[eV]&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">assign_E</span>

        <span class="c1"># Correct the geometry species information</span>
        <span class="k">class</span> <span class="nc">GeometryAction</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

                <span class="n">old_g</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># Now read the file to read the geometry from</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># Make sure g has the same # of orbitals</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_g</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">atom</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">orbital</span><span class="o">=</span><span class="n">old_g</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
                <span class="n">g</span><span class="o">.</span><span class="n">_atom</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;-G&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">GeometryAction</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Update the geometry of the output file, this enables one to set the species correctly,&#39;</span>
                             <span class="s1">&#39; note this only affects output-files where species are important&#39;</span><span class="p">))</span>

        <span class="k">class</span> <span class="nc">ERange</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">E</span>
                <span class="n">Emap</span> <span class="o">=</span> <span class="n">strmap</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">E</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">E</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
                <span class="c1"># Convert to actual indices</span>
                <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">Emap</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">begin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">return</span>
                    <span class="k">elif</span> <span class="n">begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">E</span><span class="p">)))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="c1"># Issuing unique also sorts the entries</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--energy&#39;</span><span class="p">,</span> <span class="s1">&#39;-E&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">ERange</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Denote the sub-section of energies that are extracted: &quot;-1:0,1:2&quot; [eV]</span>

<span class="s2">                       This flag takes effect on all energy-resolved quantities and is reset whenever --plot or --out is called&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># k-range</span>
        <span class="k">class</span> <span class="nc">kRange</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@collect_action</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_krng</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_avg</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--kpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;-k&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">kRange</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Denote the sub-section of k-indices that are extracted.</span>

<span class="s2">                           This flag takes effect on all k-resolved quantities and is reset whenever --plot or --out is called&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># The normalization method</span>
        <span class="k">class</span> <span class="nc">NormAction</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@collect_action</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--norm&#39;</span><span class="p">,</span> <span class="s1">&#39;-N&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">NormAction</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;atom&#39;</span><span class="p">,</span>
                       <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;orbital&#39;</span><span class="p">],</span>
                       <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Specify the normalization method; &quot;atom&quot;) total orbitals in selected atoms,</span>
<span class="s2">                       &quot;all&quot;) total orbitals in the device region, &quot;none&quot;) no normalization or &quot;orbital&quot;) selected orbitals.</span>

<span class="s2">                       This flag only takes effect on --dos and --ados and is reset whenever --plot or --out is called&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Try and add the atomic specification</span>
        <span class="k">class</span> <span class="nc">AtomRange</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@collect_action</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

                <span class="c1"># Immediately convert to proper indices</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span>
                <span class="n">a_dev</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">a_dev</span><span class="p">[:]</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Sadly many shell interpreters does not</span>
                <span class="c1"># allow simple [] because they are expansion tokens</span>
                <span class="c1"># in the shell.</span>
                <span class="c1"># We bypass this by allowing *, [, {</span>
                <span class="c1"># * will &quot;only&quot; fail if files are named accordingly, else</span>
                <span class="c1"># it will be passed as-is.</span>
                <span class="c1">#       {    [    *</span>
                <span class="n">sep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">]</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">while</span> <span class="n">failed</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ranges</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">a_dev</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">a_dev</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">sep</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>
                        <span class="n">failed</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not parse the atomic/orbital ranges&quot;</span><span class="p">)</span>

                <span class="c1"># we have only a subset of the orbitals</span>
                <span class="n">orbs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">no</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">asarrayi</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span>
                <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="c1"># this will be</span>
                        <span class="c1">#  atoms[0] == atom</span>
                        <span class="c1">#  atoms[1] == list of orbitals on the atom</span>
                        <span class="k">if</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_dev</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="c1"># Get atoms and orbitals</span>
                        <span class="n">ob</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># We normalize for the total number of orbitals</span>
                        <span class="c1"># on the requested atoms.</span>
                        <span class="c1"># In this way the user can compare directly the DOS</span>
                        <span class="c1"># for same atoms with different sets of orbitals and the</span>
                        <span class="c1"># total will add up.</span>
                        <span class="n">no</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
                        <span class="n">ob</span> <span class="o">=</span> <span class="n">ob</span><span class="p">[</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_dev</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">ob</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                        <span class="n">no</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
                    <span class="n">orbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Device atoms:&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="n">list2str</span><span class="p">(</span><span class="n">a_dev</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input atoms:&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Atomic/Orbital requests are not fully included in the device region.&#39;</span><span class="p">)</span>

                <span class="c1"># Add one to make the c-index equivalent to the f-index</span>
                <span class="n">orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

                <span class="c1"># Check that the requested orbitals are all in the device region</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">o2p</span><span class="p">(</span><span class="n">orbs</span><span class="p">)):</span>
                    <span class="c1"># This should in principle never be called because of the</span>
                    <span class="c1"># checks above.</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Device atoms:&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="n">list2str</span><span class="p">(</span><span class="n">a_dev</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input atoms:&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Atomic/Orbital requests are not fully included in the device region.&#39;</span><span class="p">)</span>

                <span class="n">ns</span><span class="o">.</span><span class="n">_Ovalue</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span> <span class="o">=</span> <span class="n">orbs</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--atom&#39;</span><span class="p">,</span> <span class="s1">&#39;-a&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">AtomRange</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Limit orbital resolved quantities to a sub-set of atoms/orbitals: &quot;1-2[3,4]&quot; will yield the 1st and 2nd atom and their 3rd and fourth orbital. Multiple comma-separated specifications are allowed. Note that some shells does not allow [] as text-input (due to expansion), {, [ or * are allowed orbital delimiters.</span>

<span class="s2">                       This flag takes effect on all atom/orbital resolved quantities (except BDOS, transmission_bulk) and is reset whenever --plot or --out is called&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">DataT</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Electrode: &quot;&#39;</span><span class="o">+</span><span class="n">e1</span><span class="o">+</span><span class="s1">&#39;&quot; cannot be found in the specified file.&#39;</span><span class="p">)</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e2</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">e2</span> <span class="o">!=</span> <span class="n">e1</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span> <span class="c1"># catches if T isn&#39;t calculated</span>
                                    <span class="bp">self</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">],</span> <span class="n">option_string</span><span class="p">)</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="k">pass</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Electrode: &quot;&#39;</span><span class="o">+</span><span class="n">e2</span><span class="o">+</span><span class="s1">&#39;&quot; cannot be found in the specified file.&#39;</span><span class="p">)</span>

                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">transmission</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">)[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;T:</span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">[G]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">))</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Column </span><span class="si">{}</span><span class="s1"> is transmission from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-T&#39;</span><span class="p">,</span> <span class="s1">&#39;--transmission&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;ELEC1&#39;</span><span class="p">,</span> <span class="s1">&#39;ELEC2&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">DataT</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Store the transmission between two electrodes.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">DataBT</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span> <span class="c1"># catches if B isn&#39;t calculated</span>
                                <span class="bp">self</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">option_string</span><span class="p">)</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Electrode: &quot;&#39;</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="s1">&#39;&quot; cannot be found in the specified file.&#39;</span><span class="p">)</span>

                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">transmission_bulk</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">)[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;BT:</span><span class="si">{}</span><span class="s1">[G]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Column </span><span class="si">{}</span><span class="s1"> is bulk-transmission&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-BT&#39;</span><span class="p">,</span> <span class="s1">&#39;--transmission-bulk&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ELEC&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">DataBT</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Store the bulk transmission of an electrode.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">DataDOS</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># we are storing the spectral DOS</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Electrode: &quot;&#39;</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="s1">&#39;&quot; cannot be found in the specified file.&#39;</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">ADOS</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">,</span> <span class="n">orbital</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_norm</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ADOS:</span><span class="si">{}</span><span class="s1">[1/eV]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">DOS</span><span class="p">(</span><span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">,</span> <span class="n">orbital</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_norm</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;DOS[1/eV]&#39;</span><span class="p">)</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">orbital</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_norm</span><span class="p">))</span>

                <span class="c1"># The flatten is because when ns._Erng is None, then a new</span>
                <span class="c1"># dimension (of size 1) is created</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Column </span><span class="si">{}</span><span class="s1"> is sum of all device atoms+orbitals with normalization 1/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">NORM</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Column </span><span class="si">{}</span><span class="s1"> is atoms[orbs] </span><span class="si">{}</span><span class="s1"> with normalization 1/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">ns</span><span class="o">.</span><span class="n">_Ovalue</span><span class="p">,</span> <span class="n">NORM</span><span class="p">))</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--dos&#39;</span><span class="p">,</span> <span class="s1">&#39;-D&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ELEC&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">DataDOS</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Store the DOS. If no electrode is specified, it is Green function, else it is the spectral function.&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--ados&#39;</span><span class="p">,</span> <span class="s1">&#39;-AD&#39;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ELEC&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">DataDOS</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Store the spectral DOS, same as --dos but requires an electrode-argument.&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">DataDOSBulk</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

                <span class="c1"># we are storing the Bulk DOS</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Electrode: &quot;&#39;</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="s1">&#39;&quot; cannot be found in the specified file.&#39;</span><span class="p">)</span>
                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">BDOS</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;BDOS:</span><span class="si">{}</span><span class="s1">[1/eV]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="c1"># Select the energies, even if _Erng is None, this will work!</span>
                <span class="n">no</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Column </span><span class="si">{}</span><span class="s1"> is sum of all electrode[</span><span class="si">{}</span><span class="s1">] atoms+orbitals with normalization 1/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">e</span><span class="p">,</span> <span class="n">no</span><span class="p">))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--bulk-dos&#39;</span><span class="p">,</span> <span class="s1">&#39;-BD&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ELEC&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">DataDOSBulk</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Store the bulk DOS of an electrode.&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">DataTEig</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Electrode: &quot;&#39;</span><span class="o">+</span><span class="n">e1</span><span class="o">+</span><span class="s1">&#39;&quot; cannot be found in the specified file.&#39;</span><span class="p">)</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e2</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">e1</span> <span class="o">!=</span> <span class="n">e2</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span> <span class="c1"># catches if T-eig isn&#39;t calculated</span>
                                    <span class="bp">self</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">],</span> <span class="n">option_string</span><span class="p">)</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="k">pass</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Electrode: &quot;&#39;</span><span class="o">+</span><span class="n">e2</span><span class="o">+</span><span class="s1">&#39;&quot; cannot be found in the specified file.&#39;</span><span class="p">)</span>

                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">)</span>
                <span class="c1"># The shape is: E, neig</span>
                <span class="n">neig</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">eig</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">neig</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">eig</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Teig(</span><span class="si">{}</span><span class="s1">):</span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">[G]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eig</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">))</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Column </span><span class="si">{}</span><span class="s1"> is transmission eigenvalues from electrode </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--transmission-eig&#39;</span><span class="p">,</span> <span class="s1">&#39;-Teig&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;ELEC1&#39;</span><span class="p">,</span> <span class="s1">&#39;ELEC2&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">DataTEig</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Store the transmission eigenvalues between two electrodes.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">Info</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Action to print information contained in the TBT.nc file, helpful before performing actions &quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># First short-hand the file</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--info&#39;</span><span class="p">,</span> <span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">Info</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ELEC&#39;</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Print out what information is contained in the TBT.nc file, optionally only for one of the electrodes.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">Out</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@run_actions</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

                <span class="n">out</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># We figure out if the user wants to write</span>
                    <span class="c1"># to a geometry</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;write_geometry&#39;</span><span class="p">):</span>
                        <span class="k">with</span> <span class="n">obj</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                            <span class="n">fh</span><span class="o">.</span><span class="n">write_geometry</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># do nothing if data has not been collected</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No data has been collected in the arguments, nothing will be written, have you forgotten arguments?&quot;</span><span class="p">)</span>
                    <span class="k">return</span>

                <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="k">import</span> <span class="n">TableSile</span>
                <span class="n">TableSile</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="o">*</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
                                               <span class="n">comment</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="p">,</span>
                                               <span class="n">header</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="p">)</span>
                <span class="c1"># Clean all data</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># These are expert options</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Ovalue</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_krng</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--out&#39;</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Store the currently collected information (at its current invocation) to the out file.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">AVOut</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">write_tbtav</span><span class="p">()</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--tbt-av&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">AVOut</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Create &quot;</span><span class="si">{0}</span><span class="s1">&quot; with the k-averaged quantities of this file.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;TBT.nc&#39;</span><span class="p">,</span> <span class="s1">&#39;TBT.AV.nc&#39;</span><span class="p">)))</span>

        <span class="k">class</span> <span class="nc">Plot</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="nd">@run_actions</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># do nothing if data has not been collected</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No data has been collected in the arguments, nothing will be plotted, have you forgotten arguments?&quot;</span><span class="p">)</span>
                    <span class="k">return</span>

                <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)):</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># Clean all data</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># These are expert options</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Ovalue</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_krng</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--plot&#39;</span><span class="p">,</span> <span class="s1">&#39;-p&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">Plot</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;FILE&#39;</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Plot the currently collected information (at its current invocation).&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">namespace</span></div>


<span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TBT.nc&#39;</span><span class="p">,</span> <span class="n">tbtncSileTBtrans</span><span class="p">)</span>
<span class="c1"># Add spin-dependent files</span>
<span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TBT_DN.nc&#39;</span><span class="p">,</span> <span class="n">tbtncSileTBtrans</span><span class="p">)</span>
<span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TBT_UP.nc&#39;</span><span class="p">,</span> <span class="n">tbtncSileTBtrans</span><span class="p">)</span>


<div class="viewcode-block" id="phtncSileTBtrans"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.phtncSileTBtrans.html#sisl.io.tbtrans.phtncSileTBtrans">[docs]</a><span class="k">class</span> <span class="nc">phtncSileTBtrans</span><span class="p">(</span><span class="n">tbtncSileTBtrans</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; PHtrans file object &quot;&quot;&quot;</span>
    <span class="n">_trans_type</span> <span class="o">=</span> <span class="s1">&#39;PHT&#39;</span></div>

<span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;PHT.nc&#39;</span><span class="p">,</span> <span class="n">phtncSileTBtrans</span><span class="p">)</span>


<span class="c1"># The average files</span>
<span class="c1"># These are essentially equivalent to the TBT.nc files</span>
<span class="c1"># with the exception that the k-points have been averaged out.</span>
<div class="viewcode-block" id="tbtavncSileTBtrans"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtavncSileTBtrans.html#sisl.io.tbtrans.tbtavncSileTBtrans">[docs]</a><span class="k">class</span> <span class="nc">tbtavncSileTBtrans</span><span class="p">(</span><span class="n">tbtncSileTBtrans</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; TBtrans average file object</span>

<span class="sd">    This `Sile` implements the writing of the TBtrans output ``*.TBT.AV.nc`` sile which contains</span>
<span class="sd">    the k-averaged quantities related to the NEGF code TBtrans.</span>

<span class="sd">    See `tbtncSileTBtrans` for details as this object is essentially a copy of it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_trans_type</span> <span class="o">=</span> <span class="s1">&#39;TBT&#39;</span>
    <span class="n">_k_avg</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nkpt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Always return 1, this is to signal other routines &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">wkpt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Always return [1.], this is to signal other routines &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="tbtavncSileTBtrans.write_tbtav"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.tbtavncSileTBtrans.html#sisl.io.tbtrans.tbtavncSileTBtrans.write_tbtav">[docs]</a>    <span class="k">def</span> <span class="nf">write_tbtav</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Wrapper for writing the k-averaged TBT.AV.nc file.</span>

<span class="sd">        This write *requires* the TBT.nc `Sile` object passed as the first argument,</span>
<span class="sd">        or as the keyword ``from=tbt`` argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        from : tbtncSileTBtrans</span>
<span class="sd">          the TBT.nc file object that has the k-sampled quantities.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;from&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">tbt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tbt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tbtncSileTBtrans has not been passed to write the averaged file&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tbt</span><span class="p">,</span> <span class="n">tbtncSileTBtrans</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;first argument of tbtavncSileTBtrans.write *must* be a tbtncSileTBtrans object&#39;</span><span class="p">)</span>

        <span class="c1"># Notify if the object is not in write mode.</span>
        <span class="n">sile_raise_write</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">copy_attr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">t</span><span class="o">.</span><span class="n">setncatts</span><span class="p">({</span><span class="n">att</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">att</span><span class="p">)</span> <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()})</span>

        <span class="c1"># Retrieve k-weights</span>
        <span class="n">nkpt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tbt</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;nkpt&#39;</span><span class="p">])</span>
        <span class="n">wkpt</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">tbt</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;wkpt&#39;</span><span class="p">][:])</span>

        <span class="c1"># First copy and re-create all entries in the output file</span>
        <span class="k">for</span> <span class="n">dvg</span> <span class="ow">in</span> <span class="n">tbt</span><span class="p">:</span>
            <span class="c1"># Iterate all:</span>
            <span class="c1">#  root,</span>
            <span class="c1">#  dimensions,</span>
            <span class="c1">#  variables</span>
            <span class="c1">#  sub-groups, (start over again)</span>

            <span class="c1"># Root group</span>
            <span class="k">if</span> <span class="n">tbt</span><span class="o">.</span><span class="n">isDataset</span><span class="p">(</span><span class="n">dvg</span><span class="p">):</span>
                <span class="c1"># Copy attributes and continue</span>
                <span class="n">copy_attr</span><span class="p">(</span><span class="n">dvg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Ensure the group exists</span>
            <span class="k">if</span> <span class="n">tbt</span><span class="o">.</span><span class="n">isGroup</span><span class="p">(</span><span class="n">dvg</span><span class="p">):</span>
                <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="n">copy_attr</span><span class="p">(</span><span class="n">dvg</span><span class="p">,</span> <span class="n">grp</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Ensure the group exists... (the above case handles groups)</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tbt</span><span class="o">.</span><span class="n">isDimension</span><span class="p">(</span><span class="n">dvg</span><span class="p">):</span>

                <span class="c1"># In case the dimension is the k-point one</span>
                <span class="c1"># we remove that dimension</span>
                <span class="k">if</span> <span class="s1">&#39;nkpt&#39;</span> <span class="o">==</span> <span class="n">dvg</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Simply re-create the dimension</span>
                <span class="k">if</span> <span class="n">dvg</span><span class="o">.</span><span class="n">isunlimited</span><span class="p">():</span>
                    <span class="n">grp</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">grp</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dvg</span><span class="p">))</span>

                <span class="k">continue</span>

            <span class="c1"># It *must* be a variable now</span>

            <span class="c1"># Quickly skip the k-point variable and the weights</span>
            <span class="k">if</span> <span class="n">dvg</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;kpt&#39;</span><span class="p">,</span> <span class="s1">&#39;wkpt&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Down-scale the k-point dimension</span>
            <span class="k">if</span> <span class="s1">&#39;nkpt&#39;</span> <span class="ow">in</span> <span class="n">dvg</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
                <span class="c1"># Remove that dimension</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                <span class="c1"># Create slice</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;nkpt&#39;</span><span class="p">)</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
                <span class="n">has_kpt</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="n">dvg</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:]</span>
                <span class="n">has_kpt</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">grp</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dvg</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                   <span class="n">dimensions</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">dvg</span><span class="o">.</span><span class="n">filters</span><span class="p">())</span>

            <span class="c1"># Copy attributes</span>
            <span class="n">copy_attr</span><span class="p">(</span><span class="n">dvg</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="c1"># Copy values</span>
            <span class="k">if</span> <span class="n">has_kpt</span><span class="p">:</span>
                <span class="c1"># Instead of constantly reading-writing to disk</span>
                <span class="c1"># (if buffer is too small)</span>
                <span class="c1"># we create a temporary array to hold the averaged</span>
                <span class="c1"># quantities.</span>
                <span class="c1"># This should only be faster for very large variables</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dvg</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">):</span>
                        <span class="n">dat</span> <span class="o">+=</span> <span class="n">dvg</span><span class="p">[</span><span class="n">k</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">iter_shape</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">idx</span><span class="p">]):</span>
                        <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dvg</span><span class="p">[</span><span class="n">slc</span><span class="p">][</span><span class="mi">0</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">):</span>
                            <span class="n">dat</span> <span class="o">+=</span> <span class="n">dvg</span><span class="p">[</span><span class="n">slc</span><span class="p">][</span><span class="n">k</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">v</span><span class="p">[</span><span class="n">slc</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[:]</span>
                <span class="k">del</span> <span class="n">dat</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dvg</span><span class="p">[:]</span>

        <span class="c1"># Update the source attribute to signal the originating file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setncattr</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;k-average of: &#39;</span> <span class="o">+</span> <span class="n">tbt</span><span class="o">.</span><span class="n">_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sync</span><span class="p">()</span></div></div>


<span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TBT.AV.nc&#39;</span><span class="p">,</span> <span class="n">tbtavncSileTBtrans</span><span class="p">)</span>
<span class="c1"># Add spin-dependent files</span>
<span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TBT_DN.AV.nc&#39;</span><span class="p">,</span> <span class="n">tbtavncSileTBtrans</span><span class="p">)</span>
<span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TBT_UP.AV.nc&#39;</span><span class="p">,</span> <span class="n">tbtavncSileTBtrans</span><span class="p">)</span>


<div class="viewcode-block" id="phtavncSileTBtrans"><a class="viewcode-back" href="../../../../api-generated/sisl.io.tbtrans.phtavncSileTBtrans.html#sisl.io.tbtrans.phtavncSileTBtrans">[docs]</a><span class="k">class</span> <span class="nc">phtavncSileTBtrans</span><span class="p">(</span><span class="n">tbtavncSileTBtrans</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; PHtrans file object &quot;&quot;&quot;</span>
    <span class="n">_trans_type</span> <span class="o">=</span> <span class="s1">&#39;PHT&#39;</span></div>

<span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;PHT.AV.nc&#39;</span><span class="p">,</span> <span class="n">phtavncSileTBtrans</span><span class="p">)</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, Nick R. Papior.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.9.2-122',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>