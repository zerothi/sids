

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sisl.io.siesta.binaries &mdash; sisl |release| documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">Publications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../publications.html">Publications using sisl</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">API documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">sisl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>sisl.io.siesta.binaries</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sisl.io.siesta.binaries</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_siesta</span>
    <span class="n">found_module</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">found_module</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">from</span> <span class="nn">sisl.messages</span> <span class="k">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">SislError</span>
<span class="kn">from</span> <span class="nn">..sile</span> <span class="k">import</span> <span class="n">add_sile</span><span class="p">,</span> <span class="n">SileError</span>
<span class="kn">from</span> <span class="nn">.sile</span> <span class="k">import</span> <span class="n">SileBinSiesta</span>

<span class="kn">import</span> <span class="nn">sisl._array</span> <span class="k">as</span> <span class="nn">_a</span>
<span class="kn">from</span> <span class="nn">sisl</span> <span class="k">import</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atoms</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">,</span> <span class="n">Grid</span>
<span class="kn">from</span> <span class="nn">sisl.unit.siesta</span> <span class="k">import</span> <span class="n">unit_convert</span>
<span class="kn">from</span> <span class="nn">sisl.physics.sparse</span> <span class="k">import</span> <span class="n">SparseOrbitalBZ</span>
<span class="kn">from</span> <span class="nn">sisl.physics</span> <span class="k">import</span> <span class="n">Hamiltonian</span><span class="p">,</span> <span class="n">DensityMatrix</span><span class="p">,</span> <span class="n">EnergyDensityMatrix</span>
<span class="kn">from</span> <span class="nn">sisl.physics.overlap</span> <span class="k">import</span> <span class="n">Overlap</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="k">import</span> <span class="o">*</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tshsSileSiesta&#39;</span><span class="p">,</span> <span class="s1">&#39;onlysSileSiesta&#39;</span><span class="p">,</span> <span class="s1">&#39;tsdeSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;hsxSileSiesta&#39;</span><span class="p">,</span> <span class="s1">&#39;dmSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;gridSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;tsgfSileSiesta&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_bin_check</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">iostat_query</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> (ierr=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">method</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">iostat_query</span><span class="p">()))</span>


<span class="k">def</span> <span class="nf">_geometry_align</span><span class="p">(</span><span class="n">geom_b</span><span class="p">,</span> <span class="n">geom_u</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Routine used to align two geometries</span>

<span class="sd">    There are a few twists in this since the fdf-reads will automatically</span>
<span class="sd">    try and pass a geometry from the output files.</span>
<span class="sd">    In cases where the *.ion* files are non-existing this will</span>
<span class="sd">    result in a twist.</span>

<span class="sd">    This routine will select and return a merged Geometry which</span>
<span class="sd">    fulfills the correct number of atoms and orbitals.</span>

<span class="sd">    However, if the input geometries have mis-matching number</span>
<span class="sd">    of atoms a SislError will be raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    geom_b : Geometry from binary file</span>
<span class="sd">    geom_u : Geometry supplied by user</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    SislError : if the geometries have non-equal atom count</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">geom_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom_u</span>
    <span class="k">elif</span> <span class="n">geom_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom_b</span>

    <span class="c1"># Default to use the users geometry</span>
    <span class="n">geom</span> <span class="o">=</span> <span class="n">geom_u</span>

    <span class="n">is_copy</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="nf">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geom</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">na</span> <span class="o">!=</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">:</span>
        <span class="c1"># we have no way of solving this issue...</span>
        <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">.</span><span class="si">{method}</span><span class="s2"> could not use the passed geometry as the &quot;</span>
                        <span class="s2">&quot;of atoms is not consistent, user-atoms=</span><span class="si">{u_na}</span><span class="s2">, file-atoms=</span><span class="si">{b_na}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                                                                                   <span class="n">b_na</span><span class="o">=</span><span class="n">geom_b</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">u_na</span><span class="o">=</span><span class="n">geom_u</span><span class="o">.</span><span class="n">na</span><span class="p">))</span>

    <span class="c1"># Try and figure out what to do</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">.</span><span class="si">{method}</span><span class="s2"> has mismatched atomic coordinates, will copy geometry and use file XYZ.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">))</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">.</span><span class="si">{method}</span><span class="s2"> has non-equal lattice vectors, will copy geometry and use file lattice.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">))</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">nsc</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">.</span><span class="si">{method}</span><span class="s2"> has non-equal number of supercells, will copy geometry and use file supercell count.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">))</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>

    <span class="c1"># Now for the difficult part.</span>
    <span class="c1"># If there is a mismatch in the number of orbitals we will</span>
    <span class="c1"># prefer to use the user-supplied atomic species, but fill with</span>
    <span class="c1"># *random* orbitals</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">.</span><span class="si">{method}</span><span class="s2"> has non-equal number of orbitals per atom, will correct with *empty* orbitals.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">))</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>

        <span class="c1"># Now create a new atom specie with the correct number of orbitals</span>
        <span class="n">norbs</span> <span class="o">=</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[:]</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">([</span><span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">orbital</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">norbs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)])</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">atoms</span>

    <span class="k">return</span> <span class="n">geom</span>


<div class="viewcode-block" id="onlysSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">onlysSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Geometry and overlap matrix &quot;&quot;&quot;</span>

<div class="viewcode-block" id="onlysSileSiesta.read_supercell"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_supercell">[docs]</a>    <span class="k">def</span> <span class="nf">read_supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a SuperCell object from a TranSiesta file &quot;&quot;&quot;</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_supercell&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">n_s</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_supercell&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span></div>

<div class="viewcode-block" id="onlysSileSiesta.read_geometry"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">read_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns Geometry object from a TranSiesta file &quot;&quot;&quot;</span>

        <span class="c1"># Read supercell</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_supercell</span><span class="p">()</span>

        <span class="n">na</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_geom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read geometry.&#39;</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">lasto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Since the TSHS file does not contain species information</span>
        <span class="c1"># and/or other stuff we *can* reuse an existing</span>
        <span class="c1"># geometry which contains the correct atomic numbers etc.</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lasto</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create all different atoms...</span>
            <span class="c1"># The TSHS file does not contain the</span>
            <span class="c1"># atomic numbers, so we will just</span>
            <span class="c1"># create them individually</span>

            <span class="c1"># Get unique orbitals</span>
            <span class="n">uorb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
            <span class="c1"># Create atoms</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">Z</span><span class="p">,</span> <span class="n">orb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uorb</span><span class="p">):</span>
                <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">Z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">orb</span><span class="p">))</span>

            <span class="k">def</span> <span class="nf">get_atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">no</span> <span class="o">==</span> <span class="n">orbs</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">atom</span>

            <span class="n">atom</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">:</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orb</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create a new geometry with the correct atomic numbers</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">no</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">no</span> <span class="o">==</span> <span class="n">no</span><span class="p">:</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># correct atom</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)],</span> <span class="n">mass</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">tag</span><span class="p">))</span>

        <span class="c1"># Create and return geometry object</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="onlysSileSiesta.read_overlap"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">read_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the overlap matrix from the TranSiesta file &quot;&quot;&quot;</span>
        <span class="n">tshs_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">_geometry_align</span><span class="p">(</span><span class="n">tshs_g</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">tshs_g</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">)</span>

        <span class="c1"># read the sizes used...</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read overlap matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">Overlap</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert to sisl supercell</span>
        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="onlysSileSiesta.read_fermi_level"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_fermi_level">[docs]</a>    <span class="k">def</span> <span class="nf">read_fermi_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Query the Fermi-level contained in the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Ef : fermi-level of the system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ef</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_ef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_fermi_level&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read fermi-level.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Ef</span></div></div>


<div class="viewcode-block" id="tshsSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">tshsSileSiesta</span><span class="p">(</span><span class="n">onlysSileSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Geometry, Hamiltonian and overlap matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="tshsSileSiesta.read_hamiltonian"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta.read_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the electronic structure from the siesta.TSHS file &quot;&quot;&quot;</span>
        <span class="n">tshs_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">_geometry_align</span><span class="p">(</span><span class="n">tshs_g</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">tshs_g</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">)</span>

        <span class="c1"># read the sizes used...</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">spin</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dH</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian and overlap matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Check whether it is an orthogonal basis set</span>
        <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="n">orthogonal</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="p">])</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>

        <span class="c1"># Convert to sisl supercell</span>
        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># Find all indices where dS == 1 (remember col is in fortran indices)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">dS</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">no</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of orbitals: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">no</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_hamiltonian could not assert &#39;</span>
                            <span class="s1">&#39;the supercell connections in the primary unit-cell.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="tshsSileSiesta.write_hamiltonian"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta.write_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">write_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes the Hamiltonian to a siesta.TSHS file &quot;&quot;&quot;</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.write_hamiltonian cannot write &#39;</span>
                            <span class="s1">&#39;a zero element sparse matrix!&#39;</span><span class="p">)</span>

        <span class="c1"># Convert to siesta CSR</span>
        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">csr</span><span class="p">)</span>
        <span class="c1"># TODO consider removing finalize here!</span>
        <span class="c1"># If tbtrans really needs this, then we should definitely do this</span>
        <span class="c1"># in tbtrans!</span>
        <span class="c1"># I.e. we should probably just do finalize(sort=False)</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>

        <span class="c1"># Extract the data to pass to the fortran routine</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span>

        <span class="c1"># Get H and S</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Ensure all data is correctly formatted (i.e. have the same sparsity pattern</span>
            <span class="n">s</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">csr</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">nnz</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s1">&#39;The diagonal elements of your orthogonal Hamiltonian &#39;</span>
                                <span class="s1">&#39;have not been defined, this is a requirement.&#39;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Ensure shapes (say if only 1 spin)</span>
        <span class="n">h</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">spin</span><span class="p">))</span>
        <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># Get shorter variants</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">siesta_sc_off</span><span class="p">(</span><span class="o">*</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># I can&#39;t seem to figure out the usage of f2py</span>
        <span class="c1"># Below I get an error if xyz is not transposed and h is transposed,</span>
        <span class="c1"># however, they are both in C-contiguous arrays and this is indeed weird... :(</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_tshs_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                              <span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">xyz</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span>
                              <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write Hamiltonian and overlap matrix.&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="dmSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">dmSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Density matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="dmSileSiesta.read_density_matrix"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta.read_density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">read_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the density matrix from the siesta.DM file &quot;&quot;&quot;</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_dm_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read density matrix sizes.&#39;</span><span class="p">)</span>

        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dDM</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_dm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read density matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We truly, have no clue,</span>
            <span class="c1"># Just generate a boxed system</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">nsc</span><span class="p">):</span>
            <span class="c1"># We have to update the number of supercells!</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_density_matrix could not use the &#39;</span>
                            <span class="s1">&#39;passed geometry as the number of atoms or orbitals is &#39;</span>
                            <span class="s1">&#39;inconsistent with DM file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the density matrix container</span>
        <span class="n">DM</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDM</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="c1"># DM file does not contain overlap matrix... so neglect it for now.</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">DM</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">&gt;=</span> <span class="n">col</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_density_matrix may result in a wrong sparse pattern!&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DM</span></div>

<div class="viewcode-block" id="dmSileSiesta.write_density_matrix"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta.write_density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">write_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DM</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes the density matrix to a siesta.DM file &quot;&quot;&quot;</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># This ensures that we don&#39;t have any *empty* elements</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.write_density_matrix cannot write &#39;</span>
                            <span class="s1">&#39;a zero element sparse matrix!&#39;</span><span class="p">)</span>

        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">csr</span><span class="p">)</span>
        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>

        <span class="c1"># Get DM</span>
        <span class="k">if</span> <span class="n">DM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">DM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="c1"># Ensure shapes (say if only 1 spin)</span>
        <span class="n">dm</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">spin</span><span class="p">))</span>

        <span class="n">nsc</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_dm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write density matrix.&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="tsdeSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">tsdeSileSiesta</span><span class="p">(</span><span class="n">dmSileSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Non-equilibrium density matrix and energy density matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="tsdeSileSiesta.read_energy_density_matrix"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.read_energy_density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">read_energy_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the energy density matrix from the siesta.DM file &quot;&quot;&quot;</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_energy_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read energy density matrix sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dEDM</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_edm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_energy_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read energy density matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We truly, have no clue,</span>
            <span class="c1"># Just generate a boxed system</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">nsc</span><span class="p">):</span>
            <span class="c1"># We have to update the number of supercells!</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_energy_density_matrix could &#39;</span>
                            <span class="s1">&#39;not use the passed geometry as the number of atoms or orbitals &#39;</span>
                            <span class="s1">&#39;is inconsistent with DM file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the energy density matrix container</span>
        <span class="n">EDM</span> <span class="o">=</span> <span class="n">EnergyDensityMatrix</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dEDM</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="c1"># EDM file does not contain overlap matrix... so neglect it for now.</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">EDM</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">&gt;=</span> <span class="n">col</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_energy_density_matrix may result in a wrong sparse pattern!&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">EDM</span></div>

<div class="viewcode-block" id="tsdeSileSiesta.read_fermi_level"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.read_fermi_level">[docs]</a>    <span class="k">def</span> <span class="nf">read_fermi_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Query the Fermi-level contained in the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Ef : fermi-level of the system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ef</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_ef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_fermi_level&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read fermi-level.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Ef</span></div>

<div class="viewcode-block" id="tsdeSileSiesta.write_density_matrices"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.write_density_matrices">[docs]</a>    <span class="k">def</span> <span class="nf">write_density_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DM</span><span class="p">,</span> <span class="n">EDM</span><span class="p">,</span> <span class="n">Ef</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Writes the density matrix to a siesta.DM file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        DM : DensityMatrix</span>
<span class="sd">           density matrix to write to the file</span>
<span class="sd">        EDM : EnergyDensityMatrix</span>
<span class="sd">           energy density matrix to write to the file</span>
<span class="sd">        Ef : float, optional</span>
<span class="sd">           fermi-level to be contained</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DMcsr</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">EDMcsr</span> <span class="o">=</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">DMcsr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">EDMcsr</span><span class="p">)</span>
        <span class="n">EDMcsr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">DMcsr</span><span class="p">)</span>
        <span class="c1"># This ensures that we don&#39;t have any *empty* elements</span>
        <span class="n">DMcsr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">EDMcsr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.write_density_matrices cannot write &#39;</span>
                            <span class="s1">&#39;a zero element sparse matrix!&#39;</span><span class="p">)</span>

        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">DMcsr</span><span class="p">)</span>
        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">EDMcsr</span><span class="p">)</span>
        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">DMcsr</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>
        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">EDMcsr</span><span class="p">,</span> <span class="n">EDM</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>

        <span class="c1"># Ensure everything is correct</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">DMcsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">DMcsr</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">col</span><span class="p">)):</span>
            <span class="c1"># Only finalize in cases where it is needed</span>
            <span class="n">DMcsr</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
            <span class="n">EDMcsr</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">DMcsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">DMcsr</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">col</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.write_density_matrices got non compatible &#39;</span>
                                 <span class="s1">&#39;DM and EDM matrices.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">DM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">DM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">EDM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">edm</span> <span class="o">=</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edm</span> <span class="o">=</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">EDM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="n">nsc</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_tsde_dm_edm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">edm</span><span class="p">,</span> <span class="n">Ef</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_density_matrices&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write DM + EDM matrices.&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="hsxSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">hsxSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Hamiltonian and overlap matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="hsxSileSiesta.read_hamiltonian"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the electronic structure from the siesta.TSHS file &quot;&quot;&quot;</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dH</span><span class="p">,</span> <span class="n">dS</span><span class="p">,</span> <span class="n">dxij</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_hsx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian.&#39;</span><span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We have *no* clue about the</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dxij</span><span class="p">,</span> <span class="mf">0.</span><span class="p">):</span>
                <span class="c1"># We truly, have no clue,</span>
                <span class="c1"># Just generate a boxed system</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="p">[</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Try to figure out the supercell</span>
                <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.read_hamiltonian &#39;</span>
                     <span class="s1">&#39;(currently we can not calculate atomic positions from xij array)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_hamiltonian could not use the &#39;</span>
                            <span class="s1">&#39;passed geometry as the number of atoms or orbitals is &#39;</span>
                            <span class="s1">&#39;inconsistent with HSX file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyf</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">no_s</span> <span class="o">//</span> <span class="n">no</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="hsxSileSiesta.read_overlap"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">read_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the overlap matrix from the siesta.HSX file &quot;&quot;&quot;</span>
        <span class="c1"># Now read the sizes used...</span>
        <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read overlap matrix sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read overlap matrix.&#39;</span><span class="p">)</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.read_overlap requires input geometry to assign S&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_overlap could not use the &#39;</span>
                            <span class="s1">&#39;passed geometry as the number of atoms or orbitals is &#39;</span>
                            <span class="s1">&#39;inconsistent with HSX file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">Overlap</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyf</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">no_s</span> <span class="o">//</span> <span class="n">no</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div></div>


<span class="k">class</span> <span class="nc">_gridSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Binary real-space grid file</span>

<span class="sd">    The Siesta binary grid sile will automatically convert the units from Siesta</span>
<span class="sd">    units (Bohr, Ry) to sisl units (Ang, eV) provided the correct extension is present.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">read_supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the cell contained in the file &quot;&quot;&quot;</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_supercell&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_grid_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Query grid size information such as the grid size and number of spin components</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int : number of spin-components</span>
<span class="sd">        mesh : 3 values for the number of mesh-elements</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Read the sizes</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_grid_size&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read grid sizes.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span>

    <span class="k">def</span> <span class="nf">read_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read grid contained in the Grid file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or array_like, optional</span>
<span class="sd">           the spin-index for retrieving one of the components. If a vector</span>
<span class="sd">           is passed it refers to the fraction per indexed component. I.e.</span>
<span class="sd">           ``[0.5, 0.5]`` will return sum of half the first two components.</span>
<span class="sd">           Default to the first component.</span>
<span class="sd">        dtype : numpy.float64, optional</span>
<span class="sd">           default data-type precision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read the sizes and cell</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_grid_size</span><span class="p">()</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_grid&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read grid cell.&#39;</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_grid&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read grid.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.read_grid requires spin to be an integer or &#39;</span>
                                 <span class="s1">&#39;an array of length equal to the number of spin components.&#39;</span><span class="p">)</span>
            <span class="c1"># It is F-contiguous, hence the last index</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">g</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">g</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Simply create the grid (with no information)</span>
        <span class="c1"># We will overwrite the actual grid</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sc</span><span class="o">=</span><span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
        <span class="c1"># NOTE: there is no need to swap-axes since the returned array is in F ordering</span>
        <span class="c1">#       and thus the first axis is the fast (x, y, z) is retained</span>
        <span class="n">g</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_unit</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span>


<span class="k">class</span> <span class="nc">_gfSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Surface Green function file containing, Hamiltonian, overlap matrix and self-energies</span>

<span class="sd">    Do not mix read and write statements when using this code. Complete one or the other</span>
<span class="sd">    before doing the other thing. Fortran does not allow the same file opened twice, if this</span>
<span class="sd">    is needed you are recommended to make a symlink to the file and thus open two different</span>
<span class="sd">    files.</span>

<span class="sd">    This small snippet reads/writes the GF file</span>

<span class="sd">    &gt;&gt;&gt; with sisl.io._gfSileSiesta(&#39;hello.GF&#39;) as f:</span>
<span class="sd">    ...    nspin, no, k, E = f.read_header()</span>
<span class="sd">    ...    for ispin, new_k, k, E in f:</span>
<span class="sd">    ...        if new_k:</span>
<span class="sd">    ...            H, S = f.read_hamiltonian()</span>
<span class="sd">    ...        SeHSE = f.read_self_energy()</span>

<span class="sd">    To write a file do:</span>

<span class="sd">    &gt;&gt;&gt; with sisl.io._gfSileSiesta(&#39;hello.GF&#39;) as f:</span>
<span class="sd">    ...    f.write_header(sisl.MonkhorstPack(...), E)</span>
<span class="sd">    ...    for ispin, new_k, k, E in f:</span>
<span class="sd">    ...        if new_k:</span>
<span class="sd">    ...            f.write_hamiltonian(H, S)</span>
<span class="sd">    ...        f.write_self_energy(SeHSE)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simple setup that needs to be overwritten &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_is_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_open_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rewind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">()</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rewind</span><span class="p">:</span>
                <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">rewind_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># retain indices</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_open_gf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">write_open_gf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_open_gf&#39;</span><span class="p">,</span> <span class="s1">&#39;could not open for </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">({</span><span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;reading&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="s1">&#39;writing&#39;</span><span class="p">}[</span><span class="n">mode</span><span class="p">]))</span>

        <span class="c1"># They will at any given time</span>
        <span class="c1"># correspond to the current Python indices that is to be read</span>
        <span class="c1"># The process for identification is done on this basis:</span>
        <span class="c1">#  iE is the current (Python) index for the energy-point to be read</span>
        <span class="c1">#  ik is the current (Python) index for the k-point to be read</span>
        <span class="c1">#  ispin is the current (Python) index for the spin-index to be read (only has meaning for a spin-polarized</span>
        <span class="c1">#         GF files)</span>
        <span class="c1">#  state is:</span>
        <span class="c1">#        -1 : the file-descriptor has just been opened (i.e. in front of header)</span>
        <span class="c1">#         0 : it means that the file-descriptor IS in front of H and S</span>
        <span class="c1">#         1 : it means that the file-descriptor is NOT in front of H and S but somewhere in front of a self-energy</span>
        <span class="c1">#  is_read is:</span>
        <span class="c1">#         0 : means that the current indices HAVE NOT been read</span>
        <span class="c1">#         1 : means that the current indices HAVE been read</span>
        <span class="c1">#</span>
        <span class="c1"># All routines in the gf_read/write sources requires input in Python indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_close_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="c1"># Close it</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">close_gf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Clean variables</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_step_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Method for stepping values *must* be called before doing the actual read to check correct values &quot;&quot;&quot;</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;header&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># The header only exists once, so check whether it is the correct place to read/write</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the header has already &#39;</span>
                                <span class="s1">&#39;been read.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1">#print(&#39;HEADER: &#39;, self._state, self._ispin, self._ik, self._iE)</span>

        <span class="k">elif</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HS&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Correct for the previous state and jump values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We have just read the header</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has not read the header.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
                <span class="c1"># Reset values as though the header has just been read</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has already read the current HS for the given k-point.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We have just read from the last energy-point</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has not read all energy-points for a given k-point.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span><span class="p">:</span>
                    <span class="c1"># We need to step spin</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1">#print(&#39;HS: &#39;, self._state, self._ispin, self._ik, self._iE)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">:</span>
                <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;spin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;nspin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
                <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because of missing information, &#39;</span>
                                <span class="s1">&#39;a non-existing entry has been requested! spin=</span><span class="si">{spin}</span><span class="s1"> max_spin=</span><span class="si">{nspin}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are reading an energy-point</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                <span class="s1">&#39;has an unknown state.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Fine, we have just read the HS, ispin and ik are correct</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has an unknown state.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">:</span>
                    <span class="c1"># we haven&#39;t read the current energy-point.and self._iE + 1 &lt; self._nE:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has an unknown state.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">:</span>
                    <span class="c1"># You are trying to read beyond the entry</span>
                    <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;iE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;NE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because of missing information, &#39;</span>
                                    <span class="s1">&#39;a non-existing energy-point has been requested! E_index=</span><span class="si">{iE}</span><span class="s1"> max_E_index=</span><span class="si">{NE}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
            <span class="c1">#print(&#39;SE: &#39;, self._state, self._ispin, self._ik, self._iE)</span>

        <span class="c1"># Always signal (when stepping) that we have not yet read the thing</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">Eindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the closest energy index corresponding to the energy ``E``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : float or int</span>
<span class="sd">           if ``int``, return it-self, else return the energy index which is</span>
<span class="sd">           closests to the energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">E</span>
        <span class="n">idxE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">ret_E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="n">idxE</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ret_E</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">5e-3</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; requesting energy &quot;</span> <span class="o">+</span>
                 <span class="s2">&quot;</span><span class="si">{0:.5f}</span><span class="s2"> eV, found </span><span class="si">{1:.5f}</span><span class="s2"> eV as the closest energy!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">ret_E</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ret_E</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; requesting energy &quot;</span> <span class="o">+</span>
                 <span class="s2">&quot;</span><span class="si">{0:.5f}</span><span class="s2"> eV, found </span><span class="si">{1:.5f}</span><span class="s2"> eV as the closest energy!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">ret_E</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">idxE</span>

    <span class="k">def</span> <span class="nf">kindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the index of the k-point that is closests to the queried k-point (in reduced coordinates)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like of float or int</span>
<span class="sd">           the queried k-point in reduced coordinates :math:`]-0.5;0.5]`. If ``int``</span>
<span class="sd">           return it-self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">k</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">-</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">ret_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ret_k</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">SileWarning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; requesting k-point &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;[</span><span class="si">{0:.3f}</span><span class="s2">, </span><span class="si">{1:.3f}</span><span class="s2">, </span><span class="si">{2:.3f}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s2">&quot; found &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;[</span><span class="si">{0:.3f}</span><span class="s2">, </span><span class="si">{1:.3f}</span><span class="s2">, </span><span class="si">{2:.3f}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">ret_k</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">ik</span>

    <span class="k">def</span> <span class="nf">read_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read the header of the file and open it for reading subsequently</span>

<span class="sd">        NOTES: this method may change in the future</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nspin : number of spin-components stored (1 or 2)</span>
<span class="sd">        no_u : size of the matrices returned</span>
<span class="sd">        k : k points in the GF file</span>
<span class="sd">        E : energy points in the GF file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure it is open (in read-mode)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">():</span>
            <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">rewind_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open_gf</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">NE</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_header&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">nspin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span> <span class="o">=</span> <span class="n">nkpt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="o">=</span> <span class="n">NE</span>

        <span class="c1"># We need to rewind (because of k and energy -points)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">rewind_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;read_header&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">NE</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_header&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read header information.&#39;</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># non-colinear</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">k</span>

        <span class="k">return</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span>

    <span class="k">def</span> <span class="nf">disk_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the estimated size of the resulting file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        estimated disk-space used in GB</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_open</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="c1"># HS are only stored per k-point</span>
        <span class="n">HS</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span>
        <span class="n">SE</span> <span class="o">=</span> <span class="n">HS</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span>

        <span class="c1"># Now calculate the full size</span>
        <span class="c1"># no_u ** 2 = matrix size</span>
        <span class="c1"># 16 = bytes in double complex</span>
        <span class="c1"># 1024 ** 3 = B -&gt; GB</span>
        <span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">HS</span> <span class="o">+</span> <span class="n">SE</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">**</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">mem</span>

    <span class="k">def</span> <span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return current Hamiltonian and overlap matrix from the GF file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complex128 : Hamiltonian matrix</span>
<span class="sd">        complex128 : Overlap matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="n">HS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian and overlap matrices.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">read_self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Read the currently reached bulk self-energy</span>

<span class="sd">        The returned self-energy is:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol \Sigma_{\mathrm{bulk}}(E) = \mathbf S E - \mathbf H - \boldsymbol \Sigma(E)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complex128 : Self-energy matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;read_self_energy&#39;</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">SE</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_se</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_self_energy&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read self-energy.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SE</span>

    <span class="k">def</span> <span class="nf">HkSk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retrieve H and S for the given k-point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or array_like of float, optional</span>
<span class="sd">           k-point to read the corresponding Hamiltonian and overlap matrices</span>
<span class="sd">           for. If a specific k-point is passed `kindex` will be used to find</span>
<span class="sd">           the corresponding index.</span>
<span class="sd">        spin : int, optional</span>
<span class="sd">           spin-index for the Hamiltonian and overlap matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="c1"># find k-index that is requested</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kindex</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span><span class="p">,</span>
                             <span class="mi">0</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;HkSk&#39;</span><span class="p">,</span> <span class="s1">&#39;could not find Hamiltonian and overlap matrix.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">spin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">ik</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># signal this is to be read</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_hamiltonian</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retrieve self-energy for a given energy-point and k-point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : int or float</span>
<span class="sd">           energy to retrieve self-energy at</span>
<span class="sd">        k : int or array_like of float, optional</span>
<span class="sd">           k-point to retrieve k-point at</span>
<span class="sd">        spin : int, optional</span>
<span class="sd">           spin-index to retrieve self-energy at</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kindex</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">iE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span><span class="p">,</span>
                             <span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">iE</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;self_energy&#39;</span><span class="p">,</span> <span class="s1">&#39;could not find requested self-energy.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">spin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">ik</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="n">iE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># signal this is to be read</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_self_energy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">write_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bz</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write to the binary file the header of the file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bz : BrillouinZone</span>
<span class="sd">           contains the k-points, the weights and possibly the parent Hamiltonian (if `obj` is None)s</span>
<span class="sd">        E : array_like of cmplx or float</span>
<span class="sd">           the energy points. If `obj` is an instance of `SelfEnergy` where an</span>
<span class="sd">           associated ``eta`` is defined then `E` may be float, otherwise</span>
<span class="sd">           it *has* to be a complex array.</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">           chemical potential in the file</span>
<span class="sd">        obj : ..., optional</span>
<span class="sd">           an object that contains the Hamiltonian definitions, defaults to ``bz.parent``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">nspin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">na_u</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>
        <span class="n">no_u</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">xa</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span>
        <span class="c1"># The lasto in siesta requires lasto(0) == 0</span>
        <span class="c1"># and secondly, the Python index to fortran</span>
        <span class="c1"># index makes firsto behave like fortran lasto</span>
        <span class="n">lasto</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">firsto</span>
        <span class="n">bloch</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">E</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">]:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">eta</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bz</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">k</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">weight</span>

        <span class="n">sizes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;na_used&#39;</span><span class="p">:</span> <span class="n">na_u</span><span class="p">,</span>
            <span class="s1">&#39;nkpt&#39;</span><span class="p">:</span> <span class="n">Nk</span><span class="p">,</span>
            <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="n">NE</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">nspin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span>

        <span class="c1"># Ensure it is open (in write mode)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_gf</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="c1"># Now write to it...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;write_header&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">na_u</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">xa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lasto</span><span class="p">,</span>
                                <span class="n">bloch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">,</span> <span class="o">**</span><span class="n">sizes</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_header&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write header information.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write the current energy, k-point and H and S to the file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        H : matrix</span>
<span class="sd">           a square matrix corresponding to the Hamiltonian</span>
<span class="sd">        S : matrix, optional</span>
<span class="sd">           a square matrix corresponding to the overlap, for efficiency reasons</span>
<span class="sd">           it may be advantageous to specify this argument for orthogonal cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">H</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;write_hamiltonian&#39;</span><span class="p">,</span> <span class="n">HS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">],</span>
                            <span class="n">H</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                            <span class="n">S</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">no_u</span><span class="o">=</span><span class="n">no</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write Hamiltonian and overlap matrices.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SE</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Write the current self energy, k-point and H and S to the file</span>

<span class="sd">        The self-energy must correspond to the *bulk* self-energy</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol \Sigma_{\mathrm{bulk}}(E) = \mathbf S E - \mathbf H - \boldsymbol \Sigma(E)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        SE : matrix</span>
<span class="sd">           a square matrix corresponding to the self-energy (Green function)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;write_self_energy&#39;</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_se</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">],</span>
                            <span class="n">SE</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">no_u</span><span class="o">=</span><span class="n">no</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_self_energy&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write self-energy.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterate through the energies and k-points that this GF file is associated with</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        bool, list of float, float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get everything</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">ispin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ispin</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">yield</span> <span class="n">ispin</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">:</span>
                <span class="k">yield</span> <span class="kc">True</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">yield</span> <span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span>

        <span class="c1"># We will automatically close once we hit the end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">dic</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Always pass the docstring</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;__doc__&#39;</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dic</span><span class="p">[</span><span class="s1">&#39;__doc__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">),</span> <span class="n">dic</span><span class="p">)</span>

<span class="c1"># Faster than class ... \ pass</span>
<span class="n">tsgfSileSiesta</span> <span class="o">=</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;tsgfSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gfSileSiesta</span><span class="p">)</span>
<span class="n">gridSileSiesta</span> <span class="o">=</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;gridSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">})</span>

<span class="k">if</span> <span class="n">found_module</span><span class="p">:</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TSHS&#39;</span><span class="p">,</span> <span class="n">tshsSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;onlyS&#39;</span><span class="p">,</span> <span class="n">onlysSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TSDE&#39;</span><span class="p">,</span> <span class="n">tsdeSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;DM&#39;</span><span class="p">,</span> <span class="n">dmSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;HSX&#39;</span><span class="p">,</span> <span class="n">hsxSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TSGF&#39;</span><span class="p">,</span> <span class="n">tsgfSileSiesta</span><span class="p">)</span>
    <span class="c1"># These have unit-conversions</span>
    <span class="n">BohrC2AngC</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Bohr&#39;</span><span class="p">,</span> <span class="s1">&#39;Ang&#39;</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span>
    <span class="n">Ry2eV</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Ry&#39;</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;RHO&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;LDOS&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;ldosSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;RHOINIT&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoinitSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;RHOXC&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoxcSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;DRHO&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;drhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;BADER&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;baderSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;IOCH&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;iorhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TOCH&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;totalrhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="c1"># The following two files *require* that</span>
    <span class="c1">#  STM.DensityUnits   Ele/bohr**3</span>
    <span class="c1">#  which I can&#39;t check!</span>
    <span class="c1"># They are however the default</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;STS&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;stsSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;STM.LDOS&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;stmldosSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;VH&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;hartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="n">Ry2eV</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;VNA&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;neutralatomhartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="n">Ry2eV</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;totalhartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="n">Ry2eV</span><span class="p">}))</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2020, Nick Papior

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>