

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sisl.physics.brillouinzone &mdash; sisl |release| documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">Publications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications using sisl</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>sisl.physics.brillouinzone</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sisl.physics.brillouinzone</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Brillouin zone classes</span>
<span class="sd">=========================</span>

<span class="sd">.. module:: sisl.physics.brillouinzone</span>
<span class="sd">   :noindex:</span>

<span class="sd">The Brillouin zone objects are all special classes enabling easy manipulation</span>
<span class="sd">of an underlying physical quantity.</span>

<span class="sd">Quite often a physical quantity will be required to be averaged, or calculated individually</span>
<span class="sd">over a number of k-points. In this regard can the Brillouin zone objects help.</span>

<span class="sd">A basic principle of the BrillouinZone objects is that *any* method called on a BrillouinZone</span>
<span class="sd">object will defer to the attached parent to the class. Lets take an example.</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; bz = BrillouinZone(H)</span>
<span class="sd">&gt;&gt;&gt; bz.eigh()</span>

<span class="sd">This will actually calculate the eigenvalues for all k-points associated with the BrillouinZone.</span>
<span class="sd">This may be extremely convenient when calculating band-structures:</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; bs = BandStructure(H, [[0, 0, 0], [0.5, 0, 0]], 100)</span>
<span class="sd">&gt;&gt;&gt; bs_eig = bs.eigh().T</span>

<span class="sd">and then you have all eigenvalues for all the k-points.</span>

<span class="sd">Sometimes one may want to post-process the data for each k-point.</span>
<span class="sd">As an example lets post-process the DOS on a per k-point basis.</span>
<span class="sd"> </span>
<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">&gt;&gt;&gt; def wrap_DOS(eigenstate):</span>
<span class="sd">...    # Calculate the DOS for the eigenstates</span>
<span class="sd">...    DOS = eigenstate.DOS(E)</span>
<span class="sd">...    # Calculate the velocity for the eigenstates</span>
<span class="sd">...    v = eigenstate.velocity()</span>
<span class="sd">...    V = (v ** 2).sum(1)</span>
<span class="sd">...    return DOS.reshape(-1, 1) * v ** 2 / V.reshape(-1, 1)</span>
<span class="sd">&gt;&gt;&gt; DOS = mp.asaverage().eigenstate(wrap=wrap_DOS, eta=True)</span>

<span class="sd">This will, calculate the Monkhorst pack k-averaged DOS split into 3 Cartesian</span>
<span class="sd">directions based on the eigenstates velocity direction. This method of manipulating</span>
<span class="sd">the result can be extremely powerful to calculate many quantities while running an</span>
<span class="sd">efficient BrillouinZone average. The `eta` flag will print, to stdout, a progress-bar.</span>
<span class="sd">The usage of the ``wrap`` method are also passed optional arguments, ``parent`` which is</span>
<span class="sd">``H`` in the above example. ``k`` and ``weight`` are the current k-point and weight of the</span>
<span class="sd">corresponding k-point. An example could be to manipulate the DOS depending on the k-point and</span>
<span class="sd">weight:</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">&gt;&gt;&gt; def wrap_DOS(eigenstate, k, weight):</span>
<span class="sd">...    # Calculate the DOS for the eigenstates and weight by k_x and weight</span>
<span class="sd">...    return eigenstate.DOS(E) * k[0] * weight</span>
<span class="sd">&gt;&gt;&gt; DOS = mp.assum().eigenstate(wrap=wrap_DOS, eta=True)</span>

<span class="sd">When using wrap to calculate more than one quantity per eigenstate it may be advantageous</span>
<span class="sd">to use `~sisl.oplist` to handle cases of `BrillouinZone.asaverage` and `BrillouinZone.assum`.</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">&gt;&gt;&gt; def wrap_multiple(eigenstate):</span>
<span class="sd">...    # Calculate DOS/PDOS for eigenstates</span>
<span class="sd">...    DOS = eigenstate.DOS(E)</span>
<span class="sd">...    PDOS = eigenstate.PDOS(E)</span>
<span class="sd">...    # Calculate velocity for the eigenstates</span>
<span class="sd">...    v = eigenstate.velocity()</span>
<span class="sd">...    return oplist([DOS, PDOS, v])</span>
<span class="sd">&gt;&gt;&gt; DOS, PDOS, v = mp.asaverage().eigenstate(wrap=wrap_multiple, eta=True)</span>

<span class="sd">Which does mathematical operations (averaging/summing) using `~sisl.oplist`.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree:</span>

<span class="sd">   BrillouinZone</span>
<span class="sd">   MonkhorstPack</span>
<span class="sd">   BandStructure</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Real</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">pi</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">cross</span>

<span class="kn">from</span> <span class="nn">sisl.oplist</span> <span class="k">import</span> <span class="n">oplist</span>
<span class="kn">from</span> <span class="nn">sisl.unit</span> <span class="k">import</span> <span class="n">units</span>
<span class="kn">from</span> <span class="nn">sisl.quaternion</span> <span class="k">import</span> <span class="n">Quaternion</span>
<span class="kn">from</span> <span class="nn">sisl.utils.mathematics</span> <span class="k">import</span> <span class="n">cart2spher</span><span class="p">,</span> <span class="n">fnorm</span>
<span class="kn">from</span> <span class="nn">sisl.utils.misc</span> <span class="k">import</span> <span class="n">allow_kwargs</span>
<span class="kn">import</span> <span class="nn">sisl._array</span> <span class="k">as</span> <span class="nn">_a</span>
<span class="kn">from</span> <span class="nn">sisl.messages</span> <span class="k">import</span> <span class="n">info</span><span class="p">,</span> <span class="n">SislError</span><span class="p">,</span> <span class="n">tqdm_eta</span>
<span class="kn">from</span> <span class="nn">sisl.supercell</span> <span class="k">import</span> <span class="n">SuperCell</span>
<span class="kn">from</span> <span class="nn">sisl.grid</span> <span class="k">import</span> <span class="n">Grid</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;BrillouinZone&#39;</span><span class="p">,</span> <span class="s1">&#39;MonkhorstPack&#39;</span><span class="p">,</span> <span class="s1">&#39;BandStructure&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="BrillouinZone"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone">[docs]</a><span class="k">class</span> <span class="nc">BrillouinZone</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A class to construct Brillouin zone related quantities</span>

<span class="sd">    It takes any object (which has access to cell-vectors) as an argument</span>
<span class="sd">    and can then return the k-points in non-reduced units from reduced units.</span>

<span class="sd">    The object associated with the BrillouinZone object *has* to implement</span>
<span class="sd">    at least two different properties:</span>

<span class="sd">    1. `cell` which is the lattice vector</span>
<span class="sd">    2. `rcell` which is the reciprocal lattice vectors.</span>

<span class="sd">    The object may also be an array of floats in which case an internal</span>
<span class="sd">    `SuperCell` object will be created from the cell vectors (see `SuperCell` for</span>
<span class="sd">    details).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : object or array_like</span>
<span class="sd">       An object with associated ``parent.cell`` and ``parent.rcell`` or</span>
<span class="sd">       an array of floats which may be turned into a `SuperCell`</span>
<span class="sd">    k : array_like, optional</span>
<span class="sd">       k-points that this Brillouin zone represents</span>
<span class="sd">    weight : array_like, optional</span>
<span class="sd">       weights for the k-points. Must have the same length as `k`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="c1"># Gamma point</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.__init__ requires input k-points and weights to be of equal length.&#39;</span><span class="p">)</span>

        <span class="c1"># Instantiate the array call</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; String representation of the BrillouinZone &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;{{nk: </span><span class="si">{}</span><span class="s1">,</span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="se">\n</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;{{nk: </span><span class="si">{}</span><span class="s1">,</span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="se">\n</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">sc</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">))</span>

<div class="viewcode-block" id="BrillouinZone.parametrize"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.parametrize">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parametrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generate a new `BrillouinZone` object with k-points parameterized via the function `func` in `N` separations</span>

<span class="sd">        Generator of a parameterized Brillouin zone object that contains a parameterized k-point</span>
<span class="sd">        list.</span>

<span class="sd">        Basically this generates a new BrillouinZone object as:</span>

<span class="sd">        &gt;&gt;&gt; def func(sc, frac):</span>
<span class="sd">        ...    return [frac, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.parametrize(1, func, 10)</span>
<span class="sd">        &gt;&gt;&gt; len(bz) == 10</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(bz.k[-1, :], [9./10, 0, 0])</span>
<span class="sd">        True</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sc : SuperCell, or SuperCellChild</span>
<span class="sd">           the supercell used to construct the k-points</span>
<span class="sd">        func : callable</span>
<span class="sd">           method that parameterizes the k-points, *must* at least accept two arguments, ``sc``</span>
<span class="sd">           (super-cell object containing the unit-cell and reciprocal cell) and ``frac``</span>
<span class="sd">           (current parametrization fraction, between 0 and ``(N-1)/N``. It must return</span>
<span class="sd">           a k-point in 3 dimensions.</span>
<span class="sd">        N : int</span>
<span class="sd">           number of k-points generated using the parameterization</span>
<span class="sd">        args: list of arguments</span>
<span class="sd">           arguments passed directly to `func`</span>
<span class="sd">        kwargs: dictionary of arguments</span>
<span class="sd">           keyword arguments passed directly to `func`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrillouinZone.param_circle"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.param_circle">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">param_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">N_or_dk</span><span class="p">,</span> <span class="n">kR</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">origo</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a parameterized k-point list where the k-points are generated on a circle around an origo</span>

<span class="sd">        The generated circle is a perfect circle in the reciprocal space (Cartesian coordinates).</span>
<span class="sd">        To generate a perfect circle in units of the reciprocal lattice vectors one can</span>
<span class="sd">        generate the circle for a diagonal supercell with side-length :math:`2\pi`, see</span>
<span class="sd">        example below.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sc : SuperCell, or SuperCellChild</span>
<span class="sd">           the supercell used to construct the k-points</span>
<span class="sd">        N_or_dk : int</span>
<span class="sd">           number of k-points generated using the parameterization (if an integer),</span>
<span class="sd">           otherwise it specifies the discretization length on the circle (in 1/Ang),</span>
<span class="sd">           If the latter case will use less than 4 points a warning will be raised and</span>
<span class="sd">           the number of points increased to 4.</span>
<span class="sd">        kR : float</span>
<span class="sd">           radius of the k-point. In 1/Ang</span>
<span class="sd">        normal : array_like of float</span>
<span class="sd">           normal vector to determine the circle plane</span>
<span class="sd">        origo : array_like of float</span>
<span class="sd">           origo of the circle used to generate the circular parameterization</span>
<span class="sd">        loop : bool, optional</span>
<span class="sd">           whether the first and last point are equal</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell([1, 1, 10, 90, 90, 60])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.param_circle(sc, 10, 0.05, [0, 0, 1], [1./3, 2./3, 0])</span>

<span class="sd">        To generate a circular set of k-points in reduced coordinates (reciprocal</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell([1, 1, 10, 90, 90, 60])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.param_circle(sc, 10, 0.05, [0, 0, 1], [1./3, 2./3, 0])</span>
<span class="sd">        &gt;&gt;&gt; bz_rec = BrillouinZone.param_circle(2*np.pi, 10, 0.05, [0, 0, 1], [1./3, 2./3, 0])</span>
<span class="sd">        &gt;&gt;&gt; bz.k[:, :] = bz_rec.k[:, :]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BrillouinZone : with the parameterized k-points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N_or_dk</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">N_or_dk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate the required number of points</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kR</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">N_or_dk</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>
                <span class="n">info</span><span class="p">(</span><span class="s1">&#39;BrillouinZone.param_circle increased the number of circle points to 4.&#39;</span><span class="p">)</span>

        <span class="c1"># Conversion object</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

        <span class="n">normal</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">origo</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">origo</span><span class="p">)</span>
        <span class="n">k_n</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">k_o</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">origo</span><span class="p">)</span>

        <span class="c1"># Generate a preset list of k-points on the unit-circle</span>
        <span class="k">if</span> <span class="n">loop</span><span class="p">:</span>
            <span class="n">radians</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radians</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">k</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
        <span class="n">k</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
        <span class="n">k</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Now generate the rotation</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2spher</span><span class="p">(</span><span class="n">k_n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="n">k_n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pv</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">Quaternion</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k_n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">k_n</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Calculate k-points</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">*=</span> <span class="n">kR</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">toreduced</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">k_o</span><span class="p">)</span>

        <span class="c1"># The sum of weights is equal to the BZ area</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">kR</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">W</span> <span class="o">/</span> <span class="n">N</span><span class="p">],</span> <span class="n">N</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrillouinZone.set_parent"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.set_parent">[docs]</a>    <span class="k">def</span> <span class="nf">set_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Update the parent associated to this object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : object or array_like</span>
<span class="sd">           an object containing cell vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># It probably has the supercell attached</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">cell</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">rcell</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrillouinZone.copy"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a copy of this object &quot;&quot;&quot;</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">bz</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bz</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">bz</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A list of all k-points (if available) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Weight of the k-points in the `BrillouinZone` object &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">cell</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rcell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">rcell</span>

<div class="viewcode-block" id="BrillouinZone.tocartesian"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.tocartesian">[docs]</a>    <span class="k">def</span> <span class="nf">tocartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Transfer a k-point in reduced coordinates to the Cartesian coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : list of float</span>
<span class="sd">           k-point in reduced coordinates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k : in units of 1/Ang</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcell</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrillouinZone.toreduced"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.toreduced">[docs]</a>    <span class="k">def</span> <span class="nf">toreduced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Transfer a k-point in Cartesian coordinates to the reduced coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : list of float</span>
<span class="sd">           k-point in Cartesian coordinates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k : in units of reciprocal lattice vectors ]-0.5 ; 0.5] (if k is in the primitive cell)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">))</span></div>

<div class="viewcode-block" id="BrillouinZone.in_primitive"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.in_primitive">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Move the k-point into the primitive point(s) ]-0.5 ; 0.5]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">           k-point(s) to move into the primitive cell</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k : all k-points moved into the primitive cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.</span>

        <span class="c1"># Ensure that we are in the interval ]-0.5; 0.5]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span> <span class="o">-=</span> <span class="mf">1.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span> <span class="o">+=</span> <span class="mf">1.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">k</span></div>

    <span class="n">_bz_attr</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span> <span class="o">=</span> <span class="n">attr</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; does not exist in class &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">attr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_bz_get_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Internal method to retrieve the actual function to be called &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span><span class="p">)</span>

<div class="viewcode-block" id="BrillouinZone.call"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Call the function `func` and run as though the function has been called</span>

<span class="sd">        This is a wrapper to call user-defined functions not attached to the parent</span>
<span class="sd">        object.</span>

<span class="sd">        The below example shows that the equivalence of the call.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone(H)</span>
<span class="sd">        &gt;&gt;&gt; bz.eigh() == bz.call(H.eigh)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">           method used</span>
<span class="sd">        *args :</span>
<span class="sd">           arguments passed to func in the call sequence</span>
<span class="sd">        **kwargs :</span>
<span class="sd">           keyword arguments passed to func in the call sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span> <span class="o">=</span> <span class="n">func</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># Implement wrapper calls</span>
<div class="viewcode-block" id="BrillouinZone.asarray"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.asarray">[docs]</a>    <span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with `numpy.ndarray` returned quantities</span>

<span class="sd">        This forces the `__call__` routine to return a single array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(...)</span>
<span class="sd">        &gt;&gt;&gt; obj.asarray().eigh(eta=True)</span>

<span class="sd">        To compute multiple things in one go one should use wrappers to contain</span>
<span class="sd">        the calculation</span>

<span class="sd">        &gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">        &gt;&gt;&gt; dist = get_distribution(&#39;gaussian&#39;, smearing=0.1)</span>
<span class="sd">        &gt;&gt;&gt; def wrap(es, parent, k, weight):</span>
<span class="sd">        ...    DOS = es.DOS(E, distribution=dist)</span>
<span class="sd">        ...    PDOS = es.PDOS(E, distribution=dist)</span>
<span class="sd">        ...    occ = es.occupation()</span>
<span class="sd">        ...    spin_moment = (es.spin_moment(E, distribution=dist) * occ.reshape(-1, 1)).sum(0)</span>
<span class="sd">        ...    return oplist([DOS, PDOS, spin_moment])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone(hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; DOS, PDOS, spin_moment = bz.asaverage().eigenstate(wrap=wrap)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">tqdm_eta</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.asarray&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">del</span> <span class="n">v</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="c1"># Set instance __bz_call</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_call</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.asnone"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.asnone">[docs]</a>    <span class="k">def</span> <span class="nf">asnone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with None, this may be done for instance when wrapping the function calls.</span>

<span class="sd">        This forces the `__call__` routine to return ``None``. This usage is mainly intended when</span>
<span class="sd">        creating custom `wrap` function calls.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(...)</span>
<span class="sd">        &gt;&gt;&gt; obj.asnone().eigh(eta=True)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">tqdm_eta</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.asnone&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_call</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.aslist"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.aslist">[docs]</a>    <span class="k">def</span> <span class="nf">aslist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with `list` returned quantities</span>

<span class="sd">        This forces the `__call__` routine to return a list with returned values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(...)</span>
<span class="sd">        &gt;&gt;&gt; def first_ten(es):</span>
<span class="sd">        ...    return es.sub(range(10))</span>
<span class="sd">        &gt;&gt;&gt; obj.aslist().eigenstate(eta=True, wrap=first_ten)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">tqdm_eta</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.aslist&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_call</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.asyield"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.asyield">[docs]</a>    <span class="k">def</span> <span class="nf">asyield</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with yielded quantities</span>

<span class="sd">        This forces the `__call__` routine to return a an iterator which may</span>
<span class="sd">        yield the quantities calculated.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.asyield().eigh(eta=True)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">tqdm_eta</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.asyield&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_call</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.asaverage"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.asaverage">[docs]</a>    <span class="k">def</span> <span class="nf">asaverage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with k-averaged quantities</span>

<span class="sd">        This forces the `__call__` routine to return a single k-averaged value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.asaverage().DOS(np.linspace(-2, 2, 100))</span>

<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.asaverage()</span>
<span class="sd">        &gt;&gt;&gt; obj.DOS(np.linspace(-2, 2, 100))</span>
<span class="sd">        &gt;&gt;&gt; obj.PDOS(np.linspace(-2, 2, 100), eta=True)</span>

<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.asaverage()</span>
<span class="sd">        &gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">        &gt;&gt;&gt; def wrap(es):</span>
<span class="sd">        ...    return es.DOS(E), es.PDOS(E)</span>
<span class="sd">        &gt;&gt;&gt; DOS, PDOS = obj.eigenstate(wrap=wrap)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">tqdm_eta</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.asaverage&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_call</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.assum"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.assum">[docs]</a>    <span class="k">def</span> <span class="nf">assum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with summed quantities</span>

<span class="sd">        This forces the `__call__` routine to return all k-point values summed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.assum().DOS(np.linspace(-2, 2, 100))</span>

<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.assum()</span>
<span class="sd">        &gt;&gt;&gt; obj.DOS(np.linspace(-2, 2, 100))</span>
<span class="sd">        &gt;&gt;&gt; obj.PDOS(np.linspace(-2, 2, 100), eta=True)</span>

<span class="sd">        &gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">        &gt;&gt;&gt; dist = get_distribution(&#39;gaussian&#39;, smearing=0.1)</span>
<span class="sd">        &gt;&gt;&gt; def wrap(es, parent, k, weight):</span>
<span class="sd">        ...    DOS = es.DOS(E, distribution=dist) * weight</span>
<span class="sd">        ...    PDOS = es.PDOS(E, distribution=dist) * weight</span>
<span class="sd">        ...    occ = es.occupation()</span>
<span class="sd">        ...    spin_moment = (es.spin_moment(E, distribution=dist) * occ.reshape(-1, 1)).sum(0) * weight</span>
<span class="sd">        ...    return oplist([DOS, PDOS, spin_moment])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone(hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; DOS, PDOS, spin_moment = bz.assum().eigenstate(wrap=wrap)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">tqdm_eta</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.assum&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">oplist</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">oplist</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_call</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calls the given attribute of the internal object and returns the quantity</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : optional</span>
<span class="sd">            arguments passed to the attribute call, note that an argument `k=k` will be</span>
<span class="sd">            added by this routine as a way to loop the k-points.</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">            keyword arguments passed to the attribute call, note that the first argument</span>
<span class="sd">            will *always* be `k`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        getattr(self, attr)(k, *args, **kwargs) : whatever this returns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">call</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Could not call the object it self&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="BrillouinZone.iter"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.iter">[docs]</a>    <span class="k">def</span> <span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; An iterator for the k-points and (possibly) the weights</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ret_weight : bool, optional</span>
<span class="sd">          if true, also yield the weight for the respective k-point</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        kpt : k-point</span>
<span class="sd">        weight : weight of k-point, only if `ret_weight` is true.</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ret_weight</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">k</span></div>

    <span class="fm">__iter__</span> <span class="o">=</span> <span class="nb">iter</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">)</span>

<div class="viewcode-block" id="BrillouinZone.write"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BrillouinZone.html#sisl.physics.BrillouinZone.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sile</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes k-points to a `~sisl.io.tableSile`.</span>

<span class="sd">        This allows one to pass a `tableSile` or a file-name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="k">import</span> <span class="n">tableSile</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">tableSile</span><span class="p">):</span>
            <span class="n">sile</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">tableSile</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MonkhorstPack"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.MonkhorstPack.html#sisl.physics.MonkhorstPack">[docs]</a><span class="k">class</span> <span class="nc">MonkhorstPack</span><span class="p">(</span><span class="n">BrillouinZone</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a Monkhorst-Pack grid for the Brillouin zone</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : object or array_like</span>
<span class="sd">       An object with associated `parent.cell` and `parent.rcell` or</span>
<span class="sd">       an array of floats which may be turned into a `SuperCell`</span>
<span class="sd">    nktp : array_like of ints</span>
<span class="sd">       a list of number of k-points along each cell direction</span>
<span class="sd">    displacement : float or array_like of float, optional</span>
<span class="sd">       the displacement of the evenly spaced grid, a single floating</span>
<span class="sd">       number is the displacement for the 3 directions, else they</span>
<span class="sd">       are the individual displacements</span>
<span class="sd">    size : float or array_like of float, optional</span>
<span class="sd">       the size of the Brillouin zone sampled. This reduces the boundaries</span>
<span class="sd">       of the Brillouin zone around the displacement to the fraction specified.</span>
<span class="sd">       I.e. `size` must be of values :math:`]0 ; 1]`. Defaults to the entire BZ.</span>
<span class="sd">       Note that this will also reduce the weights such that the weights</span>
<span class="sd">       are normalized to the entire BZ.</span>
<span class="sd">    centered : bool, optional</span>
<span class="sd">       whether the k-points are :math:`\Gamma`-centered (for zero displacement)</span>
<span class="sd">    trs : bool, optional</span>
<span class="sd">       whether time-reversal symmetry exists in the Brillouin zone.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sc = SuperCell(3.)</span>
<span class="sd">    &gt;&gt;&gt; MonkhorstPack(sc, 10) # 10 x 10 x 10 (with TRS)</span>
<span class="sd">    &gt;&gt;&gt; MonkhorstPack(sc, [10, 5, 5]) # 10 x 5 x 5 (with TRS)</span>
<span class="sd">    &gt;&gt;&gt; MonkhorstPack(sc, [10, 5, 5], trs=False) # 10 x 5 x 5 (without TRS)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">displacement</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MonkhorstPack</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nkpt</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">nkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">nkpt</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">nkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nkpt</span><span class="p">)</span>

        <span class="c1"># Now we have a matrix of k-points</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nkpt</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nkpt</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; with off-diagonal components is not implemented yet&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">displacement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">displacement</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">displacement</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># Retrieve the diagonal number of values</span>
        <span class="n">Dn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nkpt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Dn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; *must* be initialized with &#39;</span>
                             <span class="s1">&#39;diagonal elements different from 0.&#39;</span><span class="p">)</span>

        <span class="n">i_trs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">trs</span><span class="p">:</span>
            <span class="c1"># Figure out which direction to TRS</span>
            <span class="n">nmax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">displacement</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span> <span class="ow">and</span> <span class="n">Dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nmax</span><span class="p">:</span>
                    <span class="n">nmax</span> <span class="o">=</span> <span class="n">Dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">i_trs</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">nmax</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">i_trs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">i_trs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># If we still haven&#39;t decided (say for weird displacements)</span>
                <span class="c1"># simply take the one with the maximum number of k-points.</span>
                <span class="n">i_trs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Dn</span><span class="p">)</span>

        <span class="c1"># Calculate k-points and weights along all directions</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">Dn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">displacement</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">centered</span><span class="p">,</span> <span class="n">i</span> <span class="o">==</span> <span class="n">i_trs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">((</span><span class="n">kw</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">kw</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">kw</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">kw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">&gt;</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># Store information regarding size and diagonal elements</span>
        <span class="c1"># This information is basically only necessary when</span>
        <span class="c1"># we want to replace special k-points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span> <span class="o">=</span> <span class="n">Dn</span> <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span> <span class="o">=</span> <span class="n">displacement</span> <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">size</span> <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span> <span class="o">=</span> <span class="n">centered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">=</span> <span class="n">i_trs</span>

<div class="viewcode-block" id="MonkhorstPack.copy"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.MonkhorstPack.html#sisl.physics.MonkhorstPack.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a copy of this object &quot;&quot;&quot;</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bz</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bz</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">bz</span></div>

<div class="viewcode-block" id="MonkhorstPack.asgrid"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.MonkhorstPack.html#sisl.physics.MonkhorstPack.asgrid">[docs]</a>    <span class="k">def</span> <span class="nf">asgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with Grid quantities</span>

<span class="sd">        This forces the `__call__` routine to return all k-point values in a regular grid.</span>

<span class="sd">        The calculation of values on a grid requires some careful thought before</span>
<span class="sd">        running the calculation as the returned grid may be somewhat difficult</span>
<span class="sd">        to comprehend.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>
<span class="sd">        data_axis : int, optional</span>
<span class="sd">           the Grid axis to put in the data values in. Has to be specified if the</span>
<span class="sd">           subsequent routine calls return more than 1 data-point per k-point.</span>
<span class="sd">        grid_unit : {&#39;b&#39;, &#39;Ang&#39;, &#39;Bohr&#39;}, optional</span>
<span class="sd">           for &#39;b&#39; the returned grid will be a cube, otherwise the grid will be the reciprocal lattice</span>
<span class="sd">           vectors (for any other value) and in the given reciprocal unit (&#39;Ang&#39; =&gt; 1/Ang)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = MonkhorstPack(Hamiltonian, [10, 1, 10])</span>
<span class="sd">        &gt;&gt;&gt; grid = obj.asgrid().eigh(data_axis=1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">data_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;data_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">grid_unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>

            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">tqdm_eta</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.asgrid&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>

            <span class="c1"># Extract information from the MP grid, these values</span>
            <span class="c1"># define the Grid size, etc.</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_displ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{}</span><span class="s1"> requires the displacement to be 0 for all k-points.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span><span class="p">))</span>
            <span class="n">displ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">diag</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diag</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">steps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diag</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">steps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>

            <span class="c1"># Instead of doing</span>
            <span class="c1">#    _in_primitive(k) + 0.5 - offset</span>
            <span class="c1"># we can do it here</span>
            <span class="c1">#    _in_primitive(k) + offset&#39;</span>
            <span class="n">offset</span> <span class="o">-=</span> <span class="mf">0.5</span>

            <span class="c1"># Check the TRS direction</span>
            <span class="n">trs_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span>
            <span class="n">_in_primitive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span>
            <span class="n">_rint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span>
            <span class="n">_int32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
            <span class="k">def</span> <span class="nf">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="c1"># In case TRS is applied two indices may be returned</span>
                <span class="k">return</span> <span class="n">_rint</span><span class="p">((</span><span class="n">_in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">steps</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_int32</span><span class="p">)</span>
                <span class="c1"># To find the opposite k-point, do this</span>
                <span class="c1">#  idx[i] = [diag[i] - idx[i] - 1, idx[i]</span>
                <span class="c1"># with i in [0, 1, 2]</span>

            <span class="c1"># Create cell from the reciprocal cell.</span>
            <span class="k">if</span> <span class="n">grid_unit</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">rcell</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">units</span><span class="p">(</span><span class="s1">&#39;Ang&#39;</span><span class="p">,</span> <span class="n">grid_unit</span><span class="p">)</span>

            <span class="c1"># Find the grid origo</span>
            <span class="n">origo</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">cell</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Calculate first k-point (to get size and dtype)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">data_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{}</span><span class="s1"> requires one value per-kpoint because of the 3D grid values&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># Check the weights</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">diag</span><span class="p">[</span><span class="n">data_axis</span><span class="p">],</span> <span class="n">displ</span><span class="p">[</span><span class="n">data_axis</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="n">data_axis</span><span class="p">],</span>
                                    <span class="n">centered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="n">trs_axis</span> <span class="o">==</span> <span class="n">data_axis</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Correct the Grid size</span>
                <span class="n">diag</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="c1"># Create the orthogonal cell direction to ensure it is orthogonal</span>
                <span class="c1"># Since array axis is cyclic for negative numbers, we simply do this</span>
                <span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
                <span class="c1"># Check whether we should rotate it</span>
                <span class="k">if</span> <span class="n">cart2spher</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="p">,</span> <span class="p">:])[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># Correct cell for the grid</span>
            <span class="k">if</span> <span class="n">trs_axis</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">origo</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="c1"># Correct offset since we only have the positive halve</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">:</span>
                    <span class="n">offset</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">offset</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

                <span class="c1"># Find number of points</span>
                <span class="k">if</span> <span class="n">trs_axis</span> <span class="o">!=</span> <span class="n">data_axis</span><span class="p">:</span>
                    <span class="n">diag</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">diag</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">],</span> <span class="n">displ</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">],</span>
                                                   <span class="n">centered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Create the grid in the reciprocal cell</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">origo</span><span class="o">=</span><span class="n">origo</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">diag</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]]</span>
                <span class="n">idx</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">weight</span>

            <span class="k">del</span> <span class="n">v</span>

            <span class="c1"># Now perform calculation</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">data_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
                                             <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]]</span>
                    <span class="n">idx</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
                                     <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">weight</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">grid</span>

        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_call</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MonkhorstPack.grid"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.MonkhorstPack.html#sisl.physics.MonkhorstPack.grid">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">displ</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a grid of `n` points with an offset of `displ` and sampling `size` around `displ`</span>

<span class="sd">        The :math:`k`-points are :math:`\Gamma` centered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">           number of points in the grid. If `trs` is ``True`` this may be smaller than `n`</span>
<span class="sd">        displ : float, optional</span>
<span class="sd">           the displacement of the grid</span>
<span class="sd">        size : float, optional</span>
<span class="sd">           the total size of the Brillouin zone to sample</span>
<span class="sd">        centered : bool, optional</span>
<span class="sd">           if the points are centered</span>
<span class="sd">        trs : bool, optional</span>
<span class="sd">           whether time-reversal-symmetry is applied</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k : np.ndarray</span>
<span class="sd">           the list of k-points in the Brillouin zone to be sampled</span>
<span class="sd">        w : np.ndarray</span>
<span class="sd">           weights for the k-points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First ensure that displ is in the Brillouin</span>
        <span class="n">displ</span> <span class="o">=</span> <span class="n">displ</span> <span class="o">%</span> <span class="mf">1.</span>
        <span class="k">if</span> <span class="n">displ</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">displ</span> <span class="o">-=</span> <span class="mf">1.</span>
        <span class="k">if</span> <span class="n">displ</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">:</span>
            <span class="n">displ</span> <span class="o">+=</span> <span class="mf">1.</span>

        <span class="c1"># Centered _only_ has effect IFF</span>
        <span class="c1">#  displ == 0. and size == 1</span>
        <span class="c1"># Otherwise we resort to other schemes</span>
        <span class="k">if</span> <span class="n">displ</span> <span class="o">!=</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">centered</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># We create the full grid, then afterwards we figure out TRS</span>
        <span class="n">n_half</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="o">-</span><span class="n">n_half</span><span class="p">,</span> <span class="n">n_half</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span> <span class="o">/</span> <span class="n">n</span> <span class="o">+</span> <span class="n">displ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="o">-</span><span class="n">n_half</span><span class="p">,</span> <span class="n">n_half</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span> <span class="o">/</span> <span class="n">n</span> <span class="o">+</span> <span class="n">displ</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">centered</span><span class="p">:</span>
                <span class="c1"># Shift everything by halve the size each occupies</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># Move k to the primitive cell and generate weights</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">size</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># Check for TRS points</span>
        <span class="k">if</span> <span class="n">trs</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="c1"># Make all positive to remove the double conting terms</span>
            <span class="n">k_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

            <span class="c1"># Sort k-points and weights</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">k_pos</span><span class="p">)</span>

            <span class="c1"># Re-arange according to k value</span>
            <span class="n">k_pos</span> <span class="o">=</span> <span class="n">k_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="c1"># Find indices of all equivalent k-points (tolerance of 1e-10 in reciprocal units)</span>
            <span class="c1">#  1e-10 ~ 1e10 k-points (no body will do this!)</span>
            <span class="n">idx_same</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">k_pos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># The above algorithm should never create more than two duplicates.</span>
            <span class="c1"># Hence we can simply remove all idx_same and double the weight for all</span>
            <span class="c1"># idx_same + 1.</span>
            <span class="n">w</span><span class="p">[</span><span class="n">idx_same</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="c1"># Delete the duplicated k-points (they are already sorted)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">k_pos</span><span class="p">,</span> <span class="n">idx_same</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">idx_same</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sort them, because it makes more visual sense</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Return values</span>
        <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span></div>

<div class="viewcode-block" id="MonkhorstPack.replace"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.MonkhorstPack.html#sisl.physics.MonkhorstPack.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Replace a k-point with a new set of k-points from a Monkhorst-Pack grid</span>

<span class="sd">        This method tries to replace an area corresponding to `mp.size` around the k-point `k`</span>
<span class="sd">        such that the k-points are replaced.</span>
<span class="sd">        This enables one to zoom in on specific points in the Brillouin zone for detailed analysis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">           k-point in this object to replace</span>
<span class="sd">        mp : MonkhorstPack</span>
<span class="sd">           object containing the replacement k-points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        This example creates a zoomed-in view of the :math:`\Gamma`-point by replacing it with</span>
<span class="sd">        a 3x3x3 Monkhorst-Pack grid.</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell(1.)</span>
<span class="sd">        &gt;&gt;&gt; mp = MonkhorstPack(sc, [3, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mp.replace([0, 0, 0], MonkhorstPack(sc, [3, 3, 3], size=1./3))</span>

<span class="sd">        This example creates a zoomed-in view of the :math:`\Gamma`-point by replacing it with</span>
<span class="sd">        a 4x4x4 Monkhorst-Pack grid.</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell(1.)</span>
<span class="sd">        &gt;&gt;&gt; mp = MonkhorstPack(sc, [3, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mp.replace([0, 0, 0], MonkhorstPack(sc, [4, 4, 4], size=1./3))</span>

<span class="sd">        This example creates a zoomed-in view of the :math:`\Gamma`-point by replacing it with</span>
<span class="sd">        a 4x4x1 Monkhorst-Pack grid.</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell(1.)</span>
<span class="sd">        &gt;&gt;&gt; mp = MonkhorstPack(sc, [3, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mp.replace([0, 0, 0], MonkhorstPack(sc, [4, 4, 1], size=1./3))</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        SislError : if the size of the replacement `MonkhorstPack` grid is not compatible with the</span>
<span class="sd">                    k-point spacing in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we find all k-points within k +- mp.size</span>
        <span class="c1"># Those are the points we wish to remove.</span>
        <span class="c1"># Secondly we need to ensure that the k-points we remove are occupying *exactly*</span>
        <span class="c1"># the Brillouin zone we wish to replace.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">MonkhorstPack</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Object `mp` is not a MonkhorstPack object&#39;</span><span class="p">)</span>

        <span class="c1"># We can easily figure out the BZ that each k-point is averaging</span>
        <span class="n">k_vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span>
        <span class="c1"># Compare against the size of this one</span>
        <span class="c1"># Since we can remove more than one k-point, we require that the</span>
        <span class="c1"># size of the replacement MP is an integer multiple of the</span>
        <span class="c1"># k-point volumes.</span>
        <span class="n">k_int</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="n">k_vol</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">k_int</span><span class="p">),</span> <span class="n">k_int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.reduce could not replace k-point, BZ &#39;</span>
                            <span class="s1">&#39;volume replaced is not equivalent to the inherent k-point volume.&#39;</span><span class="p">)</span>
        <span class="n">k_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">k_int</span><span class="p">)</span>

        <span class="c1"># 1. find all k-points</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Find all points within [k - dk; k + dk]</span>
        <span class="c1"># Since the volume of each k-point is non-zero we know that no k-points will be located</span>
        <span class="c1"># on the boundary.</span>
        <span class="c1"># This does remove boundary points because we shift everything into the positive</span>
        <span class="c1"># plane.</span>
        <span class="n">diff_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">%</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">k</span> <span class="o">%</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_k</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.reduce could not find any points to replace.&#39;</span><span class="p">)</span>

        <span class="c1"># Now we have the k-points we need to remove</span>
        <span class="c1"># Figure out if the total weight is consistent</span>
        <span class="n">total_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">replace_weight</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">total_weight</span> <span class="o">-</span> <span class="n">replace_weight</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
            <span class="n">weight_factor</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">total_weight</span> <span class="o">-</span> <span class="n">replace_weight</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
            <span class="n">weight_factor</span> <span class="o">=</span> <span class="mf">2.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.reduce assumes that the replaced k-point has double weights.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k-point to replace:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;delta-k:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">dk</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found k-indices that will be replaced:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k-points replaced:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.reduce could not assert the weights are consistent during replacement.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Append the new k-points and weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">_k</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">_w</span> <span class="o">*</span> <span class="n">weight_factor</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="BandStructure"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BandStructure.html#sisl.physics.BandStructure">[docs]</a><span class="k">class</span> <span class="nc">BandStructure</span><span class="p">(</span><span class="n">BrillouinZone</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a path in the Brillouin zone for plotting band-structures etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : object or array_like</span>
<span class="sd">       An object with associated `parentcell` and `parent.rcell` or</span>
<span class="sd">       an array of floats which may be turned into a `SuperCell`</span>
<span class="sd">    point : array_like of float</span>
<span class="sd">       a list of points that are the *corners* of the path</span>
<span class="sd">    division : int or array_like of int</span>
<span class="sd">       number of divisions in each segment.</span>
<span class="sd">       If a single integer is passed it is the total number</span>
<span class="sd">       of points on the path (equally separated).</span>
<span class="sd">       If it is an array_like input it must have length one</span>
<span class="sd">       less than `point`.</span>
<span class="sd">    name : array_like of str</span>
<span class="sd">       the associated names of the points on the Brillouin Zone path</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sc = SuperCell(10)</span>
<span class="sd">    &gt;&gt;&gt; bs = BandStructure(sc, [[0] * 3, [0.5] * 3], 200)</span>
<span class="sd">    &gt;&gt;&gt; bs = BandStructure(sc, [[0] * 3, [0.5] * 3, [1.] * 3], 200)</span>
<span class="sd">    &gt;&gt;&gt; bs = BandStructure(sc, [[0] * 3, [0.5] * 3, [1.] * 3], 200, [&#39;Gamma&#39;, &#39;M&#39;, &#39;Gamma&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BandStructure</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="c1"># Copy over points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="c1"># If the array has fewer points we try and determine</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not determine the non-periodic direction&#39;</span><span class="p">)</span>

            <span class="c1"># fix the points where there are no periodicity</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Ensure the shape is correct</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Now figure out what to do with the divisions</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">division</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>

            <span class="c1"># Calculate points (we need correct units for distance)</span>
            <span class="n">kpts</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">kpts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">kpts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>

            <span class="n">div</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">dists</span> <span class="o">/</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">division</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">div</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">division</span><span class="p">:</span>
                <span class="n">div</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">div</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">division</span><span class="p">:</span>
                <span class="c1"># Get the separation of k-points</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">n</span>

                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">div</span><span class="p">)</span>
                <span class="n">div</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">div</span><span class="p">)</span>

            <span class="n">division</span> <span class="o">=</span> <span class="n">div</span><span class="p">[:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">division</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">division</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">division</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;ABCDEFGHIJKLMNOPQRSTUVXYZ&#39;</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterate through the path &quot;&quot;&quot;</span>

        <span class="c1"># Calculate points</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">)):</span>

            <span class="c1"># Calculate this delta</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># to get end-point</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">dk</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">division</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">dk</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">division</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">division</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">delta</span>

<div class="viewcode-block" id="BandStructure.lineartick"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BandStructure.html#sisl.physics.BandStructure.lineartick">[docs]</a>    <span class="k">def</span> <span class="nf">lineartick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The tick-marks corresponding to the linear-k values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linear_k : The positions in reciprocal space determined by the distance between points</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        lineark : Routine used to calculate the tick-marks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineark</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span></div>

<div class="viewcode-block" id="BandStructure.lineark"><a class="viewcode-back" href="../../../api-generated/sisl.physics.brillouinzone.BandStructure.html#sisl.physics.BandStructure.lineark">[docs]</a>    <span class="k">def</span> <span class="nf">lineark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A 1D array which corresponds to the delta-k values of the path</span>

<span class="sd">        This is meant for plotting</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; p = BandStructure(...)</span>
<span class="sd">        &gt;&gt;&gt; eigs = Hamiltonian.eigh(p)</span>
<span class="sd">        &gt;&gt;&gt; for i in range(len(Hamiltonian)):</span>
<span class="sd">        ...     plt.plot(p.lineark(), eigs[:, i])</span>

<span class="sd">        &gt;&gt;&gt; p = BandStructure(...)</span>
<span class="sd">        &gt;&gt;&gt; eigs = Hamiltonian.eigh(p)</span>
<span class="sd">        &gt;&gt;&gt; lk, kt, kl = p.lineark(True)</span>
<span class="sd">        &gt;&gt;&gt; plt.xticks(kt, kl)</span>
<span class="sd">        &gt;&gt;&gt; for i in range(len(Hamiltonian)):</span>
<span class="sd">        ...     plt.plot(lk, eigs[:, i])</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ticks : bool, optional</span>
<span class="sd">           if `True` the ticks for the points are also returned</span>

<span class="sd">           lk, xticks, label_ticks, lk = BandStructure.lineark(True)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linear_k : The positions in reciprocal space determined by the distance between points</span>
<span class="sd">        k_tick : Linear k-positions of the points, only returned if `ticks` is ``True``</span>
<span class="sd">        k_label : Labels at `k_tick`, only returned if `ticks` is ``True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate points</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">]</span>
        <span class="c1"># Get difference between points</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Calculate the cumultative distance between points</span>
        <span class="n">k_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumd</span><span class="p">((</span><span class="n">dk</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">xtick</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="c1"># Prepare output array</span>
        <span class="n">dK</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># short-hand</span>
        <span class="n">ls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span>

        <span class="n">xtick</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">division</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">)):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">division</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">dK</span><span class="p">[</span><span class="n">xtick</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">xtick</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ls</span><span class="p">(</span><span class="n">k_len</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">k_len</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>
        <span class="n">xtick</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># Get label tick, in case self.name is a single string &#39;ABCD&#39;</span>
        <span class="n">label_tick</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ticks</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dK</span><span class="p">,</span> <span class="n">dK</span><span class="p">[</span><span class="n">xtick</span><span class="p">],</span> <span class="n">label_tick</span>
        <span class="k">return</span> <span class="n">dK</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">division</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2018, Nick Papior

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>