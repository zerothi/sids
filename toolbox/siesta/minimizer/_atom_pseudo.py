import sys
from pathlib import Path
from functools import partial

import numpy as np
import sisl as si

from ._variable import UpdateVariable


__all__ = ["AtomPseudo"]


_Ang2Bohr = si.units.convert("Ang", "Bohr")

_orbs_core_val = {
    'Bi': (13, 4),
    'Al': (3, 4),
    'Cu': (5, 4),
    'C': (1, 4),
}


class AtomPseudo:
    """Input for the ``atom`` program see `[1]`_

    This class enables the construction of the ``INP`` file to be fed to ``atom``.


    # Example input for ATOM
    #
    #  Comments allowed here
    #
    #   ae Si ground state all-electron
    #   Si   car
    #       0.0
    #    3    2
    #    3    0      2.00      0.00
    #    3    1      2.00      0.00
    #
    # Comments allowed here
    #
    #2345678901234567890123456789012345678901234567890      Ruler

    .. [1]: https://siesta.icmab.es/SIESTA_MATERIAL/Pseudos/atom_licence.html
    """

    def __init__(self, atom,
                 define=('NEW_CC', 'FREE_FORMAT_RC_INPUT', 'NO_PS_CUTOFFS'),
                 opts=None):
        # opts = {
        #   "flavor": "tm2",
        #   "xc": "pb",
        #   "equation": "r",
        #   "logr": 2.
        #   "cc": False,
        #   "rcore": 2.

        self.atom = atom
        assert isinstance(atom, si.Atom)
        if "." in self.atom.tag:
            raise ValueError("The atom 'tag' must not contain a '.'!")

        # We need to check that atom has 4 orbitals, with increasing l
        # We don't care about n or any other stuff, so these could be
        # SphericalOrbital, for that matter
        l = 0
        for orb in self.atom:
            if orb.l != l:
                raise ValueError(f"{self.__class__.__name__} atom argument does not have "
                                 f"increasing l quantum number index {l} has l={orb.l}")
            l += 1
        if l != 4:
            raise ValueError(f"{self.__class__.__name__} atom argument must have 4 orbitals. "
                             f"One for each s-p-d-f shell")

        if opts is None:
            self.opts = si.utils.PropertyDict()
        else:
            self.opts = si.utils.PropertyDict(**opts)
        if not isinstance(self.opts, si.utils.PropertyDict):
            raise ValueError(f"{self.__class__.__name__} must get `opts` as a dictionary argument")

        # Check options passed and define defaults

        self.opts.setdefault("equation", "r")
        if self.opts.equation not in ' rs':
            # ' ' == non-polarized
            # s == polarized
            # r == relativistic
            raise ValueError(f"{self.__class__.__name__} failed to initialize; opts{'equation': <v>} has wrong value, should be [ rs].")

        self.opts.setdefault("flavor", "tm2")
        if self.opts.flavor not in ('hsc', 'ker', 'tm2'):
            # hsc == Hamann-Schluter-Chiang
            # ker == Kerker
            # tm2 == Troullier-Martins
            raise ValueError(f"{self.__class__.__name__} failed to initialize; opts{'flavor': <v>} has wrong value, should be [hsc|ker|tm2].")

        self.opts.setdefault("logr", 2.)

        self.opts.setdefault("cc", "rcore" in self.opts)
        # rcore only used if cc is True
        self.opts.setdefault("rcore", 2.)
        self.opts.setdefault("xc", "pb")

        # Store the defined names
        if define is None:
            self.define = []
        elif isinstance(define, str):
            self.define = [define]
        else:
            # must be list-like
            self.define = define

    def _write_header(self, f):
        f.write("# This file is generated by sisl pseudo\n")
        # Define all names
        for define in self.define:
            f.write(f"%define {define.upper()}\n")

    def _write_middle(self, f):
        xc = self.opts.xc
        equation = self.opts.equation
        rcore = self.opts.rcore * _Ang2Bohr
        f.write(f"   {self.atom.symbol:2s}   {xc}{equation}\n")
        f.write(f"  {0.0:5.1f}\n")
        # now extract the charges for each orbital
        atom = self.atom
        core, vals = _orbs_core_val[atom.symbol]
        assert len(atom.orbitals) == vals
        f.write(f"{core:5d}{vals:5d}\n")

        orbs = sorted(atom.orbitals, key=lambda x: x.l)
        Rs = [0.] * 4 # always 4: s, p, d, f
        for orb in orbs:
            # Write the configuration of this orbital
            n = orb.n
            l = orb.l
            # for now this is a single integer
            q0 = orb.q0
            f.write(f"{n:5d}{l:5d}{q0:10.3f}{0.0:10.3f}\n")
            Rs[l] = orb.R * _Ang2Bohr
        f.write(f"{Rs[0]:10.7f} {Rs[1]:10.7f} {Rs[2]:10.7f} {Rs[3]:10.7f} {0.0:10.7f} {rcore:10.7f}\n")

    def _get_out(self, path):
        if path is None:
            return "INP"
        return Path(path) / "INP"

    def ae(self, path=None):
        out = self._get_out(path)
        with open(out, 'w') as f:
            self._write_header(f)
            # Now prepare data
            f.write(f"   ae {self.atom.symbol} ground state calculation\n")
            self._write_middle(f)

    def pg(self, path=None):
        # check whether we need core corrections
        out = self._get_out(path)
        if self.opts.cc:
            # use core corrections
            pg = "pe"
        else:
            # do not use core corrections
            pg = "pg"
        logr = self.opts.logr * _Ang2Bohr
        with open(out, 'w') as f:
            self._write_header(f)
            # Now prepare data
            f.write(f"   {pg:2s} {self.atom.symbol} pseudo potential generation\n")
            if logr < 0.:
                f.write(f"        {self.opts.flavor:3s}\n")
            else:
                f.write(f"        {self.opts.flavor:3s}{logr:9.3f}\n")
            self._write_middle(f)

    def get_variables(self, dict_or_yaml):
        """ Convert a dictionary or yaml file input to variables usable by the minimizer """
        if not isinstance(dict_or_yaml, dict):
            # Then it must be a yaml file
            import yaml
            yaml_dict = yaml.load(open(dict_or_yaml, 'r'), Loader=yaml.CLoader)
            dict_or_yaml = yaml_dict[self.atom.tag]
        return self._get_variables_dict(dict_or_yaml)

    def _get_variables_dict(self, dic):
        """ Parse a dictionary adding potential variables to the minimize model """
        symbol = self.atom.tag
        V = []
        if len(dic) == 0:
            return V

        # Now loop and find coincidences in the dictionary
        # with respect to the basis
        def update_orb(old, new, orb):
            """ Update an orbital's radii """
            orb._R = new

        # Define other options
        def update(old, new, d, key, idx=None):
            """ An updater for a dictionary with optional keys """
            if idx is None:
                d[key] = new
            else:
                d[key][idx] = new

        # Now parse dictionary for nl
        # Loop keys to figure out what is there
        for key, value in dic.items():
            # we don't need to parse POLARIZATION
            # since that is implicitly handled
            l = 'spdf'.find(key)
            if 0 <= l:
                # Extract values
                v0 = value["initial"]
                bounds = value["bounds"]
                delta = value["delta"]

                found = False
                for orb in self.atom:
                    if orb.l == l:
                        found = True
                        # Ensure it is defined
                        var = UpdateVariable(f"{symbol}.{key}", v0, bounds,
                                             partial(update_orb, orb=orb),
                                             delta=delta)
                        V.append(var)
                if not found:
                    raise ValueError(f"Could not find l={l} shell in the orbitals?")

            elif key in ("core_correction", "core", "rcore"):
                # Extract values
                v0 = value["initial"]
                bounds = value["bounds"]
                delta = value["delta"]
                # Ensure it is enabled
                self.opts["cc"] = True
                var = UpdateVariable(f"{symbol}.core", v0, bounds,
                                     partial(update, d=self.opts, key="rcore"),
                                     delta=delta)
                V.append(var)

            elif key in ("log_radii", "logr"):
                # Extract values
                v0 = value["initial"]
                bounds = value["bounds"]
                delta = value["delta"]
                var = UpdateVariable(f"{symbol}.logr", v0, bounds,
                                     partial(update, d=self.opts, key="logr"),
                                     delta=delta)
                V.append(var)

            else:
                raise ValueError(f"Could not find something useful to do with: {key} = {value}, a typo perhaps?")

        return V

    @classmethod
    def plot(cls, path=None):
        """ Plot everything related to this psf file """
        from subprocess import run
        import matplotlib.pyplot as plt
        if path is None:
            path = Path.cwd()
        else:
            path = Path(path)

        # Now plot data
        def plot_file(ax, f, label, *args, yfactors=None, xfactors=None, **kwargs):
            f = path / f
            if not f.is_file():
                return

            data = np.loadtxt(f)
            ncol = data.shape[1]

            if xfactors is None:
                xfactors = [1]
            xfactors = np.pad(xfactors, (0, ncol-len(xfactors)), constant_values=0.)
            if yfactors is None:
                yfactors = [0, 1]
            yfactors = np.pad(yfactors, (0, ncol-len(yfactors)), constant_values=0.)

            xmark = None
            if "xmark" in kwargs:
                xmark = np.loadtxt(kwargs.pop("xmark"))
                if xmark.ndim == 1:
                    xmark.shape = (1, -1)
                xmark = xmark[:, 0]

            x = (data * xfactors.reshape(1, -1)).sum(1)
            y = (data * yfactors.reshape(1, -1)).sum(1)
            p = ax.plot(x, y, *args, **kwargs, label=label)

            if not xmark is None:
                xloc = (np.fabs(x.reshape(-1, 1) - xmark.reshape(1, -1))
                        .argmin(axis=0))
                ax.scatter(xmark, y[xloc], color=p[0].get_color(), alpha=0.5)

            return x, y

        spdf = 'spdf'

        fig, axs = plt.subplots(2, 2)
        # ae.gplot
        axs[0][0].set_title("Wavefunction")
        axs[0][0].set_xlabel("Radius [Bohr]")
        for i, shell in zip(range(4), spdf):
            plot_file(axs[0][0], f"AEWFNR{i}", f"AE {shell}")
            plot_file(axs[0][0], f"PSWFNR{i}", f"PS {shell}", '--')
            plot_file(axs[0][0], f"PTWFNR{i}", f"PT {shell}", '.')
        # no more than 7 bohr
        axs[0][0].set_xlim(0, 7)
        axs[0][0].legend()

        axs[1][0].set_title("Charge")
        axs[1][0].set_xlabel("Radius [Bohr]")
        axs[1][0].set_ylabel("(4.pi.r^2) Charge [electrons/Bohr]")
        ae_cc = plot_file(axs[1][0], "AECHARGE", "AE core charge",
                          yfactors=[0, 0, 0, 1])
        plot_file(axs[1][0], "AECHARGE", "AE valence charge",
                  yfactors=[0, 1, 1, -1])
        plot_file(axs[1][0], "PSCHARGE", "PS core charge",
                  yfactors=[0, 0, 0, 1])
        ps_vc = plot_file(axs[1][0], "PSCHARGE", "PS valence charge", '--',
                          yfactors=[0, 1, 1])
        plot_file(axs[1][0], "PTCHARGE", "PT core charge",
                  yfactors=[0, 0, 0, 1])
        plot_file(axs[1][0], "PTCHARGE", "PT valence charge", '.',
                  yfactors=[0, 1, 1])
        # Calculate overlap of all-electron core charge and
        # pseudopotential valence charge
        if np.allclose(ae_cc[0], ps_vc[0]):
            dr = ae_cc[0][1] - ae_cc[0][0]
            core_c = np.trapz(ae_cc[1], ae_cc[0])
            valence_c = np.trapz(ps_vc[1], ps_vc[0])
            print(f"Total charge in atom: {core_c + valence_c:.5f}")
            overlap_c = np.trapz(np.minimum(ae_cc[1], ps_vc[1]),
                                 ae_cc[0])
            axs[1][0].set_title(f"Charge: int(min(AE_cc, PS_vc)) = {overlap_c:.3f} e")

            # We will try and *guess-stimate* a good position for rc for core-corrections
            # Javier Junquera's document says:
            # r_pc has to be chosen such that the valence charge density is negligeable compared to
            # the core one for r < r_pc.
            # Tests show that it might be located where the core charge density is from 1 to 2 times
            # larger than the valence charge density
            core_over_valence = ae_cc[1] / ps_vc[1]
            ax2 = axs[1][0].twinx() # instantiate a second axes that shares the same x-axis
            ax2.plot(ae_cc[0], core_over_valence, 'k', alpha=0.5)
            # Now mark 1, 1.5 and 2 times
            factor_marks = [2., 1.5, 1]
            r_marks = []
            for mark in factor_marks:
                idx = (core_over_valence > mark).nonzero()[0][-1]
                r_marks.append(ae_cc[0][idx])
            ax2.scatter(r_marks, factor_marks, alpha=0.5)
            ax2.set_ylim(0, 3)
            print(f"Core-correction r_pc *probably around*: ({factor_marks}) {r_marks} Bohr")
        # no more than 4 bohr
        axs[1][0].set_xlim(0, 4)
        axs[1][0].set_ylim(0)
        axs[1][0].legend()

        axs[1][1].set_title("d-log of wavefunction")
        axs[1][1].set_xlabel("Energy [Ry]")
        axs[1][1].set_ylabel("Derivative of wavefunction")
        for i, shell in zip(range(4), spdf):
            plot_file(axs[1][1], f"AELOGD{i}", f"AE {shell}", xmark=f"AEEV{i}")
            plot_file(axs[1][1], f"PSLOGD{i}", f"PS {shell}", '--', xmark=f"PSEV{i}")
        axs[1][1].legend()

        axs[0][1].set_title("Pseudopotential")
        axs[0][1].set_xlabel("Radius [Bohr]")
        axs[0][1].set_ylabel("Potential [Ry]")
        for i, shell in zip(range(4), spdf):
            plot_file(axs[0][1], f"PSPOTR{i}", shell)
        # no more than 7 bohr
        axs[0][1].set_xlim(0, 7)
        axs[0][1].legend()

        plt.show()


_script = Path(sys.argv[0]).name


def atom_plot_cli(subp=None):
    """ Run plotting command for the output of atom """

    is_sub = not subp is None

    title = "Plotting facility for atom output"
    if is_sub:
        global _script
        _script = f"{_script} atom-plot"
        p = subp.add_parser("atom-plot", description=title, help=title)
    else:
        p = argp.ArgumentParser(title)

    p.add_argument("--directory", "-D",
                   help="""Directory to find atom output files""")

    if is_sub:
        p.set_defaults(runner=atom_plot)
    else:
        atom_plot(p.parse_args())


def atom_plot(args):
    pass
